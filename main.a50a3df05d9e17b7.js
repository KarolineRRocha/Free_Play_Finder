"use strict"; (self.webpackChunkFreePlayFinder = self.webpackChunkFreePlayFinder || []).push([[792], { 327: () => { function Bi(e, n) { return Object.is(e, n) } let Oe = null, ho = !1, po = 1; const Wt = Symbol("SIGNAL"); function W(e) { const n = Oe; return Oe = e, n } const Fa = { version: 0, lastCleanEpoch: 0, dirty: !1, producerNode: void 0, producerLastReadVersion: void 0, producerIndexOfThis: void 0, nextProducerIndex: 0, liveConsumerNode: void 0, liveConsumerIndexOfThis: void 0, consumerAllowSignalWrites: !1, consumerIsAlwaysLive: !1, producerMustRecompute: () => !1, producerRecomputeValue: () => { }, consumerMarkedDirty: () => { }, consumerOnSignalRead: () => { } }; function Zu(e) { if (ho) throw new Error(""); if (null === Oe) return; Oe.consumerOnSignalRead(e); const n = Oe.nextProducerIndex++; Va(Oe), n < Oe.producerNode.length && Oe.producerNode[n] !== e && Ui(Oe) && La(Oe.producerNode[n], Oe.producerIndexOfThis[n]), Oe.producerNode[n] !== e && (Oe.producerNode[n] = e, Oe.producerIndexOfThis[n] = Ui(Oe) ? _m(e, Oe, n) : 0), Oe.producerLastReadVersion[n] = e.version } function gm(e) { if ((!Ui(e) || e.dirty) && (e.dirty || e.lastCleanEpoch !== po)) { if (!e.producerMustRecompute(e) && !Yu(e)) return e.dirty = !1, void (e.lastCleanEpoch = po); e.producerRecomputeValue(e), e.dirty = !1, e.lastCleanEpoch = po } } function mm(e) { if (void 0 === e.liveConsumerNode) return; const n = ho; ho = !0; try { for (const t of e.liveConsumerNode) t.dirty || ym(t) } finally { ho = n } } function vm() { return !1 !== Oe?.consumerAllowSignalWrites } function ym(e) { e.dirty = !0, mm(e), e.consumerMarkedDirty?.(e) } function ka(e) { return e && (e.nextProducerIndex = 0), W(e) } function Qu(e, n) { if (W(n), e && void 0 !== e.producerNode && void 0 !== e.producerIndexOfThis && void 0 !== e.producerLastReadVersion) { if (Ui(e)) for (let t = e.nextProducerIndex; t < e.producerNode.length; t++)La(e.producerNode[t], e.producerIndexOfThis[t]); for (; e.producerNode.length > e.nextProducerIndex;)e.producerNode.pop(), e.producerLastReadVersion.pop(), e.producerIndexOfThis.pop() } } function Yu(e) { Va(e); for (let n = 0; n < e.producerNode.length; n++) { const t = e.producerNode[n], r = e.producerLastReadVersion[n]; if (r !== t.version || (gm(t), r !== t.version)) return !0 } return !1 } function Ju(e) { if (Va(e), Ui(e)) for (let n = 0; n < e.producerNode.length; n++)La(e.producerNode[n], e.producerIndexOfThis[n]); e.producerNode.length = e.producerLastReadVersion.length = e.producerIndexOfThis.length = 0, e.liveConsumerNode && (e.liveConsumerNode.length = e.liveConsumerIndexOfThis.length = 0) } function _m(e, n, t) { if (Cm(e), 0 === e.liveConsumerNode.length && Dm(e)) for (let r = 0; r < e.producerNode.length; r++)e.producerIndexOfThis[r] = _m(e.producerNode[r], e, r); return e.liveConsumerIndexOfThis.push(t), e.liveConsumerNode.push(n) - 1 } function La(e, n) { if (Cm(e), 1 === e.liveConsumerNode.length && Dm(e)) for (let r = 0; r < e.producerNode.length; r++)La(e.producerNode[r], e.producerIndexOfThis[r]); const t = e.liveConsumerNode.length - 1; if (e.liveConsumerNode[n] = e.liveConsumerNode[t], e.liveConsumerIndexOfThis[n] = e.liveConsumerIndexOfThis[t], e.liveConsumerNode.length--, e.liveConsumerIndexOfThis.length--, n < e.liveConsumerNode.length) { const r = e.liveConsumerIndexOfThis[n], o = e.liveConsumerNode[n]; Va(o), o.producerIndexOfThis[r] = n } } function Ui(e) { return e.consumerIsAlwaysLive || (e?.liveConsumerNode?.length ?? 0) > 0 } function Va(e) { e.producerNode ??= [], e.producerIndexOfThis ??= [], e.producerLastReadVersion ??= [] } function Cm(e) { e.liveConsumerNode ??= [], e.liveConsumerIndexOfThis ??= [] } function Dm(e) { return void 0 !== e.producerNode } const Xu = Symbol("UNSET"), Ku = Symbol("COMPUTING"), ja = Symbol("ERRORED"), HS = { ...Fa, value: Xu, dirty: !0, error: null, equal: Bi, producerMustRecompute: e => e.value === Xu || e.value === Ku, producerRecomputeValue(e) { if (e.value === Ku) throw new Error("Detected cycle in computations."); const n = e.value; e.value = Ku; const t = ka(e); let r; try { r = e.computation() } catch (o) { r = ja, e.error = o } finally { Qu(e, t) } n !== Xu && n !== ja && r !== ja && e.equal(n, r) ? e.value = n : (e.value = r, e.version++) } }; let wm = function GS() { throw new Error }; function bm() { wm() } let Ba = null; function Em(e, n) { vm() || bm(), e.equal(e.value, n) || (e.value = n, function QS(e) { e.version++, function US() { po++ }(), mm(e), Ba?.() }(e)) } const ZS = { ...Fa, equal: Bi, value: void 0 }; function _e(e) { return "function" == typeof e } function ed(e) { const t = e(r => { Error.call(r), r.stack = (new Error).stack }); return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t } const td = ed(e => function (t) { e(this), this.message = t ? `${t.length} errors occurred during unsubscription:\n${t.map((r, o) => `${o + 1}) ${r.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = t }); function nd(e, n) { if (e) { const t = e.indexOf(n); 0 <= t && e.splice(t, 1) } } class at { constructor(n) { this.initialTeardown = n, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let n; if (!this.closed) { this.closed = !0; const { _parentage: t } = this; if (t) if (this._parentage = null, Array.isArray(t)) for (const i of t) i.remove(this); else t.remove(this); const { initialTeardown: r } = this; if (_e(r)) try { r() } catch (i) { n = i instanceof td ? i.errors : [i] } const { _finalizers: o } = this; if (o) { this._finalizers = null; for (const i of o) try { Tm(i) } catch (s) { n = n ?? [], s instanceof td ? n = [...n, ...s.errors] : n.push(s) } } if (n) throw new td(n) } } add(n) { var t; if (n && n !== this) if (this.closed) Tm(n); else { if (n instanceof at) { if (n.closed || n._hasParent(this)) return; n._addParent(this) } (this._finalizers = null !== (t = this._finalizers) && void 0 !== t ? t : []).push(n) } } _hasParent(n) { const { _parentage: t } = this; return t === n || Array.isArray(t) && t.includes(n) } _addParent(n) { const { _parentage: t } = this; this._parentage = Array.isArray(t) ? (t.push(n), t) : t ? [t, n] : n } _removeParent(n) { const { _parentage: t } = this; t === n ? this._parentage = null : Array.isArray(t) && nd(t, n) } remove(n) { const { _finalizers: t } = this; t && nd(t, n), n instanceof at && n._removeParent(this) } } at.EMPTY = (() => { const e = new at; return e.closed = !0, e })(); const Im = at.EMPTY; function Sm(e) { return e instanceof at || e && "closed" in e && _e(e.remove) && _e(e.add) && _e(e.unsubscribe) } function Tm(e) { _e(e) ? e() : e.unsubscribe() } const Ir = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, Ua = { setTimeout(e, n, ...t) { const { delegate: r } = Ua; return r?.setTimeout ? r.setTimeout(e, n, ...t) : setTimeout(e, n, ...t) }, clearTimeout(e) { const { delegate: n } = Ua; return (n?.clearTimeout || clearTimeout)(e) }, delegate: void 0 }; function Am(e) { Ua.setTimeout(() => { const { onUnhandledError: n } = Ir; if (!n) throw e; n(e) }) } function rd() { } const JS = od("C", void 0, void 0); function od(e, n, t) { return { kind: e, value: n, error: t } } let Sr = null; function $a(e) { if (Ir.useDeprecatedSynchronousErrorHandling) { const n = !Sr; if (n && (Sr = { errorThrown: !1, error: null }), e(), n) { const { errorThrown: t, error: r } = Sr; if (Sr = null, t) throw r } } else e() } class id extends at { constructor(n) { super(), this.isStopped = !1, n ? (this.destination = n, Sm(n) && n.add(this)) : this.destination = oT } static create(n, t, r) { return new ad(n, t, r) } next(n) { this.isStopped ? cd(function KS(e) { return od("N", e, void 0) }(n), this) : this._next(n) } error(n) { this.isStopped ? cd(function XS(e) { return od("E", void 0, e) }(n), this) : (this.isStopped = !0, this._error(n)) } complete() { this.isStopped ? cd(JS, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(n) { this.destination.next(n) } _error(n) { try { this.destination.error(n) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const tT = Function.prototype.bind; function sd(e, n) { return tT.call(e, n) } class nT { constructor(n) { this.partialObserver = n } next(n) { const { partialObserver: t } = this; if (t.next) try { t.next(n) } catch (r) { Ha(r) } } error(n) { const { partialObserver: t } = this; if (t.error) try { t.error(n) } catch (r) { Ha(r) } else Ha(n) } complete() { const { partialObserver: n } = this; if (n.complete) try { n.complete() } catch (t) { Ha(t) } } } class ad extends id { constructor(n, t, r) { let o; if (super(), _e(n) || !n) o = { next: n ?? void 0, error: t ?? void 0, complete: r ?? void 0 }; else { let i; this && Ir.useDeprecatedNextContext ? (i = Object.create(n), i.unsubscribe = () => this.unsubscribe(), o = { next: n.next && sd(n.next, i), error: n.error && sd(n.error, i), complete: n.complete && sd(n.complete, i) }) : o = n } this.destination = new nT(o) } } function Ha(e) { Ir.useDeprecatedSynchronousErrorHandling ? function eT(e) { Ir.useDeprecatedSynchronousErrorHandling && Sr && (Sr.errorThrown = !0, Sr.error = e) }(e) : Am(e) } function cd(e, n) { const { onStoppedNotification: t } = Ir; t && Ua.setTimeout(() => t(e, n)) } const oT = { closed: !0, next: rd, error: function rT(e) { throw e }, complete: rd }, ld = "function" == typeof Symbol && Symbol.observable || "@@observable"; function Tr(e) { return e } function Nm(e) { return 0 === e.length ? Tr : 1 === e.length ? e[0] : function (t) { return e.reduce((r, o) => o(r), t) } } let ke = (() => { class e { constructor(t) { t && (this._subscribe = t) } lift(t) { const r = new e; return r.source = this, r.operator = t, r } subscribe(t, r, o) { const i = function aT(e) { return e && e instanceof id || function sT(e) { return e && _e(e.next) && _e(e.error) && _e(e.complete) }(e) && Sm(e) }(t) ? t : new ad(t, r, o); return $a(() => { const { operator: s, source: a } = this; i.add(s ? s.call(i, a) : a ? this._subscribe(i) : this._trySubscribe(i)) }), i } _trySubscribe(t) { try { return this._subscribe(t) } catch (r) { t.error(r) } } forEach(t, r) { return new (r = Om(r))((o, i) => { const s = new ad({ next: a => { try { t(a) } catch (c) { i(c), s.unsubscribe() } }, error: i, complete: o }); this.subscribe(s) }) } _subscribe(t) { var r; return null === (r = this.source) || void 0 === r ? void 0 : r.subscribe(t) } [ld]() { return this } pipe(...t) { return Nm(t)(this) } toPromise(t) { return new (t = Om(t))((r, o) => { let i; this.subscribe(s => i = s, s => o(s), () => r(i)) }) } } return e.create = n => new e(n), e })(); function Om(e) { var n; return null !== (n = e ?? Ir.Promise) && void 0 !== n ? n : Promise } const cT = ed(e => function () { e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let It = (() => { class e extends ke { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(t) { const r = new xm(this, this); return r.operator = t, r } _throwIfClosed() { if (this.closed) throw new cT } next(t) { $a(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const r of this.currentObservers) r.next(t) } }) } error(t) { $a(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = t; const { observers: r } = this; for (; r.length;)r.shift().error(t) } }) } complete() { $a(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: t } = this; for (; t.length;)t.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var t; return (null === (t = this.observers) || void 0 === t ? void 0 : t.length) > 0 } _trySubscribe(t) { return this._throwIfClosed(), super._trySubscribe(t) } _subscribe(t) { return this._throwIfClosed(), this._checkFinalizedStatuses(t), this._innerSubscribe(t) } _innerSubscribe(t) { const { hasError: r, isStopped: o, observers: i } = this; return r || o ? Im : (this.currentObservers = null, i.push(t), new at(() => { this.currentObservers = null, nd(i, t) })) } _checkFinalizedStatuses(t) { const { hasError: r, thrownError: o, isStopped: i } = this; r ? t.error(o) : i && t.complete() } asObservable() { const t = new ke; return t.source = this, t } } return e.create = (n, t) => new xm(n, t), e })(); class xm extends It { constructor(n, t) { super(), this.destination = n, this.source = t } next(n) { var t, r; null === (r = null === (t = this.destination) || void 0 === t ? void 0 : t.next) || void 0 === r || r.call(t, n) } error(n) { var t, r; null === (r = null === (t = this.destination) || void 0 === t ? void 0 : t.error) || void 0 === r || r.call(t, n) } complete() { var n, t; null === (t = null === (n = this.destination) || void 0 === n ? void 0 : n.complete) || void 0 === t || t.call(n) } _subscribe(n) { var t, r; return null !== (r = null === (t = this.source) || void 0 === t ? void 0 : t.subscribe(n)) && void 0 !== r ? r : Im } } class Vt extends It { constructor(n) { super(), this._value = n } get value() { return this.getValue() } _subscribe(n) { const t = super._subscribe(n); return !t.closed && n.next(this._value), t } getValue() { const { hasError: n, thrownError: t, _value: r } = this; if (n) throw t; return this._throwIfClosed(), r } next(n) { super.next(this._value = n) } } function Rm(e) { return _e(e?.lift) } function Xe(e) { return n => { if (Rm(n)) return n.lift(function (t) { try { return e(t, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function Ue(e, n, t, r, o) { return new lT(e, n, t, r, o) } class lT extends id { constructor(n, t, r, o, i, s) { super(n), this.onFinalize = i, this.shouldUnsubscribe = s, this._next = t ? function (a) { try { t(a) } catch (c) { n.error(c) } } : super._next, this._error = o ? function (a) { try { o(a) } catch (c) { n.error(c) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { n.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var n; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: t } = this; super.unsubscribe(), !t && (null === (n = this.onFinalize) || void 0 === n || n.call(this)) } } } function K(e, n) { return Xe((t, r) => { let o = 0; t.subscribe(Ue(r, i => { r.next(e.call(n, i, o++)) })) }) } const Pm = "https://g.co/ng/security#xss"; class w extends Error { constructor(n, t) { super(function go(e, n) { return `NG0${Math.abs(e)}${n ? ": " + n : ""}` }(n, t)), this.code = n } } function jn(e) { return { toString: e }.toString() } const vo = "__parameters__"; function _o(e, n, t) { return jn(() => { const r = function ud(e) { return function (...t) { if (e) { const r = e(...t); for (const o in r) this[o] = r[o] } } }(n); function o(...i) { if (this instanceof o) return r.apply(this, i), this; const s = new o(...i); return a.annotation = s, a; function a(c, l, u) { const d = c.hasOwnProperty(vo) ? c[vo] : Object.defineProperty(c, vo, { value: [] })[vo]; for (; d.length <= u;)d.push(null); return (d[u] = d[u] || []).push(s), c } } return t && (o.prototype = Object.create(t.prototype)), o.prototype.ngMetadataName = e, o.annotationCls = o, o }) } const Ce = globalThis; function ce(e) { for (let n in e) if (e[n] === ce) return n; throw Error("Could not find renamed property on target object.") } function uT(e, n) { for (const t in n) n.hasOwnProperty(t) && !e.hasOwnProperty(t) && (e[t] = n[t]) } function $e(e) { if ("string" == typeof e) return e; if (Array.isArray(e)) return "[" + e.map($e).join(", ") + "]"; if (null == e) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; const n = e.toString(); if (null == n) return "" + n; const t = n.indexOf("\n"); return -1 === t ? n : n.substring(0, t) } function dd(e, n) { return null == e || "" === e ? null === n ? "" : n : null == n || "" === n ? e : e + " " + n } const dT = ce({ __forward_ref__: ce }); function pe(e) { return e.__forward_ref__ = pe, e.toString = function () { return $e(this()) }, e } function V(e) { return za(e) ? e() : e } function za(e) { return "function" == typeof e && e.hasOwnProperty(dT) && e.__forward_ref__ === pe } function N(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function Ar(e) { return { providers: e.providers || [], imports: e.imports || [] } } function qa(e) { return Vm(e, Za) || Vm(e, jm) } function Vm(e, n) { return e.hasOwnProperty(n) ? e[n] : null } function Wa(e) { return e && (e.hasOwnProperty(fd) || e.hasOwnProperty(vT)) ? e[fd] : null } const Za = ce({ \u0275prov: ce }), fd = ce({ \u0275inj: ce }), jm = ce({ ngInjectableDef: ce }), vT = ce({ ngInjectorDef: ce }); class T { constructor(n, t) { this._desc = n, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof t ? this.__NG_ELEMENT_ID__ = t : void 0 !== t && (this.\u0275prov = N({ token: this, providedIn: t.providedIn || "root", factory: t.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } function vd(e) { return e && !!e.\u0275providers } const $i = ce({ \u0275cmp: ce }), yd = ce({ \u0275dir: ce }), _d = ce({ \u0275pipe: ce }), Um = ce({ \u0275mod: ce }), Bn = ce({ \u0275fac: ce }), Hi = ce({ __NG_ELEMENT_ID__: ce }), $m = ce({ __NG_ENV_ID__: ce }); function H(e) { return "string" == typeof e ? e : null == e ? "" : String(e) } function Cd(e, n) { throw new w(-201, !1) } var J = function (e) { return e[e.Default = 0] = "Default", e[e.Host = 1] = "Host", e[e.Self = 2] = "Self", e[e.SkipSelf = 4] = "SkipSelf", e[e.Optional = 8] = "Optional", e }(J || {}); let Dd; function Hm() { return Dd } function _t(e) { const n = Dd; return Dd = e, n } function Gm(e, n, t) { const r = qa(e); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : t & J.Optional ? null : void 0 !== n ? n : void Cd() } const Gi = {}, wd = "__NG_DI_FLAG__", Qa = "ngTempTokenPath", bT = /\n/gm, zm = "__source"; let Co; function or(e) { const n = Co; return Co = e, n } function IT(e, n = J.Default) { if (void 0 === Co) throw new w(-203, !1); return null === Co ? Gm(e, void 0, n) : Co.get(e, n & J.Optional ? null : void 0, n) } function x(e, n = J.Default) { return (Hm() || IT)(V(e), n) } function b(e, n = J.Default) { return x(e, Ya(n)) } function Ya(e) { return typeof e > "u" || "number" == typeof e ? e : (e.optional && 8) | (e.host && 1) | (e.self && 2) | (e.skipSelf && 4) } function bd(e) { const n = []; for (let t = 0; t < e.length; t++) { const r = V(e[t]); if (Array.isArray(r)) { if (0 === r.length) throw new w(900, !1); let o, i = J.Default; for (let s = 0; s < r.length; s++) { const a = r[s], c = ST(a); "number" == typeof c ? -1 === c ? o = a.token : i |= c : o = a } n.push(x(o, i)) } else n.push(x(r)) } return n } function zi(e, n) { return e[wd] = n, e.prototype[wd] = n, e } function ST(e) { return e[wd] } const Ja = zi(_o("Optional"), 8), Xa = zi(_o("SkipSelf"), 4); function Nr(e, n) { return e.hasOwnProperty(Bn) ? e[Bn] : null } function Do(e, n) { e.forEach(t => Array.isArray(t) ? Do(t, n) : n(t)) } function Wm(e, n, t) { n >= e.length ? e.push(t) : e.splice(n, 0, t) } function Ka(e, n) { return n >= e.length - 1 ? e.pop() : e.splice(n, 1)[0] } function At(e, n, t) { let r = wo(e, n); return r >= 0 ? e[1 | r] = t : (r = ~r, function Zm(e, n, t, r) { let o = e.length; if (o == n) e.push(t, r); else if (1 === o) e.push(r, e[0]), e[0] = t; else { for (o--, e.push(e[o - 1], e[o]); o > n;)e[o] = e[o - 2], o--; e[n] = t, e[n + 1] = r } }(e, r, n, t)), r } function Md(e, n) { const t = wo(e, n); if (t >= 0) return e[1 | t] } function wo(e, n) { return function Qm(e, n, t) { let r = 0, o = e.length >> t; for (; o !== r;) { const i = r + (o - r >> 1), s = e[i << t]; if (n === s) return i << t; s > n ? o = i : r = i + 1 } return ~(o << t) }(e, n, 1) } const hn = {}, ee = [], pn = new T(""), Ym = new T("", -1), Id = new T(""); class tc { get(n, t = Gi) { if (t === Gi) { const r = new Error(`NullInjectorError: No provider for ${$e(n)}!`); throw r.name = "NullInjectorError", r } return t } } var nc = function (e) { return e[e.OnPush = 0] = "OnPush", e[e.Default = 1] = "Default", e }(nc || {}), Zt = function (e) { return e[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", e }(Zt || {}), ir = function (e) { return e[e.None = 0] = "None", e[e.SignalBased = 1] = "SignalBased", e[e.HasDecoratorInputTransform = 2] = "HasDecoratorInputTransform", e }(ir || {}); function PT(e, n, t) { let r = e.length; for (; ;) { const o = e.indexOf(n, t); if (-1 === o) return o; if (0 === o || e.charCodeAt(o - 1) <= 32) { const i = n.length; if (o + i === r || e.charCodeAt(o + i) <= 32) return o } t = o + 1 } } function Sd(e, n, t) { let r = 0; for (; r < t.length;) { const o = t[r]; if ("number" == typeof o) { if (0 !== o) break; r++; const i = t[r++], s = t[r++], a = t[r++]; e.setAttribute(n, s, a, i) } else { const i = o, s = t[++r]; Xm(i) ? e.setProperty(n, i, s) : e.setAttribute(n, i, s), r++ } } return r } function Jm(e) { return 3 === e || 4 === e || 6 === e } function Xm(e) { return 64 === e.charCodeAt(0) } function qi(e, n) { if (null !== n && 0 !== n.length) if (null === e || 0 === e.length) e = n.slice(); else { let t = -1; for (let r = 0; r < n.length; r++) { const o = n[r]; "number" == typeof o ? t = o : 0 === t || Km(e, t, o, null, -1 === t || 2 === t ? n[++r] : null) } } return e } function Km(e, n, t, r, o) { let i = 0, s = e.length; if (-1 === n) s = -1; else for (; i < e.length;) { const a = e[i++]; if ("number" == typeof a) { if (a === n) { s = -1; break } if (a > n) { s = i - 1; break } } } for (; i < e.length;) { const a = e[i]; if ("number" == typeof a) break; if (a === t) { if (null === r) return void (null !== o && (e[i + 1] = o)); if (r === e[i + 1]) return void (e[i + 2] = o) } i++, null !== r && i++, null !== o && i++ } -1 !== s && (e.splice(s, 0, n), i = s + 1), e.splice(i++, 0, t), null !== r && e.splice(i++, 0, r), null !== o && e.splice(i++, 0, o) } const ev = "ng-template"; function FT(e, n, t, r) { let o = 0; if (r) { for (; o < n.length && "string" == typeof n[o]; o += 2)if ("class" === n[o] && -1 !== PT(n[o + 1].toLowerCase(), t, 0)) return !0 } else if (Td(e)) return !1; if (o = n.indexOf(1, o), o > -1) { let i; for (; ++o < n.length && "string" == typeof (i = n[o]);)if (i.toLowerCase() === t) return !0 } return !1 } function Td(e) { return 4 === e.type && e.value !== ev } function kT(e, n, t) { return n === (4 !== e.type || t ? e.value : ev) } function LT(e, n, t) { let r = 4; const o = e.attrs, i = null !== o ? function BT(e) { for (let n = 0; n < e.length; n++)if (Jm(e[n])) return n; return e.length }(o) : 0; let s = !1; for (let a = 0; a < n.length; a++) { const c = n[a]; if ("number" != typeof c) { if (!s) if (4 & r) { if (r = 2 | 1 & r, "" !== c && !kT(e, c, t) || "" === c && 1 === n.length) { if (Qt(r)) return !1; s = !0 } } else if (8 & r) { if (null === o || !FT(e, o, c, t)) { if (Qt(r)) return !1; s = !0 } } else { const l = n[++a], u = VT(c, o, Td(e), t); if (-1 === u) { if (Qt(r)) return !1; s = !0; continue } if ("" !== l) { let d; if (d = u > i ? "" : o[u + 1].toLowerCase(), 2 & r && l !== d) { if (Qt(r)) return !1; s = !0 } } } } else { if (!s && !Qt(r) && !Qt(c)) return !1; if (s && Qt(c)) continue; s = !1, r = c | 1 & r } } return Qt(r) || s } function Qt(e) { return !(1 & e) } function VT(e, n, t, r) { if (null === n) return -1; let o = 0; if (r || !t) { let i = !1; for (; o < n.length;) { const s = n[o]; if (s === e) return o; if (3 === s || 6 === s) i = !0; else { if (1 === s || 2 === s) { let a = n[++o]; for (; "string" == typeof a;)a = n[++o]; continue } if (4 === s) break; if (0 === s) { o += 4; continue } } o += i ? 1 : 2 } return -1 } return function UT(e, n) { let t = e.indexOf(4); if (t > -1) for (t++; t < e.length;) { const r = e[t]; if ("number" == typeof r) return -1; if (r === n) return t; t++ } return -1 }(n, e) } function tv(e, n, t = !1) { for (let r = 0; r < n.length; r++)if (LT(e, n[r], t)) return !0; return !1 } function nv(e, n) { return e ? ":not(" + n.trim() + ")" : n } function HT(e) { let n = e[0], t = 1, r = 2, o = "", i = !1; for (; t < e.length;) { let s = e[t]; if ("string" == typeof s) if (2 & r) { const a = e[++t]; o += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & r ? o += "." + s : 4 & r && (o += " " + s); else "" !== o && !Qt(s) && (n += nv(i, o), o = ""), r = s, i = i || !Qt(r); t++ } return "" !== o && (n += nv(i, o)), n } function gn(e) { return jn(() => { const n = ov(e), t = { ...n, decls: e.decls, vars: e.vars, template: e.template, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, onPush: e.changeDetection === nc.OnPush, directiveDefs: null, pipeDefs: null, dependencies: n.standalone && e.dependencies || null, getStandaloneInjector: null, signals: e.signals ?? !1, data: e.data || {}, encapsulation: e.encapsulation || Zt.Emulated, styles: e.styles || ee, _: null, schemas: e.schemas || null, tView: null, id: "" }; iv(t); const r = e.dependencies; return t.directiveDefs = rc(r, !1), t.pipeDefs = rc(r, !0), t.id = function QT(e) { let n = 0; const t = [e.selectors, e.ngContentSelectors, e.hostVars, e.hostAttrs, e.consts, e.vars, e.decls, e.encapsulation, e.standalone, e.signals, e.exportAs, JSON.stringify(e.inputs), JSON.stringify(e.outputs), Object.getOwnPropertyNames(e.type.prototype), !!e.contentQueries, !!e.viewQuery].join("|"); for (const o of t) n = Math.imul(31, n) + o.charCodeAt(0) | 0; return n += 2147483648, "c" + n }(t), t }) } function qT(e) { return Y(e) || He(e) } function WT(e) { return null !== e } function bo(e) { return jn(() => ({ type: e.type, bootstrap: e.bootstrap || ee, declarations: e.declarations || ee, imports: e.imports || ee, exports: e.exports || ee, transitiveCompileScopes: null, schemas: e.schemas || null, id: e.id || null })) } function rv(e, n) { if (null == e) return hn; const t = {}; for (const r in e) if (e.hasOwnProperty(r)) { const o = e[r]; let i, s, a = ir.None; Array.isArray(o) ? (a = o[0], i = o[1], s = o[2] ?? i) : (i = o, s = o), n ? (t[i] = a !== ir.None ? [r, a] : r, n[i] = s) : t[i] = r } return t } function $(e) { return jn(() => { const n = ov(e); return iv(n), n }) } function ct(e) { return { type: e.type, name: e.name, factory: null, pure: !1 !== e.pure, standalone: !0 === e.standalone, onDestroy: e.type.prototype.ngOnDestroy || null } } function Y(e) { return e[$i] || null } function He(e) { return e[yd] || null } function Ke(e) { return e[_d] || null } function nt(e, n) { const t = e[Um] || null; if (!t && !0 === n) throw new Error(`Type ${$e(e)} does not have '\u0275mod' property.`); return t } function ov(e) { const n = {}; return { type: e.type, providersResolver: null, factory: null, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: n, inputTransforms: null, inputConfig: e.inputs || hn, exportAs: e.exportAs || null, standalone: !0 === e.standalone, signals: !0 === e.signals, selectors: e.selectors || ee, viewQuery: e.viewQuery || null, features: e.features || null, setInput: null, findHostDirectiveDefs: null, hostDirectives: null, inputs: rv(e.inputs, n), outputs: rv(e.outputs), debugInfo: null } } function iv(e) { e.features?.forEach(n => n(e)) } function rc(e, n) { if (!e) return null; const t = n ? Ke : qT; return () => ("function" == typeof e ? e() : e).map(r => t(r)).filter(WT) } function Eo(e) { return { \u0275providers: e } } function YT(...e) { return { \u0275providers: Ad(0, e), \u0275fromNgModule: !0 } } function Ad(e, ...n) { const t = [], r = new Set; let o; const i = s => { t.push(s) }; return Do(n, s => { const a = s; oc(a, i, [], r) && (o ||= [], o.push(a)) }), void 0 !== o && sv(o, i), t } function sv(e, n) { for (let t = 0; t < e.length; t++) { const { ngModule: r, providers: o } = e[t]; Nd(o, i => { n(i, r) }) } } function oc(e, n, t, r) { if (!(e = V(e))) return !1; let o = null, i = Wa(e); const s = !i && Y(e); if (i || s) { if (s && !s.standalone) return !1; o = e } else { const c = e.ngModule; if (i = Wa(c), !i) return !1; o = c } const a = r.has(o); if (s) { if (a) return !1; if (r.add(o), s.dependencies) { const c = "function" == typeof s.dependencies ? s.dependencies() : s.dependencies; for (const l of c) oc(l, n, t, r) } } else { if (!i) return !1; { if (null != i.imports && !a) { let l; r.add(o); try { Do(i.imports, u => { oc(u, n, t, r) && (l ||= [], l.push(u)) }) } finally { } void 0 !== l && sv(l, n) } if (!a) { const l = Nr(o) || (() => new o); n({ provide: o, useFactory: l, deps: ee }, o), n({ provide: Id, useValue: o, multi: !0 }, o), n({ provide: pn, useValue: () => x(o), multi: !0 }, o) } const c = i.providers; if (null != c && !a) { const l = e; Nd(c, u => { n(u, l) }) } } } return o !== e && void 0 !== e.providers } function Nd(e, n) { for (let t of e) vd(t) && (t = t.\u0275providers), Array.isArray(t) ? Nd(t, n) : n(t) } const JT = ce({ provide: String, useValue: ce }); function Od(e) { return null !== e && "object" == typeof e && JT in e } function Or(e) { return "function" == typeof e } const xd = new T(""), ic = {}, KT = {}; let Rd; function sc() { return void 0 === Rd && (Rd = new tc), Rd } class lt { } class Mo extends lt { get destroyed() { return this._destroyed } constructor(n, t, r, o) { super(), this.parent = t, this.source = r, this.scopes = o, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, Fd(n, s => this.processProvider(s)), this.records.set(Ym, Io(void 0, this)), o.has("environment") && this.records.set(lt, Io(void 0, this)); const i = this.records.get(xd); null != i && "string" == typeof i.value && this.scopes.add(i.value), this.injectorDefTypes = new Set(this.get(Id, ee, J.Self)) } destroy() { this.assertNotDestroyed(), this._destroyed = !0; const n = W(null); try { for (const r of this._ngOnDestroyHooks) r.ngOnDestroy(); const t = this._onDestroyHooks; this._onDestroyHooks = []; for (const r of t) r() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), W(n) } } onDestroy(n) { return this.assertNotDestroyed(), this._onDestroyHooks.push(n), () => this.removeOnDestroy(n) } runInContext(n) { this.assertNotDestroyed(); const t = or(this), r = _t(void 0); try { return n() } finally { or(t), _t(r) } } get(n, t = Gi, r = J.Default) { if (this.assertNotDestroyed(), n.hasOwnProperty($m)) return n[$m](this); r = Ya(r); const i = or(this), s = _t(void 0); try { if (!(r & J.SkipSelf)) { let c = this.records.get(n); if (void 0 === c) { const l = function oA(e) { return "function" == typeof e || "object" == typeof e && e instanceof T }(n) && qa(n); c = l && this.injectableDefInScope(l) ? Io(Pd(n), ic) : null, this.records.set(n, c) } if (null != c) return this.hydrate(n, c) } return (r & J.Self ? sc() : this.parent).get(n, t = r & J.Optional && t === Gi ? null : t) } catch (a) { if ("NullInjectorError" === a.name) { if ((a[Qa] = a[Qa] || []).unshift($e(n)), i) throw a; return function TT(e, n, t, r) { const o = e[Qa]; throw n[zm] && o.unshift(n[zm]), e.message = function AT(e, n, t, r = null) { e = e && "\n" === e.charAt(0) && "\u0275" == e.charAt(1) ? e.slice(2) : e; let o = $e(n); if (Array.isArray(n)) o = n.map($e).join(" -> "); else if ("object" == typeof n) { let i = []; for (let s in n) if (n.hasOwnProperty(s)) { let a = n[s]; i.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : $e(a))) } o = `{${i.join(", ")}}` } return `${t}${r ? "(" + r + ")" : ""}[${o}]: ${e.replace(bT, "\n  ")}` }("\n" + e.message, o, t, r), e.ngTokenPath = o, e[Qa] = null, e }(a, n, "R3InjectorError", this.source) } throw a } finally { _t(s), or(i) } } resolveInjectorInitializers() { const n = W(null), t = or(this), r = _t(void 0); try { const i = this.get(pn, ee, J.Self); for (const s of i) s() } finally { or(t), _t(r), W(n) } } toString() { const n = [], t = this.records; for (const r of t.keys()) n.push($e(r)); return `R3Injector[${n.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new w(205, !1) } processProvider(n) { let t = Or(n = V(n)) ? n : V(n && n.provide); const r = function tA(e) { return Od(e) ? Io(void 0, e.useValue) : Io(lv(e), ic) }(n); if (!Or(n) && !0 === n.multi) { let o = this.records.get(t); o || (o = Io(void 0, ic, !0), o.factory = () => bd(o.multi), this.records.set(t, o)), t = n, o.multi.push(n) } this.records.set(t, r) } hydrate(n, t) { const r = W(null); try { return t.value === ic && (t.value = KT, t.value = t.factory()), "object" == typeof t.value && t.value && function rA(e) { return null !== e && "object" == typeof e && "function" == typeof e.ngOnDestroy }(t.value) && this._ngOnDestroyHooks.add(t.value), t.value } finally { W(r) } } injectableDefInScope(n) { if (!n.providedIn) return !1; const t = V(n.providedIn); return "string" == typeof t ? "any" === t || this.scopes.has(t) : this.injectorDefTypes.has(t) } removeOnDestroy(n) { const t = this._onDestroyHooks.indexOf(n); -1 !== t && this._onDestroyHooks.splice(t, 1) } } function Pd(e) { const n = qa(e), t = null !== n ? n.factory : Nr(e); if (null !== t) return t; if (e instanceof T) throw new w(204, !1); if (e instanceof Function) return function eA(e) { if (e.length > 0) throw new w(204, !1); const t = function mT(e) { return e && (e[Za] || e[jm]) || null }(e); return null !== t ? () => t.factory(e) : () => new e }(e); throw new w(204, !1) } function lv(e, n, t) { let r; if (Or(e)) { const o = V(e); return Nr(o) || Pd(o) } if (Od(e)) r = () => V(e.useValue); else if (function cv(e) { return !(!e || !e.useFactory) }(e)) r = () => e.useFactory(...bd(e.deps || [])); else if (function av(e) { return !(!e || !e.useExisting) }(e)) r = () => x(V(e.useExisting)); else { const o = V(e && (e.useClass || e.provide)); if (!function nA(e) { return !!e.deps }(e)) return Nr(o) || Pd(o); r = () => new o(...bd(e.deps)) } return r } function Io(e, n, t = !1) { return { factory: e, value: n, multi: t ? [] : void 0 } } function Fd(e, n) { for (const t of e) Array.isArray(t) ? Fd(t, n) : t && vd(t) ? Fd(t.\u0275providers, n) : n(t) } function mn(e, n) { e instanceof Mo && e.assertNotDestroyed(); const r = or(e), o = _t(void 0); try { return n() } finally { or(r), _t(o) } } function uv() { return void 0 !== Hm() || null != function MT() { return Co }() } const we = 0, S = 1, R = 2, Le = 3, Yt = 4, et = 5, ut = 6, To = 7, ge = 8, Ve = 9, vn = 10, j = 11, Zi = 12, fv = 13, Ao = 14, be = 15, xr = 16, No = 17, Un = 18, Oo = 19, hv = 20, ar = 21, cc = 22, jt = 23, O = 25, Vd = 1, yn = 7, xo = 9, xe = 10; var uc = function (e) { return e[e.None = 0] = "None", e[e.HasTransplantedViews = 2] = "HasTransplantedViews", e }(uc || {}); function ze(e) { return Array.isArray(e) && "object" == typeof e[Vd] } function rt(e) { return Array.isArray(e) && !0 === e[Vd] } function jd(e) { return !!(4 & e.flags) } function Rr(e) { return e.componentOffset > -1 } function dc(e) { return !(1 & ~e.flags) } function Jt(e) { return !!e.template } function Yi(e) { return !!(512 & e[R]) } class mA { constructor(n, t, r) { this.previousValue = n, this.currentValue = t, this.firstChange = r } isFirstChange() { return this.firstChange } } function yv(e, n, t, r) { null !== n ? n.applyValueToInputSignal(n, r) : e[t] = r } function Bt() { return _v } function _v(e) { return e.type.prototype.ngOnChanges && (e.setInput = yA), vA } function vA() { const e = Dv(this), n = e?.current; if (n) { const t = e.previous; if (t === hn) e.previous = n; else for (let r in n) t[r] = n[r]; e.current = null, this.ngOnChanges(n) } } function yA(e, n, t, r, o) { const i = this.declaredInputs[r], s = Dv(e) || function _A(e, n) { return e[Cv] = n }(e, { previous: hn, current: null }), a = s.current || (s.current = {}), c = s.previous, l = c[i]; a[i] = new mA(l && l.currentValue, t, c === hn), yv(e, n, o, t) } Bt.ngInherit = !0; const Cv = "__ngSimpleChanges__"; function Dv(e) { return e[Cv] || null } const _n = function (e, n, t) { }; function te(e) { for (; Array.isArray(e);)e = e[we]; return e } function Ji(e, n) { return te(n[e]) } function dt(e, n) { return te(n[e.index]) } function Xi(e, n) { return e.data[n] } function Pr(e, n) { return e[n] } function Nt(e, n) { const t = n[e]; return ze(t) ? t : t[we] } function Gd(e) { return !(128 & ~e[R]) } function Ut(e, n) { return null == n ? null : e[n] } function Ev(e) { e[No] = 0 } function Mv(e) { 1024 & e[R] || (e[R] |= 1024, Gd(e) && hc(e)) } function fc(e) { return !!(9216 & e[R] || e[jt]?.dirty) } function zd(e) { e[vn].changeDetectionScheduler?.notify(8), 64 & e[R] && (e[R] |= 1024), fc(e) && hc(e) } function hc(e) { e[vn].changeDetectionScheduler?.notify(0); let n = $n(e); for (; null !== n && !(8192 & n[R]) && (n[R] |= 8192, Gd(n));)n = $n(n) } function pc(e, n) { if (!(256 & ~e[R])) throw new w(911, !1); null === e[ar] && (e[ar] = []), e[ar].push(n) } function $n(e) { const n = e[Le]; return rt(n) ? n[Le] : n } const B = { lFrame: Vv(null), bindingsEnabled: !0, skipHydrationRootTNode: null }; let Sv = !1; function Tv() { return B.bindingsEnabled } function C() { return B.lFrame.lView } function Z() { return B.lFrame.tView } function Ie(e) { return B.lFrame.contextLView = e, e[ge] } function Se(e) { return B.lFrame.contextLView = null, e } function le() { let e = Av(); for (; null !== e && 64 === e.type;)e = e.parent; return e } function Av() { return B.lFrame.currentTNode } function Xt(e, n) { const t = B.lFrame; t.currentTNode = e, t.isParent = n } function Zd() { return B.lFrame.isParent } function xv() { return Sv } function Rv(e) { Sv = e } function ft() { const e = B.lFrame; let n = e.bindingRootIndex; return -1 === n && (n = e.bindingRootIndex = e.tView.bindingStartIndex), n } function Kt() { return B.lFrame.bindingIndex++ } function Gn(e) { const n = B.lFrame, t = n.bindingIndex; return n.bindingIndex = n.bindingIndex + e, t } function RA(e, n) { const t = B.lFrame; t.bindingIndex = t.bindingRootIndex = e, Yd(n) } function Yd(e) { B.lFrame.currentDirectiveIndex = e } function Xd() { return B.lFrame.currentQueryIndex } function mc(e) { B.lFrame.currentQueryIndex = e } function FA(e) { const n = e[S]; return 2 === n.type ? n.declTNode : 1 === n.type ? e[et] : null } function kv(e, n, t) { if (t & J.SkipSelf) { let o = n, i = e; for (; !(o = o.parent, null !== o || t & J.Host || (o = FA(i), null === o || (i = i[Ao], 10 & o.type)));); if (null === o) return !1; n = o, e = i } const r = B.lFrame = Lv(); return r.currentTNode = n, r.lView = e, !0 } function Kd(e) { const n = Lv(), t = e[S]; B.lFrame = n, n.currentTNode = t.firstChild, n.lView = e, n.tView = t, n.contextLView = e, n.bindingIndex = t.bindingStartIndex, n.inI18n = !1 } function Lv() { const e = B.lFrame, n = null === e ? null : e.child; return null === n ? Vv(e) : n } function Vv(e) { const n = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return null !== e && (e.child = n), n } function jv() { const e = B.lFrame; return B.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } const Bv = jv; function ef() { const e = jv(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function tt() { return B.lFrame.selectedIndex } function kr(e) { B.lFrame.selectedIndex = e } function me() { const e = B.lFrame; return Xi(e.tView, e.selectedIndex) } let $v = !0; function es() { return $v } function Cn(e) { $v = e } function vc(e, n) { for (let t = n.directiveStart, r = n.directiveEnd; t < r; t++) { const i = e.data[t].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: c, ngAfterViewChecked: l, ngOnDestroy: u } = i; s && (e.contentHooks ??= []).push(-t, s), a && ((e.contentHooks ??= []).push(t, a), (e.contentCheckHooks ??= []).push(t, a)), c && (e.viewHooks ??= []).push(-t, c), l && ((e.viewHooks ??= []).push(t, l), (e.viewCheckHooks ??= []).push(t, l)), null != u && (e.destroyHooks ??= []).push(t, u) } } function yc(e, n, t) { Hv(e, n, 3, t) } function _c(e, n, t, r) { (3 & e[R]) === t && Hv(e, n, t, r) } function tf(e, n) { let t = e[R]; (3 & t) === n && (t &= 16383, t += 1, e[R] = t) } function Hv(e, n, t, r) { const i = r ?? -1, s = n.length - 1; let a = 0; for (let c = void 0 !== r ? 65535 & e[No] : 0; c < s; c++)if ("number" == typeof n[c + 1]) { if (a = n[c], null != r && a >= r) break } else n[c] < 0 && (e[No] += 65536), (a < i || -1 == i) && ($A(e, t, n, c), e[No] = (4294901760 & e[No]) + c + 2), c++ } function Gv(e, n) { _n(4, e, n); const t = W(null); try { n.call(e) } finally { W(t), _n(5, e, n) } } function $A(e, n, t, r) { const o = t[r] < 0, i = t[r + 1], a = e[o ? -t[r] : t[r]]; o ? e[R] >> 14 < e[No] >> 16 && (3 & e[R]) === n && (e[R] += 16384, Gv(a, i)) : Gv(a, i) } const Ro = -1; class ts { constructor(n, t, r) { this.factory = n, this.resolving = !1, this.canSeeViewProviders = t, this.injectImpl = r } } const rf = {}; class Lr { constructor(n, t) { this.injector = n, this.parentInjector = t } get(n, t, r) { r = Ya(r); const o = this.injector.get(n, rf, r); return o !== rf || t === rf ? o : this.parentInjector.get(n, t, r) } } function sf(e) { return e !== Ro } function ns(e) { return 32767 & e } function rs(e, n) { let t = function WA(e) { return e >> 16 }(e), r = n; for (; t > 0;)r = r[Ao], t--; return r } let af = !0; function Cc(e) { const n = af; return af = e, n } const qv = 255, Wv = 5; let QA = 0; const Dn = {}; function Dc(e, n) { const t = Zv(e, n); if (-1 !== t) return t; const r = n[S]; r.firstCreatePass && (e.injectorIndex = n.length, cf(r.data, e), cf(n, null), cf(r.blueprint, null)); const o = wc(e, n), i = e.injectorIndex; if (sf(o)) { const s = ns(o), a = rs(o, n), c = a[S].data; for (let l = 0; l < 8; l++)n[i + l] = a[s + l] | c[s + l] } return n[i + 8] = o, i } function cf(e, n) { e.push(0, 0, 0, 0, 0, 0, 0, 0, n) } function Zv(e, n) { return -1 === e.injectorIndex || e.parent && e.parent.injectorIndex === e.injectorIndex || null === n[e.injectorIndex + 8] ? -1 : e.injectorIndex } function wc(e, n) { if (e.parent && -1 !== e.parent.injectorIndex) return e.parent.injectorIndex; let t = 0, r = null, o = n; for (; null !== o;) { if (r = ty(o), null === r) return Ro; if (t++, o = o[Ao], -1 !== r.injectorIndex) return r.injectorIndex | t << 16 } return Ro } function lf(e, n, t) { !function YA(e, n, t) { let r; "string" == typeof t ? r = t.charCodeAt(0) || 0 : t.hasOwnProperty(Hi) && (r = t[Hi]), null == r && (r = t[Hi] = QA++); const o = r & qv; n.data[e + (o >> Wv)] |= 1 << o }(e, n, t) } function Qv(e, n, t) { if (t & J.Optional || void 0 !== e) return e; Cd() } function Yv(e, n, t, r) { if (t & J.Optional && void 0 === r && (r = null), !(t & (J.Self | J.Host))) { const o = e[Ve], i = _t(void 0); try { return o ? o.get(n, r, t & J.Optional) : Gm(n, r, t & J.Optional) } finally { _t(i) } } return Qv(r, 0, t) } function Jv(e, n, t, r = J.Default, o) { if (null !== e) { if (2048 & n[R] && !(r & J.Self)) { const s = function tN(e, n, t, r, o) { let i = e, s = n; for (; null !== i && null !== s && 2048 & s[R] && !(512 & s[R]);) { const a = Xv(i, s, t, r | J.Self, Dn); if (a !== Dn) return a; let c = i.parent; if (!c) { const l = s[hv]; if (l) { const u = l.get(t, Dn, r); if (u !== Dn) return u } c = ty(s), s = s[Ao] } i = c } return o }(e, n, t, r, Dn); if (s !== Dn) return s } const i = Xv(e, n, t, r, Dn); if (i !== Dn) return i } return Yv(n, t, r, o) } function Xv(e, n, t, r, o) { const i = function KA(e) { if ("string" == typeof e) return e.charCodeAt(0) || 0; const n = e.hasOwnProperty(Hi) ? e[Hi] : void 0; return "number" == typeof n ? n >= 0 ? n & qv : eN : n }(t); if ("function" == typeof i) { if (!kv(n, e, r)) return r & J.Host ? Qv(o, 0, r) : Yv(n, t, r, o); try { let s; if (s = i(r), null != s || r & J.Optional) return s; Cd() } finally { Bv() } } else if ("number" == typeof i) { let s = null, a = Zv(e, n), c = Ro, l = r & J.Host ? n[be][et] : null; for ((-1 === a || r & J.SkipSelf) && (c = -1 === a ? wc(e, n) : n[a + 8], c !== Ro && ey(r, !1) ? (s = n[S], a = ns(c), n = rs(c, n)) : a = -1); -1 !== a;) { const u = n[S]; if (Kv(i, a, u.data)) { const d = XA(a, n, t, s, r, l); if (d !== Dn) return d } c = n[a + 8], c !== Ro && ey(r, n[S].data[a + 8] === l) && Kv(i, a, n) ? (s = u, a = ns(c), n = rs(c, n)) : a = -1 } } return o } function XA(e, n, t, r, o, i) { const s = n[S], a = s.data[e + 8], u = bc(a, s, t, null == r ? Rr(a) && af : r != s && !!(3 & a.type), o & J.Host && i === a); return null !== u ? Vr(n, s, u, a) : Dn } function bc(e, n, t, r, o) { const i = e.providerIndexes, s = n.data, a = 1048575 & i, c = e.directiveStart, u = i >> 20, f = o ? a + u : e.directiveEnd; for (let h = r ? a : a + u; h < f; h++) { const p = s[h]; if (h < c && t === p || h >= c && p.type === t) return h } if (o) { const h = s[c]; if (h && Jt(h) && h.type === t) return c } return null } function Vr(e, n, t, r) { let o = e[t]; const i = n.data; if (function HA(e) { return e instanceof ts }(o)) { const s = o; s.resolving && function CT(e, n) { throw n && n.join(" > "), new w(-200, e) }(function oe(e) { return "function" == typeof e ? e.name || e.toString() : "object" == typeof e && null != e && "function" == typeof e.type ? e.type.name || e.type.toString() : H(e) }(i[t])); const a = Cc(s.canSeeViewProviders); s.resolving = !0; const l = s.injectImpl ? _t(s.injectImpl) : null; kv(e, r, J.Default); try { o = e[t] = s.factory(void 0, i, e, r), n.firstCreatePass && t >= r.directiveStart && function UA(e, n, t) { const { ngOnChanges: r, ngOnInit: o, ngDoCheck: i } = n.type.prototype; if (r) { const s = _v(n); (t.preOrderHooks ??= []).push(e, s), (t.preOrderCheckHooks ??= []).push(e, s) } o && (t.preOrderHooks ??= []).push(0 - e, o), i && ((t.preOrderHooks ??= []).push(e, i), (t.preOrderCheckHooks ??= []).push(e, i)) }(t, i[t], n) } finally { null !== l && _t(l), Cc(a), s.resolving = !1, Bv() } } return o } function Kv(e, n, t) { return !!(t[n + (e >> Wv)] & 1 << e) } function ey(e, n) { return !(e & J.Self || e & J.Host && n) } class qe { constructor(n, t) { this._tNode = n, this._lView = t } get(n, t, r) { return Jv(this._tNode, this._lView, n, Ya(r), t) } } function eN() { return new qe(le(), C()) } function Ye(e) { return jn(() => { const n = e.prototype.constructor, t = n[Bn] || uf(n), r = Object.prototype; let o = Object.getPrototypeOf(e.prototype).constructor; for (; o && o !== r;) { const i = o[Bn] || uf(o); if (i && i !== t) return i; o = Object.getPrototypeOf(o) } return i => new i }) } function uf(e) { return za(e) ? () => { const n = uf(V(e)); return n && n() } : Nr(e) } function ty(e) { const n = e[S], t = n.type; return 2 === t ? n.declTNode : 1 === t ? e[et] : null } function sy(e, n = null, t = null, r) { const o = ay(e, n, t, r); return o.resolveInjectorInitializers(), o } function ay(e, n = null, t = null, r, o = new Set) { const i = [t || ee, YT(e)]; return r = r || ("object" == typeof e ? void 0 : $e(e)), new Mo(i, n || sc(), r || null, o) } class Je { static { this.THROW_IF_NOT_FOUND = Gi } static { this.NULL = new tc } static create(n, t) { if (Array.isArray(n)) return sy({ name: "" }, t, n, ""); { const r = n.name ?? ""; return sy({ name: r }, n.parent, n.providers, r) } } static { this.\u0275prov = N({ token: Je, providedIn: "any", factory: () => x(Ym) }) } static { this.__NG_ELEMENT_ID__ = -1 } } new T("").__NG_ELEMENT_ID__ = e => { const n = le(); if (null === n) throw new w(204, !1); if (2 & n.type) return n.value; if (e & J.Optional) return null; throw new w(204, !1) }; function ff(e) { return e.ngOriginalError } const ly = !0; let is = (() => { class e { static { this.__NG_ELEMENT_ID__ = dN } static { this.__NG_ENV_ID__ = t => t } } return e })(); class uN extends is { constructor(n) { super(), this._lView = n } onDestroy(n) { return pc(this._lView, n), () => function qd(e, n) { if (null === e[ar]) return; const t = e[ar].indexOf(n); -1 !== t && e[ar].splice(t, 1) }(this._lView, n) } } function dN() { return new uN(C()) } let cr = (() => { class e { constructor() { this.taskId = 0, this.pendingTasks = new Set, this.hasPendingTasks = new Vt(!1) } get _hasPendingTasks() { return this.hasPendingTasks.value } add() { this._hasPendingTasks || this.hasPendingTasks.next(!0); const t = this.taskId++; return this.pendingTasks.add(t), t } remove(t) { this.pendingTasks.delete(t), 0 === this.pendingTasks.size && this._hasPendingTasks && this.hasPendingTasks.next(!1) } ngOnDestroy() { this.pendingTasks.clear(), this._hasPendingTasks && this.hasPendingTasks.next(!1) } static { this.\u0275prov = N({ token: e, providedIn: "root", factory: () => new e }) } } return e })(); const Te = class fN extends It { constructor(n = !1) { super(), this.destroyRef = void 0, this.pendingTasks = void 0, this.__isAsync = n, uv() && (this.destroyRef = b(is, { optional: !0 }) ?? void 0, this.pendingTasks = b(cr, { optional: !0 }) ?? void 0) } emit(n) { const t = W(null); try { super.next(n) } finally { W(t) } } subscribe(n, t, r) { let o = n, i = t || (() => null), s = r; if (n && "object" == typeof n) { const c = n; o = c.next?.bind(c), i = c.error?.bind(c), s = c.complete?.bind(c) } this.__isAsync && (i = this.wrapInTimeout(i), o && (o = this.wrapInTimeout(o)), s && (s = this.wrapInTimeout(s))); const a = super.subscribe({ next: o, error: i, complete: s }); return n instanceof at && n.add(a), a } wrapInTimeout(n) { return t => { const r = this.pendingTasks?.add(); setTimeout(() => { n(t), void 0 !== r && this.pendingTasks?.remove(r) }) } } }; function Mc(...e) { } function uy(e) { let n, t; function r() { e = Mc; try { void 0 !== t && "function" == typeof cancelAnimationFrame && cancelAnimationFrame(t), void 0 !== n && clearTimeout(n) } catch { } } return n = setTimeout(() => { e(), r() }), "function" == typeof requestAnimationFrame && (t = requestAnimationFrame(() => { e(), r() })), () => r() } function dy(e) { return queueMicrotask(() => e()), () => { e = Mc } } const hf = "isAngularZone", Ic = hf + "_ID"; let hN = 0; class ie { constructor(n) { this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Te(!1), this.onMicrotaskEmpty = new Te(!1), this.onStable = new Te(!1), this.onError = new Te(!1); const { enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: r = !1, shouldCoalesceRunChangeDetection: o = !1, scheduleInRootZone: i = ly } = n; if (typeof Zone > "u") throw new w(908, !1); Zone.assertZonePatched(); const s = this; s._nesting = 0, s._outer = s._inner = Zone.current, Zone.TaskTrackingZoneSpec && (s._inner = s._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (s._inner = s._inner.fork(Zone.longStackTraceZoneSpec)), s.shouldCoalesceEventChangeDetection = !o && r, s.shouldCoalesceRunChangeDetection = o, s.callbackScheduled = !1, s.scheduleInRootZone = i, function mN(e) { const n = () => { !function gN(e) { function n() { uy(() => { e.callbackScheduled = !1, gf(e), e.isCheckStableRunning = !0, pf(e), e.isCheckStableRunning = !1 }) } e.isCheckStableRunning || e.callbackScheduled || (e.callbackScheduled = !0, e.scheduleInRootZone ? Zone.root.run(() => { n() }) : e._outer.run(() => { n() }), gf(e)) }(e) }, t = hN++; e._inner = e._inner.fork({ name: "angular", properties: { [hf]: !0, [Ic]: t, [Ic + t]: !0 }, onInvokeTask: (r, o, i, s, a, c) => { if (function vN(e) { return py(e, "__ignore_ng_zone__") }(c)) return r.invokeTask(i, s, a, c); try { return fy(e), r.invokeTask(i, s, a, c) } finally { (e.shouldCoalesceEventChangeDetection && "eventTask" === s.type || e.shouldCoalesceRunChangeDetection) && n(), hy(e) } }, onInvoke: (r, o, i, s, a, c, l) => { try { return fy(e), r.invoke(i, s, a, c, l) } finally { e.shouldCoalesceRunChangeDetection && !e.callbackScheduled && !function yN(e) { return py(e, "__scheduler_tick__") }(c) && n(), hy(e) } }, onHasTask: (r, o, i, s) => { r.hasTask(i, s), o === i && ("microTask" == s.change ? (e._hasPendingMicrotasks = s.microTask, gf(e), pf(e)) : "macroTask" == s.change && (e.hasPendingMacrotasks = s.macroTask)) }, onHandleError: (r, o, i, s) => (r.handleError(i, s), e.runOutsideAngular(() => e.onError.emit(s)), !1) }) }(s) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get(hf) } static assertInAngularZone() { if (!ie.isInAngularZone()) throw new w(909, !1) } static assertNotInAngularZone() { if (ie.isInAngularZone()) throw new w(909, !1) } run(n, t, r) { return this._inner.run(n, t, r) } runTask(n, t, r, o) { const i = this._inner, s = i.scheduleEventTask("NgZoneEvent: " + o, n, pN, Mc, Mc); try { return i.runTask(s, t, r) } finally { i.cancelTask(s) } } runGuarded(n, t, r) { return this._inner.runGuarded(n, t, r) } runOutsideAngular(n) { return this._outer.run(n) } } const pN = {}; function pf(e) { if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function gf(e) { e.hasPendingMicrotasks = !!(e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && !0 === e.callbackScheduled) } function fy(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function hy(e) { e._nesting--, pf(e) } class mf { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new Te, this.onMicrotaskEmpty = new Te, this.onStable = new Te, this.onError = new Te } run(n, t, r) { return n.apply(t, r) } runGuarded(n, t, r) { return n.apply(t, r) } runOutsideAngular(n) { return n() } runTask(n, t, r, o) { return n.apply(t, r) } } function py(e, n) { return !(!Array.isArray(e) || 1 !== e.length) && !0 === e[0]?.data?.[n] } class wn { constructor() { this._console = console } handleError(n) { const t = this._findOriginalError(n); this._console.error("ERROR", n), t && this._console.error("ORIGINAL ERROR", t) } _findOriginalError(n) { let t = n && ff(n); for (; t && ff(t);)t = ff(t); return t || null } } const CN = new T("", { providedIn: "root", factory: () => { const e = b(ie), n = b(wn); return t => e.runOutsideAngular(() => n.handleError(t)) } }); function DN() { return ko(le(), C()) } function ko(e, n) { return new Ot(dt(e, n)) } let Ot = (() => { class e { constructor(t) { this.nativeElement = t } static { this.__NG_ELEMENT_ID__ = DN } } return e })(); function my(e) { return e instanceof Ot ? e.nativeElement : e } function wN() { return this._results[Symbol.iterator]() } class vf { get changes() { return this._changes ??= new Te } constructor(n = !1) { this._emitDistinctChangesOnly = n, this.dirty = !0, this._onDirty = void 0, this._results = [], this._changesDetected = !1, this._changes = void 0, this.length = 0, this.first = void 0, this.last = void 0; const t = vf.prototype; t[Symbol.iterator] || (t[Symbol.iterator] = wN) } get(n) { return this._results[n] } map(n) { return this._results.map(n) } filter(n) { return this._results.filter(n) } find(n) { return this._results.find(n) } reduce(n, t) { return this._results.reduce(n, t) } forEach(n) { this._results.forEach(n) } some(n) { return this._results.some(n) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(n, t) { this.dirty = !1; const r = function Ct(e) { return e.flat(Number.POSITIVE_INFINITY) }(n); (this._changesDetected = !function RT(e, n, t) { if (e.length !== n.length) return !1; for (let r = 0; r < e.length; r++) { let o = e[r], i = n[r]; if (t && (o = t(o), i = t(i)), i !== o) return !1 } return !0 }(this._results, r, t)) && (this._results = r, this.length = r.length, this.last = r[this.length - 1], this.first = r[0]) } notifyOnChanges() { void 0 !== this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this) } onDirty(n) { this._onDirty = n } setDirty() { this.dirty = !0, this._onDirty?.() } destroy() { void 0 !== this._changes && (this._changes.complete(), this._changes.unsubscribe()) } } function as(e) { return !(128 & ~e.flags) } const _f = new Map; let EN = 0; function Cf(e) { _f.delete(e[Oo]) } const Sc = "__ngContext__"; function ot(e, n) { ze(n) ? (e[Sc] = n[Oo], function IN(e) { _f.set(e[Oo], e) }(n)) : e[Sc] = n } function Iy(e) { return Ty(e[Zi]) } function Sy(e) { return Ty(e[Yt]) } function Ty(e) { for (; null !== e && !rt(e);)e = e[Yt]; return e } let wf; function lr() { if (void 0 !== wf) return wf; if (typeof document < "u") return document; throw new w(210, !1) } const ls = new T("", { providedIn: "root", factory: () => HN }), HN = "ng", ky = new T(""), zn = new T("", { providedIn: "platform", factory: () => "unknown" }), Ly = new T("", { providedIn: "root", factory: () => lr().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null }); let Vy = () => null; function Af(e, n, t = !1) { return Vy(e, n, t) } const qy = new T("", { providedIn: "root", factory: () => !1 }); let Fc, kc; function Bo(e) { return function Pf() { if (void 0 === Fc && (Fc = null, Ce.trustedTypes)) try { Fc = Ce.trustedTypes.createPolicy("angular", { createHTML: e => e, createScript: e => e, createScriptURL: e => e }) } catch { } return Fc }()?.createHTML(e) || e } function Ff() { if (void 0 === kc && (kc = null, Ce.trustedTypes)) try { kc = Ce.trustedTypes.createPolicy("angular#unsafe-bypass", { createHTML: e => e, createScript: e => e, createScriptURL: e => e }) } catch { } return kc } function Qy(e) { return Ff()?.createHTML(e) || e } function Jy(e) { return Ff()?.createScriptURL(e) || e } class Br { constructor(n) { this.changingThisBreaksApplicationSecurity = n } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${Pm})` } } class r1 extends Br { getTypeName() { return "HTML" } } class o1 extends Br { getTypeName() { return "Style" } } class i1 extends Br { getTypeName() { return "Script" } } class s1 extends Br { getTypeName() { return "URL" } } class a1 extends Br { getTypeName() { return "ResourceURL" } } function xt(e) { return e instanceof Br ? e.changingThisBreaksApplicationSecurity : e } function bn(e, n) { const t = function c1(e) { return e instanceof Br && e.getTypeName() || null }(e); if (null != t && t !== n) { if ("ResourceURL" === t && "URL" === n) return !0; throw new Error(`Required a safe ${n}, got a ${t} (see ${Pm})`) } return t === n } class p1 { constructor(n) { this.inertDocumentHelper = n } getInertBodyElement(n) { n = "<body><remove></remove>" + n; try { const t = (new window.DOMParser).parseFromString(Bo(n), "text/html").body; return null === t ? this.inertDocumentHelper.getInertBodyElement(n) : (t.firstChild?.remove(), t) } catch { return null } } } class g1 { constructor(n) { this.defaultDoc = n, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert") } getInertBodyElement(n) { const t = this.inertDocument.createElement("template"); return t.innerHTML = Bo(n), t } } const v1 = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i; function Lc(e) { return (e = String(e)).match(v1) ? e : "unsafe:" + e } function qn(e) { const n = {}; for (const t of e.split(",")) n[t] = !0; return n } function gs(...e) { const n = {}; for (const t of e) for (const r in t) t.hasOwnProperty(r) && (n[r] = !0); return n } const Ky = qn("area,br,col,hr,img,wbr"), e_ = qn("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), t_ = qn("rp,rt"), kf = gs(Ky, gs(e_, qn("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), gs(t_, qn("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), gs(t_, e_)), Lf = qn("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), n_ = gs(Lf, qn("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), qn("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), y1 = qn("script,style,template"); class _1 { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(n) { let t = n.firstChild, r = !0, o = []; for (; t;)if (t.nodeType === Node.ELEMENT_NODE ? r = this.startElement(t) : t.nodeType === Node.TEXT_NODE ? this.chars(t.nodeValue) : this.sanitizedSomething = !0, r && t.firstChild) o.push(t), t = w1(t); else for (; t;) { t.nodeType === Node.ELEMENT_NODE && this.endElement(t); let i = D1(t); if (i) { t = i; break } t = o.pop() } return this.buf.join("") } startElement(n) { const t = r_(n).toLowerCase(); if (!kf.hasOwnProperty(t)) return this.sanitizedSomething = !0, !y1.hasOwnProperty(t); this.buf.push("<"), this.buf.push(t); const r = n.attributes; for (let o = 0; o < r.length; o++) { const i = r.item(o), s = i.name, a = s.toLowerCase(); if (!n_.hasOwnProperty(a)) { this.sanitizedSomething = !0; continue } let c = i.value; Lf[a] && (c = Lc(c)), this.buf.push(" ", s, '="', i_(c), '"') } return this.buf.push(">"), !0 } endElement(n) { const t = r_(n).toLowerCase(); kf.hasOwnProperty(t) && !Ky.hasOwnProperty(t) && (this.buf.push("</"), this.buf.push(t), this.buf.push(">")) } chars(n) { this.buf.push(i_(n)) } } function D1(e) { const n = e.nextSibling; if (n && e !== n.previousSibling) throw o_(n); return n } function w1(e) { const n = e.firstChild; if (n && function C1(e, n) { return (e.compareDocumentPosition(n) & Node.DOCUMENT_POSITION_CONTAINED_BY) !== Node.DOCUMENT_POSITION_CONTAINED_BY }(e, n)) throw o_(n); return n } function r_(e) { const n = e.nodeName; return "string" == typeof n ? n : "FORM" } function o_(e) { return new Error(`Failed to sanitize html because the element is clobbered: ${e.outerHTML}`) } const b1 = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, E1 = /([^\#-~ |!])/g; function i_(e) { return e.replace(/&/g, "&amp;").replace(b1, function (n) { return "&#" + (1024 * (n.charCodeAt(0) - 55296) + (n.charCodeAt(1) - 56320) + 65536) + ";" }).replace(E1, function (n) { return "&#" + n.charCodeAt(0) + ";" }).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let Vc; function s_(e, n) { let t = null; try { Vc = Vc || function Xy(e) { const n = new g1(e); return function m1() { try { return !!(new window.DOMParser).parseFromString(Bo(""), "text/html") } catch { return !1 } }() ? new p1(n) : n }(e); let r = n ? String(n) : ""; t = Vc.getInertBodyElement(r); let o = 5, i = r; do { if (0 === o) throw new Error("Failed to sanitize html because the input is unstable"); o--, r = i, i = t.innerHTML, t = Vc.getInertBodyElement(r) } while (r !== i); return Bo((new _1).sanitizeChildren(Vf(t) || t)) } finally { if (t) { const r = Vf(t) || t; for (; r.firstChild;)r.firstChild.remove() } } } function Vf(e) { return "content" in e && function M1(e) { return e.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === e.nodeName }(e) ? e.content : null } var $t = function (e) { return e[e.NONE = 0] = "NONE", e[e.HTML = 1] = "HTML", e[e.STYLE = 2] = "STYLE", e[e.SCRIPT = 3] = "SCRIPT", e[e.URL = 4] = "URL", e[e.RESOURCE_URL = 5] = "RESOURCE_URL", e }($t || {}); function a_(e) { const n = ms(); return n ? Qy(n.sanitize($t.HTML, e) || "") : bn(e, "HTML") ? Qy(xt(e)) : s_(lr(), H(e)) } function en(e) { const n = ms(); return n ? n.sanitize($t.URL, e) || "" : bn(e, "URL") ? xt(e) : Lc(H(e)) } function c_(e) { const n = ms(); if (n) return Jy(n.sanitize($t.RESOURCE_URL, e) || ""); if (bn(e, "ResourceURL")) return Jy(xt(e)); throw new w(904, !1) } function ms() { const e = C(); return e && e[vn].sanitizer } function Rt(e) { return e instanceof Function ? e() : e } var ur = function (e) { return e[e.Important = 1] = "Important", e[e.DashCase = 2] = "DashCase", e }(ur || {}); let Uf; function $f(e, n) { return Uf(e, n) } function $o(e, n, t, r, o) { if (null != r) { let i, s = !1; rt(r) ? i = r : ze(r) && (s = !0, r = r[we]); const a = te(r); 0 === e && null !== t ? null == o ? w_(n, t, a) : Ur(n, t, a, o || null, !0) : 1 === e && null !== t ? Ur(n, t, a, o || null, !0) : 2 === e ? function ys(e, n, t) { e.removeChild(null, n, t) }(n, a, s) : 3 === e && n.destroyNode(a), null != i && function K1(e, n, t, r, o) { const i = t[yn]; i !== te(t) && $o(n, e, r, i, o); for (let a = xe; a < t.length; a++) { const c = t[a]; Gc(c[S], c, e, n, r, i) } }(n, e, i, t, o) } } function Uc(e, n, t) { return e.createElement(n, t) } function __(e, n) { n[vn].changeDetectionScheduler?.notify(9), Gc(e, n, n[j], 2, null, null) } function C_(e, n) { const t = e[xo], r = n[Le]; (ze(r) || n[be] !== r[Le][be]) && (e[R] |= uc.HasTransplantedViews), null === t ? e[xo] = [n] : t.push(n) } function zf(e, n) { const t = e[xo], r = t.indexOf(n); t.splice(r, 1) } function vs(e, n) { if (e.length <= xe) return; const t = xe + n, r = e[t]; if (r) { const o = r[xr]; null !== o && o !== e && zf(o, r), n > 0 && (e[t - 1][Yt] = r[Yt]); const i = Ka(e, xe + n); !function z1(e, n) { __(e, n), n[we] = null, n[et] = null }(r[S], r); const s = i[Un]; null !== s && s.detachView(i[S]), r[Le] = null, r[Yt] = null, r[R] &= -129 } return r } function $c(e, n) { if (!(256 & n[R])) { const t = n[j]; t.destroyNode && Gc(e, n, t, 3, null, null), function W1(e) { let n = e[Zi]; if (!n) return qf(e[S], e); for (; n;) { let t = null; if (ze(n)) t = n[Zi]; else { const r = n[xe]; r && (t = r) } if (!t) { for (; n && !n[Yt] && n !== e;)ze(n) && qf(n[S], n), n = n[Le]; null === n && (n = e), ze(n) && qf(n[S], n), t = n && n[Yt] } n = t } }(n) } } function qf(e, n) { if (256 & n[R]) return; const t = W(null); try { n[R] &= -129, n[R] |= 256, n[jt] && Ju(n[jt]), function Y1(e, n) { let t; if (null != e && null != (t = e.destroyHooks)) for (let r = 0; r < t.length; r += 2) { const o = n[t[r]]; if (!(o instanceof ts)) { const i = t[r + 1]; if (Array.isArray(i)) for (let s = 0; s < i.length; s += 2) { const a = o[i[s]], c = i[s + 1]; _n(4, a, c); try { c.call(a) } finally { _n(5, a, c) } } else { _n(4, o, i); try { i.call(o) } finally { _n(5, o, i) } } } } }(e, n), function Q1(e, n) { const t = e.cleanup, r = n[To]; if (null !== t) for (let i = 0; i < t.length - 1; i += 2)if ("string" == typeof t[i]) { const s = t[i + 3]; s >= 0 ? r[s]() : r[-s].unsubscribe(), i += 2 } else t[i].call(r[t[i + 1]]); null !== r && (n[To] = null); const o = n[ar]; if (null !== o) { n[ar] = null; for (let i = 0; i < o.length; i++)(0, o[i])() } }(e, n), 1 === n[S].type && n[j].destroy(); const r = n[xr]; if (null !== r && rt(n[Le])) { r !== n[Le] && zf(r, n); const o = n[Un]; null !== o && o.detachView(e) } Cf(n) } finally { W(t) } } function Wf(e, n, t) { return function D_(e, n, t) { let r = n; for (; null !== r && 168 & r.type;)r = (n = r).parent; if (null === r) return t[we]; { const { componentOffset: o } = r; if (o > -1) { const { encapsulation: i } = e.data[r.directiveStart + o]; if (i === Zt.None || i === Zt.Emulated) return null } return dt(r, t) } }(e, n.parent, t) } function Ur(e, n, t, r, o) { e.insertBefore(n, t, r, o) } function w_(e, n, t) { e.appendChild(n, t) } function b_(e, n, t, r, o) { null !== r ? Ur(e, n, t, r, o) : w_(e, n, t) } function Zf(e, n) { return e.parentNode(n) } let Qf, I_ = function M_(e, n, t) { return 40 & e.type ? dt(e, t) : null }; function Hc(e, n, t, r) { const o = Wf(e, r, n), i = n[j], a = function E_(e, n, t) { return I_(e, n, t) }(r.parent || n[et], r, n); if (null != o) if (Array.isArray(t)) for (let c = 0; c < t.length; c++)b_(i, o, t[c], a, !1); else b_(i, o, t, a, !1); void 0 !== Qf && Qf(i, r, n, t, o) } function $r(e, n) { if (null !== n) { const t = n.type; if (3 & t) return dt(n, e); if (4 & t) return Yf(-1, e[n.index]); if (8 & t) { const r = n.child; if (null !== r) return $r(e, r); { const o = e[n.index]; return rt(o) ? Yf(-1, o) : te(o) } } if (128 & t) return $r(e, n.next); if (32 & t) return $f(n, e)() || te(e[n.index]); { const r = T_(e, n); return null !== r ? Array.isArray(r) ? r[0] : $r($n(e[be]), r) : $r(e, n.next) } } return null } function T_(e, n) { return null !== n ? e[be][et].projection[n.projection] : null } function Yf(e, n) { const t = xe + e + 1; if (t < n.length) { const r = n[t], o = r[S].firstChild; if (null !== o) return $r(r, o) } return n[yn] } function Jf(e, n, t, r, o, i, s) { for (; null != t;) { if (128 === t.type) { t = t.next; continue } const a = r[t.index], c = t.type; if (s && 0 === n && (a && ot(te(a), r), t.flags |= 2), 32 & ~t.flags) if (8 & c) Jf(e, n, t.child, r, o, i, !1), $o(n, e, o, a, i); else if (32 & c) { const l = $f(t, r); let u; for (; u = l();)$o(n, e, o, u, i); $o(n, e, o, a, i) } else 16 & c ? N_(e, n, r, t, o, i) : $o(n, e, o, a, i); t = s ? t.projectionNext : t.next } } function Gc(e, n, t, r, o, i) { Jf(t, r, e.firstChild, n, o, i, !1) } function N_(e, n, t, r, o, i) { const s = t[be], c = s[et].projection[r.projection]; if (Array.isArray(c)) for (let l = 0; l < c.length; l++)$o(n, e, o, c[l], i); else { let l = c; const u = s[Le]; as(r) && (l.flags |= 128), Jf(e, n, l, u, o, i, !0) } } function O_(e, n, t) { "" === t ? e.removeAttribute(n, "class") : e.setAttribute(n, "class", t) } function x_(e, n, t) { const { mergedAttrs: r, classes: o, styles: i } = t; null !== r && Sd(e, n, r), null !== o && O_(e, n, o), null !== i && function tO(e, n, t) { e.setAttribute(n, "style", t) }(e, n, i) } const G = {}; function I(e = 1) { R_(Z(), C(), tt() + e, !1) } function R_(e, n, t, r) { if (!r) if (3 & ~n[R]) { const i = e.preOrderHooks; null !== i && _c(n, i, 0, t) } else { const i = e.preOrderCheckHooks; null !== i && yc(n, i, t) } kr(t) } function M(e, n = J.Default) { const t = C(); return null === t ? x(e, n) : Jv(le(), t, V(e), n) } function F_(e, n, t, r, o, i) { const s = W(null); try { let a = null; o & ir.SignalBased && (a = n[r][Wt]), null !== a && void 0 !== a.transformFn && (i = a.transformFn(i)), o & ir.HasDecoratorInputTransform && (i = e.inputTransforms[r].call(n, i)), null !== e.setInput ? e.setInput(n, a, i, t, r) : yv(n, a, r, i) } finally { W(s) } } function zc(e, n, t, r, o, i, s, a, c, l, u) { const d = n.blueprint.slice(); return d[we] = o, d[R] = 204 | r, (null !== l || e && 2048 & e[R]) && (d[R] |= 2048), Ev(d), d[Le] = d[Ao] = e, d[ge] = t, d[vn] = s || e && e[vn], d[j] = a || e && e[j], d[Ve] = c || e && e[Ve] || null, d[et] = i, d[Oo] = function MN() { return EN++ }(), d[ut] = u, d[hv] = l, d[be] = 2 == n.type ? e[be] : d, d } function Hr(e, n, t, r, o) { let i = e.data[n]; if (null === i) i = function Xf(e, n, t, r, o) { const i = Av(), s = Zd(), c = e.data[n] = function lO(e, n, t, r, o, i) { let s = n ? n.injectorIndex : -1, a = 0; return function Fr() { return null !== B.skipHydrationRootTNode }() && (a |= 128), { type: t, index: r, insertBeforeIndex: null, injectorIndex: s, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, componentOffset: -1, propertyBindings: null, flags: a, providerIndexes: 0, value: o, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tView: null, next: null, prev: null, projectionNext: null, child: null, parent: n, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? i : i && i.parent, t, n, r, o); return null === e.firstChild && (e.firstChild = c), null !== i && (s ? null == i.child && null !== c.parent && (i.child = c) : null === i.next && (i.next = c, c.prev = i)), c }(e, n, t, r, o), function xA() { return B.lFrame.inI18n }() && (i.flags |= 32); else if (64 & i.type) { i.type = t, i.value = r, i.attrs = o; const s = function Ki() { const e = B.lFrame, n = e.currentTNode; return e.isParent ? n : n.parent }(); i.injectorIndex = null === s ? -1 : s.injectorIndex } return Xt(i, !0), i } function _s(e, n, t, r) { if (0 === t) return -1; const o = n.length; for (let i = 0; i < t; i++)n.push(r), e.blueprint.push(r), e.data.push(null); return o } function k_(e, n, t, r, o) { const i = tt(), s = 2 & r; try { kr(-1), s && n.length > O && R_(e, n, O, !1), _n(s ? 2 : 0, o), t(r, o) } finally { kr(i), _n(s ? 3 : 1, o) } } function Kf(e, n, t) { if (jd(n)) { const r = W(null); try { const i = n.directiveEnd; for (let s = n.directiveStart; s < i; s++) { const a = e.data[s]; a.contentQueries && a.contentQueries(1, t[s], s) } } finally { W(r) } } } function eh(e, n, t) { Tv() && (function mO(e, n, t, r) { const o = t.directiveStart, i = t.directiveEnd; Rr(t) && function bO(e, n, t) { const r = dt(n, e), o = L_(t); let s = 16; t.signals ? s = 4096 : t.onPush && (s = 64); const a = qc(e, zc(e, o, null, s, r, n, null, e[vn].rendererFactory.createRenderer(r, t), null, null, null)); e[n.index] = a }(n, t, e.data[o + t.componentOffset]), e.firstCreatePass || Dc(t, n), ot(r, n); const s = t.initialInputs; for (let a = o; a < i; a++) { const c = e.data[a], l = Vr(n, e, a, t); ot(l, n), null !== s && EO(0, a - o, l, c, 0, s), Jt(c) && (Nt(t.index, n)[ge] = Vr(n, e, a, t)) } }(e, n, t, dt(t, n)), !(64 & ~t.flags) && $_(e, n, t)) } function th(e, n, t = dt) { const r = n.localNames; if (null !== r) { let o = n.index + 1; for (let i = 0; i < r.length; i += 2) { const s = r[i + 1], a = -1 === s ? t(n, e) : e[s]; e[o++] = a } } } function L_(e) { const n = e.tView; return null === n || n.incompleteFirstPass ? e.tView = nh(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts, e.id) : n } function nh(e, n, t, r, o, i, s, a, c, l, u) { const d = O + r, f = d + o, h = function rO(e, n) { const t = []; for (let r = 0; r < n; r++)t.push(r < e ? null : G); return t }(d, f), p = "function" == typeof l ? l() : l; return h[S] = { type: e, blueprint: h, template: t, queries: null, viewQuery: a, declTNode: n, data: h.slice().fill(null, d), bindingStartIndex: d, expandoStartIndex: f, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof i ? i() : i, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: c, consts: p, incompleteFirstPass: !1, ssrId: u } } let V_ = () => null; function j_(e, n, t, r, o) { for (let i in n) { if (!n.hasOwnProperty(i)) continue; const s = n[i]; if (void 0 === s) continue; r ??= {}; let a, c = ir.None; Array.isArray(s) ? (a = s[0], c = s[1]) : a = s; let l = i; if (null !== o) { if (!o.hasOwnProperty(i)) continue; l = o[i] } 0 === e ? B_(r, t, l, a, c) : B_(r, t, l, a) } return r } function B_(e, n, t, r, o) { let i; e.hasOwnProperty(t) ? (i = e[t]).push(n, r) : i = e[t] = [n, r], void 0 !== o && i.push(o) } function wt(e, n, t, r, o, i, s, a) { const c = dt(n, t); let u, l = n.inputs; !a && null != l && (u = l[r]) ? (ah(e, t, u, r, o), Rr(n) && function fO(e, n) { const t = Nt(n, e); 16 & t[R] || (t[R] |= 64) }(t, n.index)) : 3 & n.type && (r = function dO(e) { return "class" === e ? "className" : "for" === e ? "htmlFor" : "formaction" === e ? "formAction" : "innerHtml" === e ? "innerHTML" : "readonly" === e ? "readOnly" : "tabindex" === e ? "tabIndex" : e }(r), o = null != s ? s(o, n.value || "", r) : o, i.setProperty(c, r, o)) } function rh(e, n, t, r) { if (Tv()) { const o = null === r ? null : { "": -1 }, i = function yO(e, n) { const t = e.directiveRegistry; let r = null, o = null; if (t) for (let i = 0; i < t.length; i++) { const s = t[i]; if (tv(n, s.selectors, !1)) if (r || (r = []), Jt(s)) if (null !== s.findHostDirectiveDefs) { const a = []; o = o || new Map, s.findHostDirectiveDefs(s, a, o), r.unshift(...a, s), oh(e, n, a.length) } else r.unshift(s), oh(e, n, 0); else o = o || new Map, s.findHostDirectiveDefs?.(s, r, o), r.push(s) } return null === r ? null : [r, o] }(e, t); let s, a; null === i ? s = a = null : [s, a] = i, null !== s && U_(e, n, t, s, o, a), o && function _O(e, n, t) { if (n) { const r = e.localNames = []; for (let o = 0; o < n.length; o += 2) { const i = t[n[o + 1]]; if (null == i) throw new w(-301, !1); r.push(n[o], i) } } }(t, r, o) } t.mergedAttrs = qi(t.mergedAttrs, t.attrs) } function U_(e, n, t, r, o, i) { for (let l = 0; l < r.length; l++)lf(Dc(t, n), e, r[l].type); !function DO(e, n, t) { e.flags |= 1, e.directiveStart = n, e.directiveEnd = n + t, e.providerIndexes = n }(t, e.data.length, r.length); for (let l = 0; l < r.length; l++) { const u = r[l]; u.providersResolver && u.providersResolver(u) } let s = !1, a = !1, c = _s(e, n, r.length, null); for (let l = 0; l < r.length; l++) { const u = r[l]; t.mergedAttrs = qi(t.mergedAttrs, u.hostAttrs), wO(e, t, n, c, u), CO(c, u, o), null !== u.contentQueries && (t.flags |= 4), (null !== u.hostBindings || null !== u.hostAttrs || 0 !== u.hostVars) && (t.flags |= 64); const d = u.type.prototype; !s && (d.ngOnChanges || d.ngOnInit || d.ngDoCheck) && ((e.preOrderHooks ??= []).push(t.index), s = !0), !a && (d.ngOnChanges || d.ngDoCheck) && ((e.preOrderCheckHooks ??= []).push(t.index), a = !0), c++ } !function uO(e, n, t) { const o = n.directiveEnd, i = e.data, s = n.attrs, a = []; let c = null, l = null; for (let u = n.directiveStart; u < o; u++) { const d = i[u], f = t ? t.get(d) : null, p = f ? f.outputs : null; c = j_(0, d.inputs, u, c, f ? f.inputs : null), l = j_(1, d.outputs, u, l, p); const g = null === c || null === s || Td(n) ? null : MO(c, u, s); a.push(g) } null !== c && (c.hasOwnProperty("class") && (n.flags |= 8), c.hasOwnProperty("style") && (n.flags |= 16)), n.initialInputs = a, n.inputs = c, n.outputs = l }(e, t, i) } function $_(e, n, t) { const r = t.directiveStart, o = t.directiveEnd, i = t.index, s = function PA() { return B.lFrame.currentDirectiveIndex }(); try { kr(i); for (let a = r; a < o; a++) { const c = e.data[a], l = n[a]; Yd(a), (null !== c.hostBindings || 0 !== c.hostVars || null !== c.hostAttrs) && vO(c, l) } } finally { kr(-1), Yd(s) } } function vO(e, n) { null !== e.hostBindings && e.hostBindings(1, n) } function oh(e, n, t) { n.componentOffset = t, (e.components ??= []).push(n.index) } function CO(e, n, t) { if (t) { if (n.exportAs) for (let r = 0; r < n.exportAs.length; r++)t[n.exportAs[r]] = e; Jt(n) && (t[""] = e) } } function wO(e, n, t, r, o) { e.data[r] = o; const i = o.factory || (o.factory = Nr(o.type)), s = new ts(i, Jt(o), M); e.blueprint[r] = s, t[r] = s, function pO(e, n, t, r, o) { const i = o.hostBindings; if (i) { let s = e.hostBindingOpCodes; null === s && (s = e.hostBindingOpCodes = []); const a = ~n.index; (function gO(e) { let n = e.length; for (; n > 0;) { const t = e[--n]; if ("number" == typeof t && t < 0) return t } return 0 })(s) != a && s.push(a), s.push(t, r, i) } }(e, n, r, _s(e, t, o.hostVars, G), o) } function En(e, n, t, r, o, i) { const s = dt(e, n); !function ih(e, n, t, r, o, i, s) { if (null == i) e.removeAttribute(n, o, t); else { const a = null == s ? H(i) : s(i, r || "", o); e.setAttribute(n, o, a, t) } }(n[j], s, i, e.value, t, r, o) } function EO(e, n, t, r, o, i) { const s = i[n]; if (null !== s) for (let a = 0; a < s.length;)F_(r, t, s[a++], s[a++], s[a++], s[a++]) } function MO(e, n, t) { let r = null, o = 0; for (; o < t.length;) { const i = t[o]; if (0 !== i) if (5 !== i) { if ("number" == typeof i) break; if (e.hasOwnProperty(i)) { null === r && (r = []); const s = e[i]; for (let a = 0; a < s.length; a += 3)if (s[a] === n) { r.push(i, s[a + 1], s[a + 2], t[o + 1]); break } } o += 2 } else o += 2; else o += 4 } return r } function H_(e, n, t, r) { return [e, !0, 0, n, null, r, null, t, null, null] } function G_(e, n) { const t = e.contentQueries; if (null !== t) { const r = W(null); try { for (let o = 0; o < t.length; o += 2) { const s = t[o + 1]; if (-1 !== s) { const a = e.data[s]; mc(t[o]), a.contentQueries(2, n[s], s) } } } finally { W(r) } } } function qc(e, n) { return e[Zi] ? e[fv][Yt] = n : e[Zi] = n, e[fv] = n, n } function sh(e, n, t) { mc(0); const r = W(null); try { n(e, t) } finally { W(r) } } function z_(e) { return e[To] ??= [] } function q_(e) { return e.cleanup ??= [] } function Wc(e, n) { const t = e[Ve], r = t ? t.get(wn, null) : null; r && r.handleError(n) } function ah(e, n, t, r, o) { for (let i = 0; i < t.length;) { const s = t[i++], a = t[i++], c = t[i++]; F_(e.data[s], n[s], r, a, c, o) } } function Wn(e, n, t) { const r = Ji(n, e); !function y_(e, n, t) { e.setValue(n, t) }(e[j], r, t) } function IO(e, n) { const t = Nt(n, e), r = t[S]; !function SO(e, n) { for (let t = n.length; t < e.blueprint.length; t++)n.push(e.blueprint[t]) }(r, t); const o = t[we]; null !== o && null === t[ut] && (t[ut] = Af(o, t[Ve])), ch(r, t, t[ge]) } function ch(e, n, t) { Kd(n); try { const r = e.viewQuery; null !== r && sh(1, r, t); const o = e.template; null !== o && k_(e, n, o, 1, t), e.firstCreatePass && (e.firstCreatePass = !1), n[Un]?.finishViewCreation(e), e.staticContentQueries && G_(e, n), e.staticViewQueries && sh(2, e.viewQuery, t); const i = e.components; null !== i && function TO(e, n) { for (let t = 0; t < n.length; t++)IO(e, n[t]) }(n, i) } catch (r) { throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), r } finally { n[R] &= -5, ef() } } function Gr(e, n) { return !n || null === n.firstChild || as(e) } function Cs(e, n, t, r, o = !1) { for (; null !== t;) { if (128 === t.type) { t = o ? t.projectionNext : t.next; continue } const i = n[t.index]; null !== i && r.push(te(i)), rt(i) && Q_(i, r); const s = t.type; if (8 & s) Cs(e, n, t.child, r); else if (32 & s) { const a = $f(t, n); let c; for (; c = a();)r.push(c) } else if (16 & s) { const a = T_(n, t); if (Array.isArray(a)) r.push(...a); else { const c = $n(n[be]); Cs(c[S], c, a, r, !0) } } t = o ? t.projectionNext : t.next } return r } function Q_(e, n) { for (let t = xe; t < e.length; t++) { const r = e[t], o = r[S].firstChild; null !== o && Cs(r[S], r, o, n) } e[yn] !== e[we] && n.push(e[yn]) } let Y_ = []; const xO = { ...Fa, consumerIsAlwaysLive: !0, consumerMarkedDirty: e => { hc(e.lView) }, consumerOnSignalRead() { this.lView[jt] = this } }, PO = { ...Fa, consumerIsAlwaysLive: !0, consumerMarkedDirty: e => { let n = $n(e.lView); for (; n && !J_(n[S]);)n = $n(n); n && Mv(n) }, consumerOnSignalRead() { this.lView[jt] = this } }; function J_(e) { return 2 !== e.type } const FO = 100; function Zc(e, n = !0, t = 0) { const r = e[vn], o = r.rendererFactory; o.begin?.(); try { !function kO(e, n) { const t = xv(); try { Rv(!0), uh(e, n); let r = 0; for (; fc(e);) { if (r === FO) throw new w(103, !1); r++, uh(e, 1) } } finally { Rv(t) } }(e, t) } catch (s) { throw n && Wc(e, s), s } finally { o.end?.(), r.inlineEffectRunner?.flush() } } function LO(e, n, t, r) { const o = n[R]; if (!(256 & ~o)) return; n[vn].inlineEffectRunner?.flush(), Kd(n); let a = !0, c = null, l = null; J_(e) ? (l = function AO(e) { return e[jt] ?? function NO(e) { const n = Y_.pop() ?? Object.create(xO); return n.lView = e, n }(e) }(n), c = ka(l)) : null === function pm() { return Oe }() ? (a = !1, l = function RO(e) { const n = e[jt] ?? Object.create(PO); return n.lView = e, n }(n), c = ka(l)) : n[jt] && (Ju(n[jt]), n[jt] = null); try { Ev(n), function Pv(e) { return B.lFrame.bindingIndex = e }(e.bindingStartIndex), null !== t && k_(e, n, t, 2, r); const u = !(3 & ~o); if (u) { const h = e.preOrderCheckHooks; null !== h && yc(n, h, null) } else { const h = e.preOrderHooks; null !== h && _c(n, h, 0, null), tf(n, 0) } if (function VO(e) { for (let n = Iy(e); null !== n; n = Sy(n)) { if (!(n[R] & uc.HasTransplantedViews)) continue; const t = n[xo]; for (let r = 0; r < t.length; r++)Mv(t[r]) } }(n), K_(n, 0), null !== e.contentQueries && G_(e, n), u) { const h = e.contentCheckHooks; null !== h && yc(n, h) } else { const h = e.contentHooks; null !== h && _c(n, h, 1), tf(n, 1) } !function nO(e, n) { const t = e.hostBindingOpCodes; if (null !== t) try { for (let r = 0; r < t.length; r++) { const o = t[r]; if (o < 0) kr(~o); else { const i = o, s = t[++r], a = t[++r]; RA(s, i), a(2, n[i]) } } } finally { kr(-1) } }(e, n); const d = e.components; null !== d && tC(n, d, 0); const f = e.viewQuery; if (null !== f && sh(2, f, r), u) { const h = e.viewCheckHooks; null !== h && yc(n, h) } else { const h = e.viewHooks; null !== h && _c(n, h, 2), tf(n, 2) } if (!0 === e.firstUpdatePass && (e.firstUpdatePass = !1), n[cc]) { for (const h of n[cc]) h(); n[cc] = null } n[R] &= -73 } catch (u) { throw hc(n), u } finally { null !== l && (Qu(l, c), a && function OO(e) { e.lView[jt] !== e && (e.lView = null, Y_.push(e)) }(l)), ef() } } function K_(e, n) { for (let t = Iy(e); null !== t; t = Sy(t))for (let r = xe; r < t.length; r++)eC(t[r], n) } function jO(e, n, t) { eC(Nt(n, e), t) } function eC(e, n) { Gd(e) && uh(e, n) } function uh(e, n) { const r = e[S], o = e[R], i = e[jt]; let s = !!(0 === n && 16 & o); if (s ||= !!(64 & o && 0 === n), s ||= !!(1024 & o), s ||= !(!i?.dirty || !Yu(i)), s ||= !1, i && (i.dirty = !1), e[R] &= -9217, s) LO(r, e, r.template, e[ge]); else if (8192 & o) { K_(e, 1); const a = r.components; null !== a && tC(e, a, 1) } } function tC(e, n, t) { for (let r = 0; r < n.length; r++)jO(e, n[r], t) } function Ds(e, n) { const t = xv() ? 64 : 1088; for (e[vn].changeDetectionScheduler?.notify(n); e;) { e[R] |= t; const r = $n(e); if (Yi(e) && !r) return e; e = r } return null } class ws { get rootNodes() { const n = this._lView, t = n[S]; return Cs(t, n, t.firstChild, []) } constructor(n, t, r = !0) { this._lView = n, this._cdRefInjectingView = t, this.notifyErrorHandler = r, this._appRef = null, this._attachedToViewContainer = !1 } get context() { return this._lView[ge] } set context(n) { this._lView[ge] = n } get destroyed() { return !(256 & ~this._lView[R]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const n = this._lView[Le]; if (rt(n)) { const t = n[8], r = t ? t.indexOf(this) : -1; r > -1 && (vs(n, r), Ka(t, r)) } this._attachedToViewContainer = !1 } $c(this._lView[S], this._lView) } onDestroy(n) { pc(this._lView, n) } markForCheck() { Ds(this._cdRefInjectingView || this._lView, 4) } detach() { this._lView[R] &= -129 } reattach() { zd(this._lView), this._lView[R] |= 128 } detectChanges() { this._lView[R] |= 1024, Zc(this._lView, this.notifyErrorHandler) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new w(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null; const n = Yi(this._lView), t = this._lView[xr]; null !== t && !n && zf(t, this._lView), __(this._lView[S], this._lView) } attachToAppRef(n) { if (this._attachedToViewContainer) throw new w(902, !1); this._appRef = n; const t = Yi(this._lView), r = this._lView[xr]; null !== r && !t && C_(r, this._lView), zd(this._lView) } } let Zn = (() => { class e { static { this.__NG_ELEMENT_ID__ = $O } } return e })(); const BO = Zn, UO = class extends BO { constructor(n, t, r) { super(), this._declarationLView = n, this._declarationTContainer = t, this.elementRef = r } get ssrId() { return this._declarationTContainer.tView?.ssrId || null } createEmbeddedView(n, t) { return this.createEmbeddedViewImpl(n, t) } createEmbeddedViewImpl(n, t, r) { const o = function Ho(e, n, t, r) { const o = W(null); try { const i = n.tView, c = zc(e, i, t, 4096 & e[R] ? 4096 : 16, null, n, null, null, r?.injector ?? null, r?.embeddedViewInjector ?? null, r?.dehydratedView ?? null); c[xr] = e[n.index]; const u = e[Un]; return null !== u && (c[Un] = u.createEmbeddedView(i)), ch(i, c, t), c } finally { W(o) } }(this._declarationLView, this._declarationTContainer, n, { embeddedViewInjector: t, dehydratedView: r }); return new ws(o) } }; function $O() { return Qc(le(), C()) } function Qc(e, n) { return 4 & e.type ? new UO(n, e, ko(e, n)) : null } class qo { } const Ns = new T("", { providedIn: "root", factory: () => !1 }), bC = new T(""), Dh = new T(""); class Px { } class EC { } class kx { resolveComponentFactory(n) { throw function Fx(e) { const n = Error(`No component factory found for ${$e(e)}.`); return n.ngComponent = e, n }(n) } } class tl { static { this.NULL = new kx } } class wh { } let Qn = (() => { class e { constructor() { this.destroyNode = null } static { this.__NG_ELEMENT_ID__ = () => function Lx() { const e = C(), t = Nt(le().index, e); return (ze(t) ? t : e)[j] }() } } return e })(), Vx = (() => { class e { static { this.\u0275prov = N({ token: e, providedIn: "root", factory: () => null }) } } return e })(); function rl(e, n, t) { let r = t ? e.styles : null, o = t ? e.classes : null, i = 0; if (null !== n) for (let s = 0; s < n.length; s++) { const a = n[s]; "number" == typeof a ? i = a : 1 == i ? o = dd(o, a) : 2 == i && (r = dd(r, a + ": " + n[++s] + ";")) } t ? e.styles = r : e.stylesWithoutHost = r, t ? e.classes = o : e.classesWithoutHost = o } class TC extends tl { constructor(n) { super(), this.ngModule = n } resolveComponentFactory(n) { const t = Y(n); return new Rs(t, this.ngModule) } } function AC(e, n) { const t = []; for (const r in e) { if (!e.hasOwnProperty(r)) continue; const o = e[r]; if (void 0 === o) continue; const i = Array.isArray(o), s = i ? o[0] : o; t.push(n ? { propName: s, templateName: r, isSignal: !!((i ? o[1] : ir.None) & ir.SignalBased) } : { propName: s, templateName: r }) } return t } class Rs extends EC { get inputs() { const n = this.componentDef, t = n.inputTransforms, r = AC(n.inputs, !0); if (null !== t) for (const o of r) t.hasOwnProperty(o.propName) && (o.transform = t[o.propName]); return r } get outputs() { return AC(this.componentDef.outputs, !1) } constructor(n, t) { super(), this.componentDef = n, this.ngModule = t, this.componentType = n.type, this.selector = function GT(e) { return e.map(HT).join(",") }(n.selectors), this.ngContentSelectors = n.ngContentSelectors ? n.ngContentSelectors : [], this.isBoundToModule = !!t } create(n, t, r, o) { const i = W(null); try { let s = (o = o || this.ngModule) instanceof lt ? o : o?.injector; s && null !== this.componentDef.getStandaloneInjector && (s = this.componentDef.getStandaloneInjector(s) || s); const a = s ? new Lr(n, s) : n, c = a.get(wh, null); if (null === c) throw new w(407, !1); const d = { rendererFactory: c, sanitizer: a.get(Vx, null), inlineEffectRunner: null, changeDetectionScheduler: a.get(qo, null) }, f = c.createRenderer(null, this.componentDef), h = this.componentDef.selectors[0][0] || "div", p = r ? function oO(e, n, t, r) { const i = r.get(qy, !1) || t === Zt.ShadowDom, s = e.selectRootElement(n, i); return function iO(e) { V_(e) }(s), s }(f, r, this.componentDef.encapsulation, a) : Uc(f, h, function Ux(e) { const n = e.toLowerCase(); return "svg" === n ? "svg" : "math" === n ? "math" : null }(h)); let g = 512; this.componentDef.signals ? g |= 4096 : this.componentDef.onPush || (g |= 16); let v = null; null !== p && (v = Af(p, a, !0)); const D = nh(0, null, null, 1, 0, null, null, null, null, null, null), _ = zc(null, D, null, g, null, null, d, f, a, null, v); Kd(_); let A, F, Q = null; try { const ne = this.componentDef; let Ne, nr = null; ne.findHostDirectiveDefs ? (Ne = [], nr = new Map, ne.findHostDirectiveDefs(ne, Ne, nr), Ne.push(ne)) : Ne = [ne]; const jS = function Hx(e, n) { const t = e[S], r = O; return e[r] = n, Hr(t, r, 2, "#host", null) }(_, p); Q = function Gx(e, n, t, r, o, i, s) { const a = o[S]; !function zx(e, n, t, r) { for (const o of e) n.mergedAttrs = qi(n.mergedAttrs, o.hostAttrs); null !== n.mergedAttrs && (rl(n, n.mergedAttrs, !0), null !== t && x_(r, t, n)) }(r, e, n, s); let c = null; null !== n && (c = Af(n, o[Ve])); const l = i.rendererFactory.createRenderer(n, t); let u = 16; t.signals ? u = 4096 : t.onPush && (u = 64); const d = zc(o, L_(t), null, u, o[e.index], e, i, l, null, null, c); return a.firstCreatePass && oh(a, e, r.length - 1), qc(o, d), o[e.index] = d }(jS, p, ne, Ne, _, d, f), F = Xi(D, O), p && function Wx(e, n, t, r) { if (r) Sd(e, t, ["ng-version", "18.2.13"]); else { const { attrs: o, classes: i } = function zT(e) { const n = [], t = []; let r = 1, o = 2; for (; r < e.length;) { let i = e[r]; if ("string" == typeof i) 2 === o ? "" !== i && n.push(i, e[++r]) : 8 === o && t.push(i); else { if (!Qt(o)) break; o = i } r++ } return { attrs: n, classes: t } }(n.selectors[0]); o && Sd(e, t, o), i && i.length > 0 && O_(e, t, i.join(" ")) } }(f, ne, p, r), void 0 !== t && function Zx(e, n, t) { const r = e.projection = []; for (let o = 0; o < n.length; o++) { const i = t[o]; r.push(null != i ? Array.from(i) : null) } }(F, this.ngContentSelectors, t), A = function qx(e, n, t, r, o, i) { const s = le(), a = o[S], c = dt(s, o); U_(a, o, s, t, null, r); for (let u = 0; u < t.length; u++)ot(Vr(o, a, s.directiveStart + u, s), o); $_(a, o, s), c && ot(c, o); const l = Vr(o, a, s.directiveStart + s.componentOffset, s); if (e[ge] = o[ge] = l, null !== i) for (const u of i) u(l, n); return Kf(a, s, o), l }(Q, ne, Ne, nr, _, [Qx]), ch(D, _, null) } catch (ne) { throw null !== Q && Cf(Q), Cf(_), ne } finally { ef() } return new $x(this.componentType, A, ko(F, _), _, F) } finally { W(i) } } } class $x extends Px { constructor(n, t, r, o, i) { super(), this.location = r, this._rootLView = o, this._tNode = i, this.previousInputValues = null, this.instance = t, this.hostView = this.changeDetectorRef = new ws(o, void 0, !1), this.componentType = n } setInput(n, t) { const r = this._tNode.inputs; let o; if (null !== r && (o = r[n])) { if (this.previousInputValues ??= new Map, this.previousInputValues.has(n) && Object.is(this.previousInputValues.get(n), t)) return; const i = this._rootLView; ah(i[S], i, o, n, t), this.previousInputValues.set(n, t), Ds(Nt(this._tNode.index, i), 1) } } get injector() { return new qe(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(n) { this.hostView.onDestroy(n) } } function Qx() { const e = le(); vc(C()[S], e) } let tn = (() => { class e { static { this.__NG_ELEMENT_ID__ = Yx } } return e })(); function Yx() { return xC(le(), C()) } const Jx = tn, NC = class extends Jx { constructor(n, t, r) { super(), this._lContainer = n, this._hostTNode = t, this._hostLView = r } get element() { return ko(this._hostTNode, this._hostLView) } get injector() { return new qe(this._hostTNode, this._hostLView) } get parentInjector() { const n = wc(this._hostTNode, this._hostLView); if (sf(n)) { const t = rs(n, this._hostLView), r = ns(n); return new qe(t[S].data[r + 8], t) } return new qe(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(n) { const t = OC(this._lContainer); return null !== t && t[n] || null } get length() { return this._lContainer.length - xe } createEmbeddedView(n, t, r) { let o, i; "number" == typeof r ? o = r : null != r && (o = r.index, i = r.injector); const a = n.createEmbeddedViewImpl(t || {}, i, null); return this.insertImpl(a, o, Gr(this._hostTNode, null)), a } createComponent(n, t, r, o, i) { const s = n && !function Wi(e) { return "function" == typeof e }(n); let a; if (s) a = t; else { const p = t || {}; a = p.index, r = p.injector, o = p.projectableNodes, i = p.environmentInjector || p.ngModuleRef } const c = s ? n : new Rs(Y(n)), l = r || this.parentInjector; if (!i && null == c.ngModule) { const g = (s ? l : this.parentInjector).get(lt, null); g && (i = g) } Y(c.componentType ?? {}); const h = c.create(l, o, null, i); return this.insertImpl(h.hostView, a, Gr(this._hostTNode, null)), h } insert(n, t) { return this.insertImpl(n, t, !0) } insertImpl(n, t, r) { const o = n._lView; if (function bA(e) { return rt(e[Le]) }(o)) { const a = this.indexOf(n); if (-1 !== a) this.detach(a); else { const c = o[Le], l = new NC(c, c[et], c[Le]); l.detach(l.indexOf(n)) } } const i = this._adjustIndex(t), s = this._lContainer; return function Go(e, n, t, r = !0) { const o = n[S]; if (function Z1(e, n, t, r) { const o = xe + r, i = t.length; r > 0 && (t[o - 1][Yt] = n), r < i - xe ? (n[Yt] = t[o], Wm(t, xe + r, n)) : (t.push(n), n[Yt] = null), n[Le] = t; const s = n[xr]; null !== s && t !== s && C_(s, n); const a = n[Un]; null !== a && a.insertView(e), zd(n), n[R] |= 128 }(o, n, e, t), r) { const s = Yf(t, e), a = n[j], c = Zf(a, e[yn]); null !== c && function q1(e, n, t, r, o, i) { r[we] = o, r[et] = n, Gc(e, r, t, 1, o, i) }(o, e[et], a, n, c, s) } const i = n[ut]; null !== i && null !== i.firstChild && (i.firstChild = null) }(s, o, i, r), n.attachToViewContainerRef(), Wm(Mh(s), i, n), n } move(n, t) { return this.insert(n, t) } indexOf(n) { const t = OC(this._lContainer); return null !== t ? t.indexOf(n) : -1 } remove(n) { const t = this._adjustIndex(n, -1), r = vs(this._lContainer, t); r && (Ka(Mh(this._lContainer), t), $c(r[S], r)) } detach(n) { const t = this._adjustIndex(n, -1), r = vs(this._lContainer, t); return r && null != Ka(Mh(this._lContainer), t) ? new ws(r) : null } _adjustIndex(n, t = 0) { return n ?? this.length + t } }; function OC(e) { return e[8] } function Mh(e) { return e[8] || (e[8] = []) } function xC(e, n) { let t; const r = n[e.index]; return rt(r) ? t = r : (t = H_(r, n, null, e), n[e.index] = t, qc(n, t)), RC(t, n, e, r), new NC(t, e, n) } let RC = function FC(e, n, t, r) { if (e[yn]) return; let o; o = 8 & t.type ? te(r) : function Xx(e, n) { const t = e[j], r = t.createComment(""), o = dt(n, e); return Ur(t, Zf(t, o), r, function J1(e, n) { return e.nextSibling(n) }(t, o), !1), r }(n, t), e[yn] = o }, Ih = () => !1; class Sh { constructor(n) { this.queryList = n, this.matches = null } clone() { return new Sh(this.queryList) } setDirty() { this.queryList.setDirty() } } class Th { constructor(n = []) { this.queries = n } createEmbeddedView(n) { const t = n.queries; if (null !== t) { const r = null !== n.contentQueries ? n.contentQueries[0] : t.length, o = []; for (let i = 0; i < r; i++) { const s = t.getByIndex(i); o.push(this.queries[s.indexInDeclarationView].clone()) } return new Th(o) } return null } insertView(n) { this.dirtyQueriesWithMatches(n) } detachView(n) { this.dirtyQueriesWithMatches(n) } finishViewCreation(n) { this.dirtyQueriesWithMatches(n) } dirtyQueriesWithMatches(n) { for (let t = 0; t < this.queries.length; t++)null !== Rh(n, t).matches && this.queries[t].setDirty() } } class kC { constructor(n, t, r = null) { this.flags = t, this.read = r, this.predicate = "string" == typeof n ? function sR(e) { return e.split(",").map(n => n.trim()) }(n) : n } } class Ah { constructor(n = []) { this.queries = n } elementStart(n, t) { for (let r = 0; r < this.queries.length; r++)this.queries[r].elementStart(n, t) } elementEnd(n) { for (let t = 0; t < this.queries.length; t++)this.queries[t].elementEnd(n) } embeddedTView(n) { let t = null; for (let r = 0; r < this.length; r++) { const o = null !== t ? t.length : 0, i = this.getByIndex(r).embeddedTView(n, o); i && (i.indexInDeclarationView = r, null !== t ? t.push(i) : t = [i]) } return null !== t ? new Ah(t) : null } template(n, t) { for (let r = 0; r < this.queries.length; r++)this.queries[r].template(n, t) } getByIndex(n) { return this.queries[n] } get length() { return this.queries.length } track(n) { this.queries.push(n) } } class Nh { constructor(n, t = -1) { this.metadata = n, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = t } elementStart(n, t) { this.isApplyingToNode(t) && this.matchTNode(n, t) } elementEnd(n) { this._declarationNodeIndex === n.index && (this._appliesToNextNode = !1) } template(n, t) { this.elementStart(n, t) } embeddedTView(n, t) { return this.isApplyingToNode(n) ? (this.crossesNgTemplate = !0, this.addMatch(-n.index, t), new Nh(this.metadata)) : null } isApplyingToNode(n) { if (this._appliesToNextNode && 1 & ~this.metadata.flags) { const t = this._declarationNodeIndex; let r = n.parent; for (; null !== r && 8 & r.type && r.index !== t;)r = r.parent; return t === (null !== r ? r.index : -1) } return this._appliesToNextNode } matchTNode(n, t) { const r = this.metadata.predicate; if (Array.isArray(r)) for (let o = 0; o < r.length; o++) { const i = r[o]; this.matchTNodeWithReadOption(n, t, nR(t, i)), this.matchTNodeWithReadOption(n, t, bc(t, n, i, !1, !1)) } else r === Zn ? 4 & t.type && this.matchTNodeWithReadOption(n, t, -1) : this.matchTNodeWithReadOption(n, t, bc(t, n, r, !1, !1)) } matchTNodeWithReadOption(n, t, r) { if (null !== r) { const o = this.metadata.read; if (null !== o) if (o === Ot || o === tn || o === Zn && 4 & t.type) this.addMatch(t.index, -2); else { const i = bc(t, n, o, !1, !1); null !== i && this.addMatch(t.index, i) } else this.addMatch(t.index, r) } } addMatch(n, t) { null === this.matches ? this.matches = [n, t] : this.matches.push(n, t) } } function nR(e, n) { const t = e.localNames; if (null !== t) for (let r = 0; r < t.length; r += 2)if (t[r] === n) return t[r + 1]; return null } function oR(e, n, t, r) { return -1 === t ? function rR(e, n) { return 11 & e.type ? ko(e, n) : 4 & e.type ? Qc(e, n) : null }(n, e) : -2 === t ? function iR(e, n, t) { return t === Ot ? ko(n, e) : t === Zn ? Qc(n, e) : t === tn ? xC(n, e) : void 0 }(e, n, r) : Vr(e, e[S], t, n) } function LC(e, n, t, r) { const o = n[Un].queries[r]; if (null === o.matches) { const i = e.data, s = t.matches, a = []; for (let c = 0; null !== s && c < s.length; c += 2) { const l = s[c]; a.push(l < 0 ? null : oR(n, i[l], s[c + 1], t.metadata.read)) } o.matches = a } return o.matches } function Oh(e, n, t, r) { const o = e.queries.getByIndex(t), i = o.matches; if (null !== i) { const s = LC(e, n, o, t); for (let a = 0; a < i.length; a += 2) { const c = i[a]; if (c > 0) r.push(s[a / 2]); else { const l = i[a + 1], u = n[-c]; for (let d = xe; d < u.length; d++) { const f = u[d]; f[xr] === f[Le] && Oh(f[S], f, l, r) } if (null !== u[xo]) { const d = u[xo]; for (let f = 0; f < d.length; f++) { const h = d[f]; Oh(h[S], h, l, r) } } } } } return r } function BC(e, n, t, r) { const o = Z(); if (o.firstCreatePass) { const i = le(); (function UC(e, n, t) { null === e.queries && (e.queries = new Ah), e.queries.track(new Nh(n, t)) })(o, new kC(n, t, r), i.index), function aR(e, n) { const t = e.contentQueries || (e.contentQueries = []); n !== (t.length ? t[t.length - 1] : -1) && t.push(e.queries.length - 1, n) }(o, e), !(2 & ~t) && (o.staticContentQueries = !0) } return function VC(e, n, t) { const r = new vf(!(4 & ~t)); return function cO(e, n, t, r) { const o = z_(n); o.push(t), e.firstCreatePass && q_(e).push(r, o.length - 1) }(e, n, r, r.destroy), (n[Un] ??= new Th).queries.push(new Sh(r)) - 1 }(o, C(), t) } function Rh(e, n) { return e.queries.getByIndex(n) } function $C(e, n) { const t = e[S], r = Rh(t, n); return r.crossesNgTemplate ? Oh(t, e, n, []) : LC(t, e, r, n) } const HC = new Set; function ht(e) { HC.has(e) || (HC.add(e), performance?.mark?.("mark_feature_usage", { detail: { feature: e } })) } function Wo(e, n) { ht("NgSignals"); const t = function qS(e) { const n = Object.create(ZS); n.value = e; const t = () => (Zu(n), n.value); return t[Wt] = n, t }(e), r = t[Wt]; return n?.equal && (r.equal = n.equal), t.set = o => Em(r, o), t.update = o => function WS(e, n) { vm() || bm(), Em(e, n(e.value)) }(r, o), t.asReadonly = zC.bind(t), t } function zC() { const e = this[Wt]; if (void 0 === e.readonlyFn) { const n = () => this(); n[Wt] = e, e.readonlyFn = n } return e.readonlyFn } function qC(e) { return function GC(e) { return "function" == typeof e && void 0 !== e[Wt] }(e) && "function" == typeof e.set } function ue(e) { let n = function rD(e) { return Object.getPrototypeOf(e.prototype).constructor }(e.type), t = !0; const r = [e]; for (; n;) { let o; if (Jt(e)) o = n.\u0275cmp || n.\u0275dir; else { if (n.\u0275cmp) throw new w(903, !1); o = n.\u0275dir } if (o) { if (t) { r.push(o); const s = e; s.inputs = il(e.inputs), s.inputTransforms = il(e.inputTransforms), s.declaredInputs = il(e.declaredInputs), s.outputs = il(e.outputs); const a = o.hostBindings; a && DR(e, a); const c = o.viewQuery, l = o.contentQueries; if (c && _R(e, c), l && CR(e, l), vR(e, o), uT(e.outputs, o.outputs), Jt(o) && o.data.animation) { const u = e.data; u.animation = (u.animation || []).concat(o.data.animation) } } const i = o.features; if (i) for (let s = 0; s < i.length; s++) { const a = i[s]; a && a.ngInherit && a(e), a === ue && (t = !1) } } n = Object.getPrototypeOf(n) } !function yR(e) { let n = 0, t = null; for (let r = e.length - 1; r >= 0; r--) { const o = e[r]; o.hostVars = n += o.hostVars, o.hostAttrs = qi(o.hostAttrs, t = qi(t, o.hostAttrs)) } }(r) } function vR(e, n) { for (const t in n.inputs) { if (!n.inputs.hasOwnProperty(t) || e.inputs.hasOwnProperty(t)) continue; const r = n.inputs[t]; if (void 0 !== r && (e.inputs[t] = r, e.declaredInputs[t] = n.declaredInputs[t], null !== n.inputTransforms)) { const o = Array.isArray(r) ? r[0] : r; if (!n.inputTransforms.hasOwnProperty(o)) continue; e.inputTransforms ??= {}, e.inputTransforms[o] = n.inputTransforms[o] } } } function il(e) { return e === hn ? {} : e === ee ? [] : e } function _R(e, n) { const t = e.viewQuery; e.viewQuery = t ? (r, o) => { n(r, o), t(r, o) } : n } function CR(e, n) { const t = e.contentQueries; e.contentQueries = t ? (r, o, i) => { n(r, o, i), t(r, o, i) } : n } function DR(e, n) { const t = e.hostBindings; e.hostBindings = t ? (r, o) => { n(r, o), t(r, o) } : n } function cD(e) { const n = e.inputConfig, t = {}; for (const r in n) if (n.hasOwnProperty(r)) { const o = n[r]; Array.isArray(o) && o[3] && (t[r] = o[3]) } e.inputTransforms = t } class Wr { } class lD { } class kh extends Wr { constructor(n, t, r, o = !0) { super(), this.ngModuleType = n, this._parent = t, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new TC(this); const i = nt(n); this._bootstrapComponents = Rt(i.bootstrap), this._r3Injector = ay(n, t, [{ provide: Wr, useValue: this }, { provide: tl, useValue: this.componentFactoryResolver }, ...r], $e(n), new Set(["environment"])), o && this.resolveInjectorInitializers() } resolveInjectorInitializers() { this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(this.ngModuleType) } get injector() { return this._r3Injector } destroy() { const n = this._r3Injector; !n.destroyed && n.destroy(), this.destroyCbs.forEach(t => t()), this.destroyCbs = null } onDestroy(n) { this.destroyCbs.push(n) } } class Lh extends lD { constructor(n) { super(), this.moduleType = n } create(n) { return new kh(this.moduleType, n, []) } } class uD extends Wr { constructor(n) { super(), this.componentFactoryResolver = new TC(this), this.instance = null; const t = new Mo([...n.providers, { provide: Wr, useValue: this }, { provide: tl, useValue: this.componentFactoryResolver }], n.parent || sc(), n.debugName, new Set(["environment"])); this.injector = t, n.runEnvironmentInitializers && t.resolveInjectorInitializers() } destroy() { this.injector.destroy() } onDestroy(n) { this.injector.onDestroy(n) } } function sl(e, n, t = null) { return new uD({ providers: e, parent: n, debugName: t, runEnvironmentInitializers: !0 }).injector } function al(e) { return !!function Vh(e) { return null !== e && ("function" == typeof e || "object" == typeof e) }(e) && (Array.isArray(e) || !(e instanceof Map) && Symbol.iterator in e) } function Mn(e, n, t) { return e[n] = t } function Re(e, n, t) { return !Object.is(e[n], t) && (e[n] = t, !0) } function Zr(e, n, t, r) { const o = Re(e, n, t); return Re(e, n + 1, r) || o } function ks(e, n, t, r, o, i, s, a, c, l) { const u = t + O, d = n.firstCreatePass ? function RR(e, n, t, r, o, i, s, a, c) { const l = n.consts, u = Hr(n, e, 4, s || null, a || null); rh(n, t, u, Ut(l, c)), vc(n, u); const d = u.tView = nh(2, u, r, o, i, n.directiveRegistry, n.pipeRegistry, null, n.schemas, l, null); return null !== n.queries && (n.queries.template(n, u), d.queries = n.queries.embeddedTView(u)), u }(u, n, e, r, o, i, s, a, c) : n.data[u]; Xt(d, !1); const f = dD(n, e, d, t); es() && Hc(n, e, f, d), ot(f, e); const h = H_(f, e, f, d); return e[u] = h, qc(e, h), function PC(e, n, t) { return Ih(e, n, t) }(h, d, e), dc(d) && eh(n, e, d), null != c && th(e, d, l), d } function De(e, n, t, r, o, i, s, a) { const c = C(), l = Z(); return ks(c, l, e, n, t, r, o, Ut(l.consts, i), s, a), De } let dD = function fD(e, n, t, r) { return Cn(!0), n[j].createComment("") }; var Jo = function (e) { return e[e.EarlyRead = 0] = "EarlyRead", e[e.Write = 1] = "Write", e[e.MixedReadWrite = 2] = "MixedReadWrite", e[e.Read = 3] = "Read", e }(Jo || {}); let yD = (() => { class e { constructor() { this.impl = null } execute() { this.impl?.execute() } static { this.\u0275prov = N({ token: e, providedIn: "root", factory: () => new e }) } } return e })(); class js { constructor() { this.ngZone = b(ie), this.scheduler = b(qo), this.errorHandler = b(wn, { optional: !0 }), this.sequences = new Set, this.deferredRegistrations = new Set, this.executing = !1 } static { this.PHASES = [Jo.EarlyRead, Jo.Write, Jo.MixedReadWrite, Jo.Read] } execute() { this.executing = !0; for (const n of js.PHASES) for (const t of this.sequences) if (!t.erroredOrDestroyed && t.hooks[n]) try { t.pipelinedValue = this.ngZone.runOutsideAngular(() => t.hooks[n](t.pipelinedValue)) } catch (r) { t.erroredOrDestroyed = !0, this.errorHandler?.handleError(r) } this.executing = !1; for (const n of this.sequences) n.afterRun(), n.once && (this.sequences.delete(n), n.destroy()); for (const n of this.deferredRegistrations) this.sequences.add(n); this.deferredRegistrations.size > 0 && this.scheduler.notify(7), this.deferredRegistrations.clear() } register(n) { this.executing ? this.deferredRegistrations.add(n) : (this.sequences.add(n), this.scheduler.notify(6)) } unregister(n) { this.executing && this.sequences.has(n) ? (n.erroredOrDestroyed = !0, n.pipelinedValue = void 0, n.once = !0) : (this.sequences.delete(n), this.deferredRegistrations.delete(n)) } static { this.\u0275prov = N({ token: js, providedIn: "root", factory: () => new js }) } } class LR { constructor(n, t, r, o) { this.impl = n, this.hooks = t, this.once = r, this.erroredOrDestroyed = !1, this.pipelinedValue = void 0, this.unregisterOnDestroy = o?.onDestroy(() => this.destroy()) } afterRun() { this.erroredOrDestroyed = !1, this.pipelinedValue = void 0 } destroy() { this.impl.unregister(this), this.unregisterOnDestroy?.() } } function fl(e, n) { !n?.injector && function kd(e) { if (!uv()) throw new w(-203, !1) }(); const t = n?.injector ?? b(Je); return function Pt(e) { return "browser" === (e ?? b(Je)).get(zn) }(t) ? (ht("NgAfterNextRender"), function _D(e, n, t, r) { const o = n.get(yD); o.impl ??= n.get(js); const i = t?.phase ?? Jo.MixedReadWrite, s = !0 !== t?.manualCleanup ? n.get(is) : null, a = new LR(o.impl, function jR(e, n) { if (e instanceof Function) { const t = [void 0, void 0, void 0, void 0]; return t[n] = e, t } return [e.earlyRead, e.write, e.mixedReadWrite, e.read] }(e, i), r, s); return o.impl.register(a), a }(e, t, n, !0)) : CD } const CD = { destroy() { } }; function nn(e, n, t, r) { const o = C(); return Re(o, Kt(), n) && (Z(), En(me(), o, e, n, t, r)), nn } function ii(e, n, t, r, o, i) { const a = Zr(e, function Hn() { return B.lFrame.bindingIndex }(), t, o); return Gn(2), a ? n + H(t) + r + H(o) + i : G } function gl(e, n) { return e << 17 | n << 2 } function pr(e) { return e >> 17 & 32767 } function Qh(e) { return 2 | e } function Yr(e) { return (131068 & e) >> 2 } function Yh(e, n) { return -131069 & e | n << 2 } function Jh(e) { return 1 | e } function qD(e, n, t, r) { const o = e[t + 1], i = null === n; let s = r ? pr(o) : Yr(o), a = !1; for (; 0 !== s && (!1 === a || i);) { const l = e[s + 1]; DP(e[s], n) && (a = !0, e[s + 1] = r ? Jh(l) : Qh(l)), s = r ? pr(l) : Yr(l) } a && (e[t + 1] = r ? Qh(o) : Jh(o)) } function DP(e, n) { return null === e || null == n || (Array.isArray(e) ? e[1] : e) === n || !(!Array.isArray(e) || "string" != typeof n) && wo(e, n) >= 0 } const We = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }; function WD(e) { return e.substring(We.key, We.keyEnd) } function ZD(e, n) { const t = We.textEnd; return t === n ? -1 : (n = We.keyEnd = function MP(e, n, t) { for (; n < t && e.charCodeAt(n) > 32;)n++; return n }(e, We.key = n, t), fi(e, n, t)) } function fi(e, n, t) { for (; n < t && e.charCodeAt(n) <= 32;)n++; return n } function P(e, n, t) { const r = C(); return Re(r, Kt(), n) && wt(Z(), me(), r, e, n, r[j], t, !1), P } function Xh(e, n, t, r, o) { const s = o ? "class" : "style"; ah(e, t, n.inputs[s], s, r) } function hi(e, n, t) { return rn(e, n, t, !1), hi } function pi(e, n) { return rn(e, n, null, !0), pi } function gi(e) { !function on(e, n, t, r) { const o = Z(), i = Gn(2); o.firstUpdatePass && ew(o, null, i, r); const s = C(); if (t !== G && Re(s, i, t)) { const a = o.data[tt()]; if (ow(a, r) && !KD(o, i)) { let c = r ? a.classesWithoutHost : a.stylesWithoutHost; null !== c && (t = dd(c, t || "")), Xh(o, a, s, t, r) } else !function FP(e, n, t, r, o, i, s, a) { o === G && (o = ee); let c = 0, l = 0, u = 0 < o.length ? o[0] : null, d = 0 < i.length ? i[0] : null; for (; null !== u || null !== d;) { const f = c < o.length ? o[c + 1] : void 0, h = l < i.length ? i[l + 1] : void 0; let g, p = null; u === d ? (c += 2, l += 2, f !== h && (p = d, g = h)) : null === d || null !== u && u < d ? (c += 2, p = u) : (l += 2, p = d, g = h), null !== p && nw(e, n, t, r, p, g, s, a), u = c < o.length ? o[c] : null, d = l < i.length ? i[l] : null } }(o, a, s, s[j], s[i + 1], s[i + 1] = function RP(e, n, t) { if (null == t || "" === t) return ee; const r = [], o = xt(t); if (Array.isArray(o)) for (let i = 0; i < o.length; i++)e(r, o[i], !0); else if ("object" == typeof o) for (const i in o) o.hasOwnProperty(i) && e(r, i, o[i]); else "string" == typeof o && n(r, o); return r }(e, n, t), r, i) } }(PP, Sn, e, !0) } function Sn(e, n) { for (let t = function bP(e) { return function YD(e) { We.key = 0, We.keyEnd = 0, We.value = 0, We.valueEnd = 0, We.textEnd = e.length }(e), ZD(e, fi(e, 0, We.textEnd)) }(n); t >= 0; t = ZD(n, t))At(e, WD(n), !0) } function rn(e, n, t, r) { const o = C(), i = Z(), s = Gn(2); i.firstUpdatePass && ew(i, e, s, r), n !== G && Re(o, s, n) && nw(i, i.data[tt()], o, o[j], e, o[s + 1] = function kP(e, n) { return null == e || "" === e || ("string" == typeof n ? e += n : "object" == typeof e && (e = $e(xt(e)))), e }(n, t), r, s) } function KD(e, n) { return n >= e.expandoStartIndex } function ew(e, n, t, r) { const o = e.data; if (null === o[t + 1]) { const i = o[tt()], s = KD(e, t); ow(i, r) && null === n && !s && (n = !1), n = function AP(e, n, t, r) { const o = function Jd(e) { const n = B.lFrame.currentDirectiveIndex; return -1 === n ? null : e[n] }(e); let i = r ? n.residualClasses : n.residualStyles; if (null === o) 0 === (r ? n.classBindings : n.styleBindings) && (t = Us(t = Kh(null, e, n, t, r), n.attrs, r), i = null); else { const s = n.directiveStylingLast; if (-1 === s || e[s] !== o) if (t = Kh(o, e, n, t, r), null === i) { let c = function NP(e, n, t) { const r = t ? n.classBindings : n.styleBindings; if (0 !== Yr(r)) return e[pr(r)] }(e, n, r); void 0 !== c && Array.isArray(c) && (c = Kh(null, e, n, c[1], r), c = Us(c, n.attrs, r), function OP(e, n, t, r) { e[pr(t ? n.classBindings : n.styleBindings)] = r }(e, n, r, c)) } else i = function xP(e, n, t) { let r; const o = n.directiveEnd; for (let i = 1 + n.directiveStylingLast; i < o; i++)r = Us(r, e[i].hostAttrs, t); return Us(r, n.attrs, t) }(e, n, r) } return void 0 !== i && (r ? n.residualClasses = i : n.residualStyles = i), t }(o, i, n, r), function _P(e, n, t, r, o, i) { let s = i ? n.classBindings : n.styleBindings, a = pr(s), c = Yr(s); e[r] = t; let u, l = !1; if (Array.isArray(t) ? (u = t[1], (null === u || wo(t, u) > 0) && (l = !0)) : u = t, o) if (0 !== c) { const f = pr(e[a + 1]); e[r + 1] = gl(f, a), 0 !== f && (e[f + 1] = Yh(e[f + 1], r)), e[a + 1] = function vP(e, n) { return 131071 & e | n << 17 }(e[a + 1], r) } else e[r + 1] = gl(a, 0), 0 !== a && (e[a + 1] = Yh(e[a + 1], r)), a = r; else e[r + 1] = gl(c, 0), 0 === a ? a = r : e[c + 1] = Yh(e[c + 1], r), c = r; l && (e[r + 1] = Qh(e[r + 1])), qD(e, u, r, !0), qD(e, u, r, !1), function CP(e, n, t, r, o) { const i = o ? e.residualClasses : e.residualStyles; null != i && "string" == typeof n && wo(i, n) >= 0 && (t[r + 1] = Jh(t[r + 1])) }(n, u, e, r, i), s = gl(a, c), i ? n.classBindings = s : n.styleBindings = s }(o, i, n, t, s, r) } } function Kh(e, n, t, r, o) { let i = null; const s = t.directiveEnd; let a = t.directiveStylingLast; for (-1 === a ? a = t.directiveStart : a++; a < s && (i = n[a], r = Us(r, i.hostAttrs, o), i !== e);)a++; return null !== e && (t.directiveStylingLast = a), r } function Us(e, n, t) { const r = t ? 1 : 2; let o = -1; if (null !== n) for (let i = 0; i < n.length; i++) { const s = n[i]; "number" == typeof s ? o = s : o === r && (Array.isArray(e) || (e = void 0 === e ? [] : ["", e]), At(e, s, !!t || n[++i])) } return void 0 === e ? null : e } function PP(e, n, t) { const r = String(n); "" !== r && !r.includes(" ") && At(e, r, t) } function nw(e, n, t, r, o, i, s, a) { if (!(3 & n.type)) return; const c = e.data, l = c[a + 1], u = function yP(e) { return !(1 & ~e) }(l) ? rw(c, n, t, o, Yr(l), s) : void 0; ml(u) || (ml(i) || function mP(e) { return !(2 & ~e) }(l) && (i = rw(c, null, t, o, a, s)), function eO(e, n, t, r, o) { if (n) o ? e.addClass(t, r) : e.removeClass(t, r); else { let i = -1 === r.indexOf("-") ? void 0 : ur.DashCase; null == o ? e.removeStyle(t, r, i) : ("string" == typeof o && o.endsWith("!important") && (o = o.slice(0, -10), i |= ur.Important), e.setStyle(t, r, o, i)) } }(r, s, Ji(tt(), t), o, i)) } function rw(e, n, t, r, o, i) { const s = null === n; let a; for (; o > 0;) { const c = e[o], l = Array.isArray(c), u = l ? c[1] : c, d = null === u; let f = t[o + 1]; f === G && (f = d ? ee : void 0); let h = d ? Md(f, r) : u === r ? f : void 0; if (l && !ml(h) && (h = Md(c, r)), ml(h) && (a = h, s)) return a; const p = e[o + 1]; o = s ? pr(p) : Yr(p) } if (null !== n) { let c = i ? n.residualClasses : n.residualStyles; null != c && (a = Md(c, r)) } return a } function ml(e) { return void 0 !== e } function ow(e, n) { return !!(e.flags & (n ? 8 : 16)) } function y(e, n, t, r) { const o = C(), i = Z(), s = O + e, a = o[j], c = i.firstCreatePass ? function iF(e, n, t, r, o, i) { const s = n.consts, c = Hr(n, e, 2, r, Ut(s, o)); return rh(n, t, c, Ut(s, i)), null !== c.attrs && rl(c, c.attrs, !1), null !== c.mergedAttrs && rl(c, c.mergedAttrs, !0), null !== n.queries && n.queries.elementStart(n, c), c }(s, i, o, n, t, r) : i.data[s], l = cw(i, o, c, a, n, e); o[s] = l; const u = dc(c); return Xt(c, !0), x_(a, l, c), !function Qo(e) { return !(32 & ~e.flags) }(c) && es() && Hc(i, o, l, c), 0 === function EA() { return B.lFrame.elementDepthCount }() && ot(l, o), function MA() { B.lFrame.elementDepthCount++ }(), u && (eh(i, o, c), Kf(i, c, o)), null !== r && th(o, c), y } function m() { let e = le(); Zd() ? function Qd() { B.lFrame.isParent = !1 }() : (e = e.parent, Xt(e, !1)); const n = e; (function SA(e) { return B.skipHydrationRootTNode === e })(n) && function OA() { B.skipHydrationRootTNode = null }(), function IA() { B.lFrame.elementDepthCount-- }(); const t = Z(); return t.firstCreatePass && (vc(t, e), jd(e) && t.queries.elementEnd(e)), null != n.classesWithoutHost && function zA(e) { return !!(8 & e.flags) }(n) && Xh(t, n, C(), n.classesWithoutHost, !0), null != n.stylesWithoutHost && function qA(e) { return !!(16 & e.flags) }(n) && Xh(t, n, C(), n.stylesWithoutHost, !1), m } function k(e, n, t, r) { return y(e, n, t, r), m(), k } let cw = (e, n, t, r, o, i) => (Cn(!0), Uc(r, o, function Uv() { return B.lFrame.currentNamespace }())); function Tn() { return C() } const Jr = void 0; var fF = ["en", [["a", "p"], ["AM", "PM"], Jr], [["AM", "PM"], Jr, Jr], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], Jr, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], Jr, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", Jr, "{1} 'at' {0}", Jr], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function dF(e) { const t = Math.floor(Math.abs(e)), r = e.toString().replace(/^[^.]*\.?/, "").length; return 1 === t && 0 === r ? 1 : 5 }]; let mi = {}; function pt(e) { const n = function hF(e) { return e.toLowerCase().replace(/_/g, "-") }(e); let t = pw(n); if (t) return t; const r = n.split("-")[0]; if (t = pw(r), t) return t; if ("en" === r) return fF; throw new w(701, !1) } function pw(e) { return e in mi || (mi[e] = Ce.ng && Ce.ng.common && Ce.ng.common.locales && Ce.ng.common.locales[e]), mi[e] } var ve = function (e) { return e[e.LocaleId = 0] = "LocaleId", e[e.DayPeriodsFormat = 1] = "DayPeriodsFormat", e[e.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", e[e.DaysFormat = 3] = "DaysFormat", e[e.DaysStandalone = 4] = "DaysStandalone", e[e.MonthsFormat = 5] = "MonthsFormat", e[e.MonthsStandalone = 6] = "MonthsStandalone", e[e.Eras = 7] = "Eras", e[e.FirstDayOfWeek = 8] = "FirstDayOfWeek", e[e.WeekendRange = 9] = "WeekendRange", e[e.DateFormat = 10] = "DateFormat", e[e.TimeFormat = 11] = "TimeFormat", e[e.DateTimeFormat = 12] = "DateTimeFormat", e[e.NumberSymbols = 13] = "NumberSymbols", e[e.NumberFormats = 14] = "NumberFormats", e[e.CurrencyCode = 15] = "CurrencyCode", e[e.CurrencySymbol = 16] = "CurrencySymbol", e[e.CurrencyName = 17] = "CurrencyName", e[e.Currencies = 18] = "Currencies", e[e.Directionality = 19] = "Directionality", e[e.PluralCase = 20] = "PluralCase", e[e.ExtraData = 21] = "ExtraData", e }(ve || {}); const yl = "en-US"; let gw = yl, Rw = (e, n, t) => { }; function re(e, n, t, r) { const o = C(), i = Z(), s = le(); return ap(i, o, o[j], s, e, n, r), re } function ap(e, n, t, r, o, i, s) { const a = dc(r), l = e.firstCreatePass && q_(e), u = n[ge], d = z_(n); let f = !0; if (3 & r.type || s) { const g = dt(r, n), v = s ? s(g) : g, D = d.length, _ = s ? F => s(te(F[r.index])) : r.index; let A = null; if (!s && a && (A = function tk(e, n, t, r) { const o = e.cleanup; if (null != o) for (let i = 0; i < o.length - 1; i += 2) { const s = o[i]; if (s === t && o[i + 1] === r) { const a = n[To], c = o[i + 2]; return a.length > c ? a[c] : null } "string" == typeof s && (i += 2) } return null }(e, n, o, r.index)), null !== A) (A.__ngLastListenerFn__ || A).__ngNextListenerFn__ = i, A.__ngLastListenerFn__ = i, f = !1; else { i = Lw(r, n, u, i), Rw(g, o, i); const F = t.listen(v, o, i); d.push(i, F), l && l.push(o, _, D, D + 1) } } else i = Lw(r, n, u, i); const h = r.outputs; let p; if (f && null !== h && (p = h[o])) { const g = p.length; if (g) for (let v = 0; v < g; v += 2) { const Q = n[p[v]][p[v + 1]].subscribe(i), ne = d.length; d.push(i, Q), l && l.push(o, r.index, ne, -(ne + 1)) } } } function kw(e, n, t, r) { const o = W(null); try { return _n(6, n, t), !1 !== t(r) } catch (i) { return Wc(e, i), !1 } finally { _n(7, n, t), W(o) } } function Lw(e, n, t, r) { return function o(i) { if (i === Function) return r; Ds(e.componentOffset > -1 ? Nt(e.index, n) : n, 5); let a = kw(n, t, r, i), c = o.__ngNextListenerFn__; for (; c;)a = kw(n, t, c, i) && a, c = c.__ngNextListenerFn__; return a } } function z(e = 1) { return function kA(e) { return (B.lFrame.contextLView = function Iv(e, n) { for (; e > 0;)n = n[Ao], e--; return n }(e, B.lFrame.contextLView))[ge] }(e) } function Qw() { return function xh(e, n) { return e[Un].queries[n].queryList }(C(), Xd()) } function Yw(e) { return Pr(function Nv() { return B.lFrame.contextLView }(), O + e) } function E(e, n = "") { const t = C(), r = Z(), o = e + O, i = r.firstCreatePass ? Hr(r, o, 1, n, null) : r.data[o], s = sb(r, t, i, n, e); t[o] = s, es() && Hc(r, t, s, i), Xt(i, !1) } let sb = (e, n, t, r, o) => (Cn(!0), function Hf(e, n) { return e.createText(n) }(n[j], r)); function Me(e) { return Ae("", e, ""), Me } function Ae(e, n, t) { const r = C(), o = function oi(e, n, t, r) { return Re(e, Kt(), t) ? n + H(t) + r : G }(r, e, n, t); return o !== G && Wn(r, tt(), o), Ae } function wl(e, n, t, r, o) { const i = C(), s = ii(i, e, n, t, r, o); return s !== G && Wn(i, tt(), s), wl } function sn(e, n, t) { qC(n) && (n = n()); const r = C(); return Re(r, Kt(), n) && wt(Z(), me(), r, e, n, r[j], t, !1), sn } function An(e, n) { const t = qC(e); return t && e.set(n), t } function an(e, n) { const t = C(), r = Z(), o = le(); return ap(r, t, t[j], o, e, n), an } function up(e, n, t, r, o) { if (e = V(e), Array.isArray(e)) for (let i = 0; i < e.length; i++)up(e[i], n, t, r, o); else { const i = Z(), s = C(), a = le(); let c = Or(e) ? e : V(e.provide); const l = lv(e), u = 1048575 & a.providerIndexes, d = a.directiveStart, f = a.providerIndexes >> 20; if (Or(e) || !e.multi) { const h = new ts(l, o, M), p = fp(c, n, o ? u : u + f, d); -1 === p ? (lf(Dc(a, s), i, c), dp(i, e, n.length), n.push(c), a.directiveStart++, a.directiveEnd++, o && (a.providerIndexes += 1048576), t.push(h), s.push(h)) : (t[p] = h, s[p] = h) } else { const h = fp(c, n, u + f, d), p = fp(c, n, u, u + f), v = p >= 0 && t[p]; if (o && !v || !o && !(h >= 0 && t[h])) { lf(Dc(a, s), i, c); const D = function Ik(e, n, t, r, o) { const i = new ts(e, t, M); return i.multi = [], i.index = n, i.componentProviders = 0, mb(i, o, r && !t), i }(o ? Mk : Ek, t.length, o, r, l); !o && v && (t[p].providerFactory = D), dp(i, e, n.length, 0), n.push(c), a.directiveStart++, a.directiveEnd++, o && (a.providerIndexes += 1048576), t.push(D), s.push(D) } else dp(i, e, h > -1 ? h : p, mb(t[o ? p : h], l, !o && r)); !o && r && v && t[p].componentProviders++ } } } function dp(e, n, t, r) { const o = Or(n), i = function XT(e) { return !!e.useClass }(n); if (o || i) { const c = (i ? V(n.useClass) : n).prototype.ngOnDestroy; if (c) { const l = e.destroyHooks || (e.destroyHooks = []); if (!o && n.multi) { const u = l.indexOf(t); -1 === u ? l.push(t, [r, c]) : l[u + 1].push(r, c) } else l.push(t, c) } } } function mb(e, n, t) { return t && e.componentProviders++, e.multi.push(n) - 1 } function fp(e, n, t, r) { for (let o = t; o < r; o++)if (n[o] === e) return o; return -1 } function Ek(e, n, t, r) { return hp(this.multi, []) } function Mk(e, n, t, r) { const o = this.multi; let i; if (this.providerFactory) { const s = this.providerFactory.componentProviders, a = Vr(t, t[S], this.providerFactory.index, r); i = a.slice(0, s), hp(o, i); for (let c = s; c < a.length; c++)i.push(a[c]) } else i = [], hp(o, i); return i } function hp(e, n) { for (let t = 0; t < e.length; t++)n.push((0, e[t])()); return n } function Ee(e, n = []) { return t => { t.providersResolver = (r, o) => function bk(e, n, t) { const r = Z(); if (r.firstCreatePass) { const o = Jt(e); up(t, r.data, r.blueprint, o, !0), up(n, r.data, r.blueprint, o, !1) } }(r, o ? o(e) : e, n) } } let Sk = (() => { class e { constructor(t) { this._injector = t, this.cachedInjectors = new Map } getOrCreateStandaloneInjector(t) { if (!t.standalone) return null; if (!this.cachedInjectors.has(t)) { const r = Ad(0, t.type), o = r.length > 0 ? sl([r], this._injector, `Standalone[${t.type.name}]`) : null; this.cachedInjectors.set(t, o) } return this.cachedInjectors.get(t) } ngOnDestroy() { try { for (const t of this.cachedInjectors.values()) null !== t && t.destroy() } finally { this.cachedInjectors.clear() } } static { this.\u0275prov = N({ token: e, providedIn: "environment", factory: () => new e(x(lt)) }) } } return e })(); function Nn(e) { ht("NgStandalone"), e.getStandaloneInjector = n => n.get(Sk).getOrCreateStandaloneInjector(e) } function Ws(e, n) { const t = e[n]; return t === G ? void 0 : t } function Db(e, n, t, r, o, i, s, a) { const c = n + t; return function cl(e, n, t, r, o) { const i = Zr(e, n, t, r); return Re(e, n + 2, o) || i }(e, c, o, i, s) ? Mn(e, c + 3, a ? r.call(a, o, i, s) : r(o, i, s)) : Ws(e, c + 3) } function Xr(e, n) { const t = Z(); let r; const o = e + O; t.firstCreatePass ? (r = function Uk(e, n) { if (n) for (let t = n.length - 1; t >= 0; t--) { const r = n[t]; if (e === r.name) return r } }(n, t.pipeRegistry), t.data[o] = r, r.onDestroy && (t.destroyHooks ??= []).push(o, r.onDestroy)) : r = t.data[o]; const i = r.factory || (r.factory = Nr(r.type)), a = _t(M); try { const c = Cc(!1), l = i(); return Cc(c), function lp(e, n, t, r) { t >= e.data.length && (e.data[t] = null, e.blueprint[t] = null), n[t] = r }(t, C(), o, l), l } finally { _t(a) } } function Eb(e, n, t) { const r = e + O, o = C(), i = Pr(o, r); return Zs(o, r) ? function _b(e, n, t, r, o, i) { const s = n + t; return Re(e, s, o) ? Mn(e, s + 1, i ? r.call(i, o) : r(o)) : Ws(e, s + 1) }(o, ft(), n, i.transform, t, i) : i.transform(t) } function Ml(e, n, t, r) { const o = e + O, i = C(), s = Pr(i, o); return Zs(i, o) ? function Cb(e, n, t, r, o, i, s) { const a = n + t; return Zr(e, a, o, i) ? Mn(e, a + 2, s ? r.call(s, o, i) : r(o, i)) : Ws(e, a + 2) }(i, ft(), n, s.transform, t, r, s) : s.transform(t, r) } function pp(e, n, t, r, o) { const i = e + O, s = C(), a = Pr(s, i); return Zs(s, i) ? Db(s, ft(), n, a.transform, t, r, o, a) : a.transform(t, r, o) } function Zs(e, n) { return e[S].data[n].pure } let Bb = (() => { class e { log(t) { console.log(t) } warn(t) { console.warn(t) } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "platform" }) } } return e })(); const zb = new T(""); function Xs(e) { return !!e && "function" == typeof e.then } function qb(e) { return !!e && "function" == typeof e.subscribe } const bp = new T(""); let Wb = (() => { class e { constructor() { this.initialized = !1, this.done = !1, this.donePromise = new Promise((t, r) => { this.resolve = t, this.reject = r }), this.appInits = b(bp, { optional: !0 }) ?? [] } runInitializers() { if (this.initialized) return; const t = []; for (const o of this.appInits) { const i = o(); if (Xs(i)) t.push(i); else if (qb(i)) { const s = new Promise((a, c) => { i.subscribe({ complete: a, error: c }) }); t.push(s) } } const r = () => { this.done = !0, this.resolve() }; Promise.all(t).then(() => { r() }).catch(o => { this.reject(o) }), 0 === t.length && r(), this.initialized = !0 } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); const Ks = new T(""); let On = (() => { class e { constructor() { this._bootstrapListeners = [], this._runningTick = !1, this._destroyed = !1, this._destroyListeners = [], this._views = [], this.internalErrorHandler = b(CN), this.afterRenderManager = b(yD), this.zonelessEnabled = b(Ns), this.dirtyFlags = 0, this.deferredDirtyFlags = 0, this.externalTestViews = new Set, this.beforeRender = new It, this.afterTick = new It, this.componentTypes = [], this.components = [], this.isStable = b(cr).hasPendingTasks.pipe(K(t => !t)), this._injector = b(lt) } get allViews() { return [...this.externalTestViews.keys(), ...this._views] } get destroyed() { return this._destroyed } whenStable() { let t; return new Promise(r => { t = this.isStable.subscribe({ next: o => { o && r() } }) }).finally(() => { t.unsubscribe() }) } get injector() { return this._injector } bootstrap(t, r) { const o = t instanceof EC; if (!this._injector.get(Wb).done) throw !o && function sr(e) { const n = Y(e) || He(e) || Ke(e); return null !== n && n.standalone }(t), new w(405, !1); let s; s = o ? t : this._injector.get(tl).resolveComponentFactory(t), this.componentTypes.push(s.componentType); const a = function VL(e) { return e.isBoundToModule }(s) ? void 0 : this._injector.get(Wr), l = s.create(Je.NULL, [], r || s.selector, a), u = l.location.nativeElement, d = l.injector.get(zb, null); return d?.registerApplication(u), l.onDestroy(() => { this.detachView(l.hostView), Al(this.components, l), d?.unregisterApplication(u) }), this._loadComponent(l), l } tick() { this.zonelessEnabled || (this.dirtyFlags |= 1), this._tick() } _tick() { if (this._runningTick) throw new w(101, !1); const t = W(null); try { this._runningTick = !0, this.synchronize() } catch (r) { this.internalErrorHandler(r) } finally { this._runningTick = !1, W(t), this.afterTick.next() } } synchronize() { let t = null; this._injector.destroyed || (t = this._injector.get(wh, null, { optional: !0 })), this.dirtyFlags |= this.deferredDirtyFlags, this.deferredDirtyFlags = 0; let r = 0; for (; 0 !== this.dirtyFlags && r++ < 10;)this.synchronizeOnce(t) } synchronizeOnce(t) { if (this.dirtyFlags |= this.deferredDirtyFlags, this.deferredDirtyFlags = 0, 7 & this.dirtyFlags) { const r = !!(1 & this.dirtyFlags); this.dirtyFlags &= -8, this.dirtyFlags |= 8, this.beforeRender.next(r); for (let { _lView: o, notifyErrorHandler: i } of this._views) UL(o, i, r, this.zonelessEnabled); if (this.dirtyFlags &= -5, this.syncDirtyFlagsWithViews(), 7 & this.dirtyFlags) return } else t?.begin?.(), t?.end?.(); 8 & this.dirtyFlags && (this.dirtyFlags &= -9, this.afterRenderManager.execute()), this.syncDirtyFlagsWithViews() } syncDirtyFlagsWithViews() { this.allViews.some(({ _lView: t }) => fc(t)) ? this.dirtyFlags |= 2 : this.dirtyFlags &= -8 } attachView(t) { const r = t; this._views.push(r), r.attachToAppRef(this) } detachView(t) { const r = t; Al(this._views, r), r.detachFromAppRef() } _loadComponent(t) { this.attachView(t.hostView), this.tick(), this.components.push(t); const r = this._injector.get(Ks, []);[...this._bootstrapListeners, ...r].forEach(o => o(t)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(t => t()), this._views.slice().forEach(t => t.destroy()) } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(t) { return this._destroyListeners.push(t), () => Al(this._destroyListeners, t) } destroy() { if (this._destroyed) throw new w(406, !1); const t = this._injector; t.destroy && !t.destroyed && t.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); function Al(e, n) { const t = e.indexOf(n); t > -1 && e.splice(t, 1) } function UL(e, n, t, r) { (t || fc(e)) && Zc(e, n, t && !r ? 0 : 1) } class $L { constructor(n, t) { this.ngModuleFactory = n, this.componentFactories = t } } let Jb = (() => { class e { compileModuleSync(t) { return new Lh(t) } compileModuleAsync(t) { return Promise.resolve(this.compileModuleSync(t)) } compileModuleAndAllComponentsSync(t) { const r = this.compileModuleSync(t), i = Rt(nt(t).declarations).reduce((s, a) => { const c = Y(a); return c && s.push(new Rs(c)), s }, []); return new $L(r, i) } compileModuleAndAllComponentsAsync(t) { return Promise.resolve(this.compileModuleAndAllComponentsSync(t)) } clearCache() { } clearCacheFor(t) { } getModuleId(t) { } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(), zL = (() => { class e { constructor() { this.zone = b(ie), this.changeDetectionScheduler = b(qo), this.applicationRef = b(On) } initialize() { this._onMicrotaskEmptySubscription || (this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({ next: () => { this.changeDetectionScheduler.runningTick || this.zone.run(() => { this.applicationRef.tick() }) } })) } ngOnDestroy() { this._onMicrotaskEmptySubscription?.unsubscribe() } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); const qL = new T("", { factory: () => !1 }); function Ep({ ngZoneFactory: e, ignoreChangesOutsideZone: n, scheduleInRootZone: t }) { return e ??= () => new ie({ ...Mp(), scheduleInRootZone: t }), [{ provide: ie, useFactory: e }, { provide: pn, multi: !0, useFactory: () => { const r = b(zL, { optional: !0 }); return () => r.initialize() } }, { provide: pn, multi: !0, useFactory: () => { const r = b(ZL); return () => { r.initialize() } } }, !0 === n ? { provide: bC, useValue: !0 } : [], { provide: Dh, useValue: t ?? ly }] } function Mp(e) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: e?.eventCoalescing ?? !1, shouldCoalesceRunChangeDetection: e?.runCoalescing ?? !1 } } let ZL = (() => { class e { constructor() { this.subscription = new at, this.initialized = !1, this.zone = b(ie), this.pendingTasks = b(cr) } initialize() { if (this.initialized) return; this.initialized = !0; let t = null; !this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks && (t = this.pendingTasks.add()), this.zone.runOutsideAngular(() => { this.subscription.add(this.zone.onStable.subscribe(() => { ie.assertNotInAngularZone(), queueMicrotask(() => { null !== t && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks && (this.pendingTasks.remove(t), t = null) }) })) }), this.subscription.add(this.zone.onUnstable.subscribe(() => { ie.assertInAngularZone(), t ??= this.pendingTasks.add() })) } ngOnDestroy() { this.subscription.unsubscribe() } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(), ea = (() => { class e { constructor() { this.appRef = b(On), this.taskService = b(cr), this.ngZone = b(ie), this.zonelessEnabled = b(Ns), this.disableScheduling = b(bC, { optional: !0 }) ?? !1, this.zoneIsDefined = typeof Zone < "u" && !!Zone.root.run, this.schedulerTickApplyArgs = [{ data: { __scheduler_tick__: !0 } }], this.subscriptions = new at, this.angularZoneId = this.zoneIsDefined ? this.ngZone._inner?.get(Ic) : null, this.scheduleInRootZone = !this.zonelessEnabled && this.zoneIsDefined && (b(Dh, { optional: !0 }) ?? !1), this.cancelScheduledCallback = null, this.useMicrotaskScheduler = !1, this.runningTick = !1, this.pendingRenderTaskId = null, this.subscriptions.add(this.appRef.afterTick.subscribe(() => { this.runningTick || this.cleanup() })), this.subscriptions.add(this.ngZone.onUnstable.subscribe(() => { this.runningTick || this.cleanup() })), this.disableScheduling ||= !this.zonelessEnabled && (this.ngZone instanceof mf || !this.zoneIsDefined) } notify(t) { if (!this.zonelessEnabled && 5 === t) return; switch (t) { case 0: this.appRef.dirtyFlags |= 2; break; case 3: case 2: case 4: case 5: case 1: this.appRef.dirtyFlags |= 4; break; case 7: this.appRef.deferredDirtyFlags |= 8; break; default: this.appRef.dirtyFlags |= 8 }if (!this.shouldScheduleTick()) return; const r = this.useMicrotaskScheduler ? dy : uy; this.pendingRenderTaskId = this.taskService.add(), this.cancelScheduledCallback = this.scheduleInRootZone ? Zone.root.run(() => r(() => this.tick())) : this.ngZone.runOutsideAngular(() => r(() => this.tick())) } shouldScheduleTick() { return !(this.disableScheduling || null !== this.pendingRenderTaskId || this.runningTick || this.appRef._runningTick || !this.zonelessEnabled && this.zoneIsDefined && Zone.current.get(Ic + this.angularZoneId)) } tick() { if (this.runningTick || this.appRef.destroyed) return; !this.zonelessEnabled && 7 & this.appRef.dirtyFlags && (this.appRef.dirtyFlags |= 1); const t = this.taskService.add(); try { this.ngZone.run(() => { this.runningTick = !0, this.appRef._tick() }, void 0, this.schedulerTickApplyArgs) } catch (r) { throw this.taskService.remove(t), r } finally { this.cleanup() } this.useMicrotaskScheduler = !0, dy(() => { this.useMicrotaskScheduler = !1, this.taskService.remove(t) }) } ngOnDestroy() { this.subscriptions.unsubscribe(), this.cleanup() } cleanup() { if (this.runningTick = !1, this.cancelScheduledCallback?.(), this.cancelScheduledCallback = null, null !== this.pendingRenderTaskId) { const t = this.pendingRenderTaskId; this.pendingRenderTaskId = null, this.taskService.remove(t) } } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); const gr = new T("", { providedIn: "root", factory: () => b(gr, J.Optional | J.SkipSelf) || function QL() { return typeof $localize < "u" && $localize.locale || yl }() }), Ol = new T(""); function xl(e) { return !e.moduleRef } let mr = null; let ta = (() => { class e { static { this.__NG_ELEMENT_ID__ = i2 } } return e })(); function i2(e) { return function s2(e, n, t) { if (Rr(e) && !t) { const r = Nt(e.index, n); return new ws(r, r) } return 175 & e.type ? new ws(n[be], n) : null }(le(), C(), !(16 & ~e)) } class dE { constructor() { } supports(n) { return al(n) } create(n) { return new d2(n) } } const u2 = (e, n) => n; class d2 { constructor(n) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = n || u2 } forEachItem(n) { let t; for (t = this._itHead; null !== t; t = t._next)n(t) } forEachOperation(n) { let t = this._itHead, r = this._removalsHead, o = 0, i = null; for (; t || r;) { const s = !r || t && t.currentIndex < hE(r, o, i) ? t : r, a = hE(s, o, i), c = s.currentIndex; if (s === r) o--, r = r._nextRemoved; else if (t = t._next, null == s.previousIndex) o++; else { i || (i = []); const l = a - o, u = c - o; if (l != u) { for (let f = 0; f < l; f++) { const h = f < i.length ? i[f] : i[f] = 0, p = h + f; u <= p && p < l && (i[f] = h + 1) } i[s.previousIndex] = u - l } } a !== c && n(s, a, c) } } forEachPreviousItem(n) { let t; for (t = this._previousItHead; null !== t; t = t._nextPrevious)n(t) } forEachAddedItem(n) { let t; for (t = this._additionsHead; null !== t; t = t._nextAdded)n(t) } forEachMovedItem(n) { let t; for (t = this._movesHead; null !== t; t = t._nextMoved)n(t) } forEachRemovedItem(n) { let t; for (t = this._removalsHead; null !== t; t = t._nextRemoved)n(t) } forEachIdentityChange(n) { let t; for (t = this._identityChangesHead; null !== t; t = t._nextIdentityChange)n(t) } diff(n) { if (null == n && (n = []), !al(n)) throw new w(900, !1); return this.check(n) ? this : null } onDestroy() { } check(n) { this._reset(); let o, i, s, t = this._itHead, r = !1; if (Array.isArray(n)) { this.length = n.length; for (let a = 0; a < this.length; a++)i = n[a], s = this._trackByFn(a, i), null !== t && Object.is(t.trackById, s) ? (r && (t = this._verifyReinsertion(t, i, s, a)), Object.is(t.item, i) || this._addIdentityChange(t, i)) : (t = this._mismatch(t, i, s, a), r = !0), t = t._next } else o = 0, function OR(e, n) { if (Array.isArray(e)) for (let t = 0; t < e.length; t++)n(e[t]); else { const t = e[Symbol.iterator](); let r; for (; !(r = t.next()).done;)n(r.value) } }(n, a => { s = this._trackByFn(o, a), null !== t && Object.is(t.trackById, s) ? (r && (t = this._verifyReinsertion(t, a, s, o)), Object.is(t.item, a) || this._addIdentityChange(t, a)) : (t = this._mismatch(t, a, s, o), r = !0), t = t._next, o++ }), this.length = o; return this._truncate(t), this.collection = n, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let n; for (n = this._previousItHead = this._itHead; null !== n; n = n._next)n._nextPrevious = n._next; for (n = this._additionsHead; null !== n; n = n._nextAdded)n.previousIndex = n.currentIndex; for (this._additionsHead = this._additionsTail = null, n = this._movesHead; null !== n; n = n._nextMoved)n.previousIndex = n.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(n, t, r, o) { let i; return null === n ? i = this._itTail : (i = n._prev, this._remove(n)), null !== (n = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null)) ? (Object.is(n.item, t) || this._addIdentityChange(n, t), this._reinsertAfter(n, i, o)) : null !== (n = null === this._linkedRecords ? null : this._linkedRecords.get(r, o)) ? (Object.is(n.item, t) || this._addIdentityChange(n, t), this._moveAfter(n, i, o)) : n = this._addAfter(new f2(t, r), i, o), n } _verifyReinsertion(n, t, r, o) { let i = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null); return null !== i ? n = this._reinsertAfter(i, n._prev, o) : n.currentIndex != o && (n.currentIndex = o, this._addToMoves(n, o)), n } _truncate(n) { for (; null !== n;) { const t = n._next; this._addToRemovals(this._unlink(n)), n = t } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(n, t, r) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(n); const o = n._prevRemoved, i = n._nextRemoved; return null === o ? this._removalsHead = i : o._nextRemoved = i, null === i ? this._removalsTail = o : i._prevRemoved = o, this._insertAfter(n, t, r), this._addToMoves(n, r), n } _moveAfter(n, t, r) { return this._unlink(n), this._insertAfter(n, t, r), this._addToMoves(n, r), n } _addAfter(n, t, r) { return this._insertAfter(n, t, r), this._additionsTail = null === this._additionsTail ? this._additionsHead = n : this._additionsTail._nextAdded = n, n } _insertAfter(n, t, r) { const o = null === t ? this._itHead : t._next; return n._next = o, n._prev = t, null === o ? this._itTail = n : o._prev = n, null === t ? this._itHead = n : t._next = n, null === this._linkedRecords && (this._linkedRecords = new fE), this._linkedRecords.put(n), n.currentIndex = r, n } _remove(n) { return this._addToRemovals(this._unlink(n)) } _unlink(n) { null !== this._linkedRecords && this._linkedRecords.remove(n); const t = n._prev, r = n._next; return null === t ? this._itHead = r : t._next = r, null === r ? this._itTail = t : r._prev = t, n } _addToMoves(n, t) { return n.previousIndex === t || (this._movesTail = null === this._movesTail ? this._movesHead = n : this._movesTail._nextMoved = n), n } _addToRemovals(n) { return null === this._unlinkedRecords && (this._unlinkedRecords = new fE), this._unlinkedRecords.put(n), n.currentIndex = null, n._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = n, n._prevRemoved = null) : (n._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = n), n } _addIdentityChange(n, t) { return n.item = t, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = n : this._identityChangesTail._nextIdentityChange = n, n } } class f2 { constructor(n, t) { this.item = n, this.trackById = t, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class h2 { constructor() { this._head = null, this._tail = null } add(n) { null === this._head ? (this._head = this._tail = n, n._nextDup = null, n._prevDup = null) : (this._tail._nextDup = n, n._prevDup = this._tail, n._nextDup = null, this._tail = n) } get(n, t) { let r; for (r = this._head; null !== r; r = r._nextDup)if ((null === t || t <= r.currentIndex) && Object.is(r.trackById, n)) return r; return null } remove(n) { const t = n._prevDup, r = n._nextDup; return null === t ? this._head = r : t._nextDup = r, null === r ? this._tail = t : r._prevDup = t, null === this._head } } class fE { constructor() { this.map = new Map } put(n) { const t = n.trackById; let r = this.map.get(t); r || (r = new h2, this.map.set(t, r)), r.add(n) } get(n, t) { const o = this.map.get(n); return o ? o.get(n, t) : null } remove(n) { const t = n.trackById; return this.map.get(t).remove(n) && this.map.delete(t), n } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function hE(e, n, t) { const r = e.previousIndex; if (null === r) return r; let o = 0; return t && r < t.length && (o = t[r]), r + n + o } function gE() { return new xp([new dE]) } let xp = (() => { class e { static { this.\u0275prov = N({ token: e, providedIn: "root", factory: gE }) } constructor(t) { this.factories = t } static create(t, r) { if (null != r) { const o = r.factories.slice(); t = t.concat(o) } return new e(t) } static extend(t) { return { provide: e, useFactory: r => e.create(t, r || gE()), deps: [[e, new Xa, new Ja]] } } find(t) { const r = this.factories.find(o => o.supports(t)); if (null != r) return r; throw new w(901, !1) } } return e })(); function A2(e) { try { const { rootComponent: n, appProviders: t, platformProviders: r } = e, o = function o2(e = []) { if (mr) return mr; const n = function iE(e = [], n) { return Je.create({ name: n, providers: [{ provide: xd, useValue: "platform" }, { provide: Ol, useValue: new Set([() => mr = null]) }, ...e] }) }(e); return mr = n, function Zb() { !function zS(e) { wm = e }(() => { throw new w(600, !1) }) }(), function sE(e) { e.get(ky, null)?.forEach(t => t()) }(n), n }(r), i = [Ep({}), { provide: qo, useExisting: ea }, ...t || []]; return function nE(e) { const n = xl(e) ? e.r3Injector : e.moduleRef.injector, t = n.get(ie); return t.run(() => { xl(e) ? e.r3Injector.resolveInjectorInitializers() : e.moduleRef.resolveInjectorInitializers(); const r = n.get(wn, null); let o; if (t.runOutsideAngular(() => { o = t.onError.subscribe({ next: i => { r.handleError(i) } }) }), xl(e)) { const i = () => n.destroy(), s = e.platformInjector.get(Ol); s.add(i), n.onDestroy(() => { o.unsubscribe(), s.delete(i) }) } else { const i = () => e.moduleRef.destroy(), s = e.platformInjector.get(Ol); s.add(i), e.moduleRef.onDestroy(() => { Al(e.allPlatformModules, e.moduleRef), o.unsubscribe(), s.delete(i) }) } return function BL(e, n, t) { try { const r = t(); return Xs(r) ? r.catch(o => { throw n.runOutsideAngular(() => e.handleError(o)), o }) : r } catch (r) { throw n.runOutsideAngular(() => e.handleError(r)), r } }(r, t, () => { const i = n.get(Wb); return i.runInitializers(), i.donePromise.then(() => { if (function vF(e) { "string" == typeof e && (gw = e.toLowerCase().replace(/_/g, "-")) }(n.get(gr, yl) || yl), xl(e)) { const a = n.get(On); return void 0 !== e.rootComponent && a.bootstrap(e.rootComponent), a } return function t2(e, n) { const t = e.injector.get(On); if (e._bootstrapComponents.length > 0) e._bootstrapComponents.forEach(r => t.bootstrap(r)); else { if (!e.instance.ngDoBootstrap) throw new w(-403, !1); e.instance.ngDoBootstrap(t) } n.push(e) }(e.moduleRef, e.allPlatformModules), e.moduleRef }) }) }) }({ r3Injector: new uD({ providers: i, parent: o, debugName: "", runEnvironmentInitializers: !1 }).injector, platformInjector: o, rootComponent: n }) } catch (n) { return Promise.reject(n) } } function _i(e) { return "boolean" == typeof e ? e : null != e && "false" !== e } function ia(e, n) { ht("NgSignals"); const t = function $S(e) { const n = Object.create(HS); n.computation = e; const t = () => { if (gm(n), Zu(n), n.value === ja) throw n.error; return n.value }; return t[Wt] = n, t }(e); return n?.equal && (t[Wt].equal = n.equal), t } function xn(e) { const n = W(null); try { return e() } finally { W(n) } } let jE = null; function vr() { return jE } class rV { } const Et = new T(""); let Fp = (() => { class e { historyGo(t) { throw new Error("") } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: () => b(iV), providedIn: "platform" }) } } return e })(); const oV = new T(""); let iV = (() => { class e extends Fp { constructor() { super(), this._doc = b(Et), this._location = window.location, this._history = window.history } getBaseHrefFromDOM() { return vr().getBaseHref(this._doc) } onPopState(t) { const r = vr().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("popstate", t, !1), () => r.removeEventListener("popstate", t) } onHashChange(t) { const r = vr().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("hashchange", t, !1), () => r.removeEventListener("hashchange", t) } get href() { return this._location.href } get protocol() { return this._location.protocol } get hostname() { return this._location.hostname } get port() { return this._location.port } get pathname() { return this._location.pathname } get search() { return this._location.search } get hash() { return this._location.hash } set pathname(t) { this._location.pathname = t } pushState(t, r, o) { this._history.pushState(t, r, o) } replaceState(t, r, o) { this._history.replaceState(t, r, o) } forward() { this._history.forward() } back() { this._history.back() } historyGo(t = 0) { this._history.go(t) } getState() { return this._history.state } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: () => new e, providedIn: "platform" }) } } return e })(); function kp(e, n) { if (0 == e.length) return n; if (0 == n.length) return e; let t = 0; return e.endsWith("/") && t++, n.startsWith("/") && t++, 2 == t ? e + n.substring(1) : 1 == t ? e + n : e + "/" + n } function BE(e) { const n = e.match(/#|\?|$/), t = n && n.index || e.length; return e.slice(0, t - ("/" === e[t - 1] ? 1 : 0)) + e.slice(t) } function Yn(e) { return e && "?" !== e[0] ? "?" + e : e } let eo = (() => { class e { historyGo(t) { throw new Error("") } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: () => b($E), providedIn: "root" }) } } return e })(); const UE = new T(""); let $E = (() => { class e extends eo { constructor(t, r) { super(), this._platformLocation = t, this._removeListenerFns = [], this._baseHref = r ?? this._platformLocation.getBaseHrefFromDOM() ?? b(Et).location?.origin ?? "" } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(t) { this._removeListenerFns.push(this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t)) } getBaseHref() { return this._baseHref } prepareExternalUrl(t) { return kp(this._baseHref, t) } path(t = !1) { const r = this._platformLocation.pathname + Yn(this._platformLocation.search), o = this._platformLocation.hash; return o && t ? `${r}${o}` : r } pushState(t, r, o, i) { const s = this.prepareExternalUrl(o + Yn(i)); this._platformLocation.pushState(t, r, s) } replaceState(t, r, o, i) { const s = this.prepareExternalUrl(o + Yn(i)); this._platformLocation.replaceState(t, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(t = 0) { this._platformLocation.historyGo?.(t) } static { this.\u0275fac = function (r) { return new (r || e)(x(Fp), x(UE, 8)) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(), sV = (() => { class e extends eo { constructor(t, r) { super(), this._platformLocation = t, this._baseHref = "", this._removeListenerFns = [], null != r && (this._baseHref = r) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(t) { this._removeListenerFns.push(this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t)) } getBaseHref() { return this._baseHref } path(t = !1) { const r = this._platformLocation.hash ?? "#"; return r.length > 0 ? r.substring(1) : r } prepareExternalUrl(t) { const r = kp(this._baseHref, t); return r.length > 0 ? "#" + r : r } pushState(t, r, o, i) { let s = this.prepareExternalUrl(o + Yn(i)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(t, r, s) } replaceState(t, r, o, i) { let s = this.prepareExternalUrl(o + Yn(i)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(t, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(t = 0) { this._platformLocation.historyGo?.(t) } static { this.\u0275fac = function (r) { return new (r || e)(x(Fp), x(UE, 8)) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac }) } } return e })(), sa = (() => { class e { constructor(t) { this._subject = new Te, this._urlChangeListeners = [], this._urlChangeSubscription = null, this._locationStrategy = t; const r = this._locationStrategy.getBaseHref(); this._basePath = function lV(e) { if (new RegExp("^(https?:)?//").test(e)) { const [, t] = e.split(/\/\/[^\/]+/); return t } return e }(BE(HE(r))), this._locationStrategy.onPopState(o => { this._subject.emit({ url: this.path(!0), pop: !0, state: o.state, type: o.type }) }) } ngOnDestroy() { this._urlChangeSubscription?.unsubscribe(), this._urlChangeListeners = [] } path(t = !1) { return this.normalize(this._locationStrategy.path(t)) } getState() { return this._locationStrategy.getState() } isCurrentPathEqualTo(t, r = "") { return this.path() == this.normalize(t + Yn(r)) } normalize(t) { return e.stripTrailingSlash(function cV(e, n) { if (!e || !n.startsWith(e)) return n; const t = n.substring(e.length); return "" === t || ["/", ";", "?", "#"].includes(t[0]) ? t : n }(this._basePath, HE(t))) } prepareExternalUrl(t) { return t && "/" !== t[0] && (t = "/" + t), this._locationStrategy.prepareExternalUrl(t) } go(t, r = "", o = null) { this._locationStrategy.pushState(o, "", t, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + Yn(r)), o) } replaceState(t, r = "", o = null) { this._locationStrategy.replaceState(o, "", t, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + Yn(r)), o) } forward() { this._locationStrategy.forward() } back() { this._locationStrategy.back() } historyGo(t = 0) { this._locationStrategy.historyGo?.(t) } onUrlChange(t) { return this._urlChangeListeners.push(t), this._urlChangeSubscription ??= this.subscribe(r => { this._notifyUrlChangeListeners(r.url, r.state) }), () => { const r = this._urlChangeListeners.indexOf(t); this._urlChangeListeners.splice(r, 1), 0 === this._urlChangeListeners.length && (this._urlChangeSubscription?.unsubscribe(), this._urlChangeSubscription = null) } } _notifyUrlChangeListeners(t = "", r) { this._urlChangeListeners.forEach(o => o(t, r)) } subscribe(t, r, o) { return this._subject.subscribe({ next: t, error: r, complete: o }) } static { this.normalizeQueryParams = Yn } static { this.joinWithSlash = kp } static { this.stripTrailingSlash = BE } static { this.\u0275fac = function (r) { return new (r || e)(x(eo)) } } static { this.\u0275prov = N({ token: e, factory: () => function aV() { return new sa(x(eo)) }(), providedIn: "root" }) } } return e })(); function HE(e) { return e.replace(/\/index.html$/, "") } var mt = function (e) { return e[e.Format = 0] = "Format", e[e.Standalone = 1] = "Standalone", e }(mt || {}), fe = function (e) { return e[e.Narrow = 0] = "Narrow", e[e.Abbreviated = 1] = "Abbreviated", e[e.Wide = 2] = "Wide", e[e.Short = 3] = "Short", e }(fe || {}), kt = function (e) { return e[e.Short = 0] = "Short", e[e.Medium = 1] = "Medium", e[e.Long = 2] = "Long", e[e.Full = 3] = "Full", e }(kt || {}); const je = { Decimal: 0, Group: 1, List: 2, PercentSign: 3, PlusSign: 4, MinusSign: 5, Exponential: 6, SuperscriptingExponent: 7, PerMille: 8, Infinity: 9, NaN: 10, TimeSeparator: 11, CurrencyDecimal: 12, CurrencyGroup: 13 }; function Hl(e, n) { return zt(pt(e)[ve.DateFormat], n) } function Gl(e, n) { return zt(pt(e)[ve.TimeFormat], n) } function zl(e, n) { return zt(pt(e)[ve.DateTimeFormat], n) } function Gt(e, n) { const t = pt(e), r = t[ve.NumberSymbols][n]; if (typeof r > "u") { if (n === je.CurrencyDecimal) return t[ve.NumberSymbols][je.Decimal]; if (n === je.CurrencyGroup) return t[ve.NumberSymbols][je.Group] } return r } function zE(e) { if (!e[ve.ExtraData]) throw new Error(`Missing extra locale data for the locale "${e[ve.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`) } function zt(e, n) { for (let t = n; t > -1; t--)if (typeof e[t] < "u") return e[t]; throw new Error("Locale data API: locale data undefined") } function Vp(e) { const [n, t] = e.split(":"); return { hours: +n, minutes: +t } } const bV = /^(\d{4,})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/, ql = {}, EV = /((?:[^BEGHLMOSWYZabcdhmswyz']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|c{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/; var Jn = function (e) { return e[e.Short = 0] = "Short", e[e.ShortGMT = 1] = "ShortGMT", e[e.Long = 2] = "Long", e[e.Extended = 3] = "Extended", e }(Jn || {}), se = function (e) { return e[e.FullYear = 0] = "FullYear", e[e.Month = 1] = "Month", e[e.Date = 2] = "Date", e[e.Hours = 3] = "Hours", e[e.Minutes = 4] = "Minutes", e[e.Seconds = 5] = "Seconds", e[e.FractionalSeconds = 6] = "FractionalSeconds", e[e.Day = 7] = "Day", e }(se || {}), ae = function (e) { return e[e.DayPeriods = 0] = "DayPeriods", e[e.Days = 1] = "Days", e[e.Months = 2] = "Months", e[e.Eras = 3] = "Eras", e }(ae || {}); function MV(e, n, t, r) { let o = function PV(e) { if (ZE(e)) return e; if ("number" == typeof e && !isNaN(e)) return new Date(e); if ("string" == typeof e) { if (e = e.trim(), /^(\d{4}(-\d{1,2}(-\d{1,2})?)?)$/.test(e)) { const [o, i = 1, s = 1] = e.split("-").map(a => +a); return Wl(o, i - 1, s) } const t = parseFloat(e); if (!isNaN(e - t)) return new Date(t); let r; if (r = e.match(bV)) return function FV(e) { const n = new Date(0); let t = 0, r = 0; const o = e[8] ? n.setUTCFullYear : n.setFullYear, i = e[8] ? n.setUTCHours : n.setHours; e[9] && (t = Number(e[9] + e[10]), r = Number(e[9] + e[11])), o.call(n, Number(e[1]), Number(e[2]) - 1, Number(e[3])); const s = Number(e[4] || 0) - t, a = Number(e[5] || 0) - r, c = Number(e[6] || 0), l = Math.floor(1e3 * parseFloat("0." + (e[7] || 0))); return i.call(n, s, a, c, l), n }(r) } const n = new Date(e); if (!ZE(n)) throw new Error(`Unable to convert "${e}" into a date`); return n }(e); n = Xn(t, n) || n; let a, s = []; for (; n;) { if (a = EV.exec(n), !a) { s.push(n); break } { s = s.concat(a.slice(1)); const u = s.pop(); if (!u) break; n = u } } let c = o.getTimezoneOffset(); r && (c = WE(r, c), o = function RV(e, n, t) { const r = t ? -1 : 1, o = e.getTimezoneOffset(); return function xV(e, n) { return (e = new Date(e.getTime())).setMinutes(e.getMinutes() + n), e }(e, r * (WE(n, o) - o)) }(o, r, !0)); let l = ""; return s.forEach(u => { const d = function OV(e) { if (Bp[e]) return Bp[e]; let n; switch (e) { case "G": case "GG": case "GGG": n = ye(ae.Eras, fe.Abbreviated); break; case "GGGG": n = ye(ae.Eras, fe.Wide); break; case "GGGGG": n = ye(ae.Eras, fe.Narrow); break; case "y": n = Be(se.FullYear, 1, 0, !1, !0); break; case "yy": n = Be(se.FullYear, 2, 0, !0, !0); break; case "yyy": n = Be(se.FullYear, 3, 0, !1, !0); break; case "yyyy": n = Be(se.FullYear, 4, 0, !1, !0); break; case "Y": n = Jl(1); break; case "YY": n = Jl(2, !0); break; case "YYY": n = Jl(3); break; case "YYYY": n = Jl(4); break; case "M": case "L": n = Be(se.Month, 1, 1); break; case "MM": case "LL": n = Be(se.Month, 2, 1); break; case "MMM": n = ye(ae.Months, fe.Abbreviated); break; case "MMMM": n = ye(ae.Months, fe.Wide); break; case "MMMMM": n = ye(ae.Months, fe.Narrow); break; case "LLL": n = ye(ae.Months, fe.Abbreviated, mt.Standalone); break; case "LLLL": n = ye(ae.Months, fe.Wide, mt.Standalone); break; case "LLLLL": n = ye(ae.Months, fe.Narrow, mt.Standalone); break; case "w": n = jp(1); break; case "ww": n = jp(2); break; case "W": n = jp(1, !0); break; case "d": n = Be(se.Date, 1); break; case "dd": n = Be(se.Date, 2); break; case "c": case "cc": n = Be(se.Day, 1); break; case "ccc": n = ye(ae.Days, fe.Abbreviated, mt.Standalone); break; case "cccc": n = ye(ae.Days, fe.Wide, mt.Standalone); break; case "ccccc": n = ye(ae.Days, fe.Narrow, mt.Standalone); break; case "cccccc": n = ye(ae.Days, fe.Short, mt.Standalone); break; case "E": case "EE": case "EEE": n = ye(ae.Days, fe.Abbreviated); break; case "EEEE": n = ye(ae.Days, fe.Wide); break; case "EEEEE": n = ye(ae.Days, fe.Narrow); break; case "EEEEEE": n = ye(ae.Days, fe.Short); break; case "a": case "aa": case "aaa": n = ye(ae.DayPeriods, fe.Abbreviated); break; case "aaaa": n = ye(ae.DayPeriods, fe.Wide); break; case "aaaaa": n = ye(ae.DayPeriods, fe.Narrow); break; case "b": case "bb": case "bbb": n = ye(ae.DayPeriods, fe.Abbreviated, mt.Standalone, !0); break; case "bbbb": n = ye(ae.DayPeriods, fe.Wide, mt.Standalone, !0); break; case "bbbbb": n = ye(ae.DayPeriods, fe.Narrow, mt.Standalone, !0); break; case "B": case "BB": case "BBB": n = ye(ae.DayPeriods, fe.Abbreviated, mt.Format, !0); break; case "BBBB": n = ye(ae.DayPeriods, fe.Wide, mt.Format, !0); break; case "BBBBB": n = ye(ae.DayPeriods, fe.Narrow, mt.Format, !0); break; case "h": n = Be(se.Hours, 1, -12); break; case "hh": n = Be(se.Hours, 2, -12); break; case "H": n = Be(se.Hours, 1); break; case "HH": n = Be(se.Hours, 2); break; case "m": n = Be(se.Minutes, 1); break; case "mm": n = Be(se.Minutes, 2); break; case "s": n = Be(se.Seconds, 1); break; case "ss": n = Be(se.Seconds, 2); break; case "S": n = Be(se.FractionalSeconds, 1); break; case "SS": n = Be(se.FractionalSeconds, 2); break; case "SSS": n = Be(se.FractionalSeconds, 3); break; case "Z": case "ZZ": case "ZZZ": n = Ql(Jn.Short); break; case "ZZZZZ": n = Ql(Jn.Extended); break; case "O": case "OO": case "OOO": case "z": case "zz": case "zzz": n = Ql(Jn.ShortGMT); break; case "OOOO": case "ZZZZ": case "zzzz": n = Ql(Jn.Long); break; default: return null }return Bp[e] = n, n }(u); l += d ? d(o, t, c) : "''" === u ? "'" : u.replace(/(^'|'$)/g, "").replace(/''/g, "'") }), l } function Wl(e, n, t) { const r = new Date(0); return r.setFullYear(e, n, t), r.setHours(0, 0, 0), r } function Xn(e, n) { const t = function dV(e) { return pt(e)[ve.LocaleId] }(e); if (ql[t] ??= {}, ql[t][n]) return ql[t][n]; let r = ""; switch (n) { case "shortDate": r = Hl(e, kt.Short); break; case "mediumDate": r = Hl(e, kt.Medium); break; case "longDate": r = Hl(e, kt.Long); break; case "fullDate": r = Hl(e, kt.Full); break; case "shortTime": r = Gl(e, kt.Short); break; case "mediumTime": r = Gl(e, kt.Medium); break; case "longTime": r = Gl(e, kt.Long); break; case "fullTime": r = Gl(e, kt.Full); break; case "short": const o = Xn(e, "shortTime"), i = Xn(e, "shortDate"); r = Zl(zl(e, kt.Short), [o, i]); break; case "medium": const s = Xn(e, "mediumTime"), a = Xn(e, "mediumDate"); r = Zl(zl(e, kt.Medium), [s, a]); break; case "long": const c = Xn(e, "longTime"), l = Xn(e, "longDate"); r = Zl(zl(e, kt.Long), [c, l]); break; case "full": const u = Xn(e, "fullTime"), d = Xn(e, "fullDate"); r = Zl(zl(e, kt.Full), [u, d]) }return r && (ql[t][n] = r), r } function Zl(e, n) { return n && (e = e.replace(/\{([^}]+)}/g, function (t, r) { return null != n && r in n ? n[r] : t })), e } function cn(e, n, t = "-", r, o) { let i = ""; (e < 0 || o && e <= 0) && (o ? e = 1 - e : (e = -e, i = t)); let s = String(e); for (; s.length < n;)s = "0" + s; return r && (s = s.slice(s.length - n)), i + s } function Be(e, n, t = 0, r = !1, o = !1) { return function (i, s) { let a = function SV(e, n) { switch (e) { case se.FullYear: return n.getFullYear(); case se.Month: return n.getMonth(); case se.Date: return n.getDate(); case se.Hours: return n.getHours(); case se.Minutes: return n.getMinutes(); case se.Seconds: return n.getSeconds(); case se.FractionalSeconds: return n.getMilliseconds(); case se.Day: return n.getDay(); default: throw new Error(`Unknown DateType value "${e}".`) } }(e, i); if ((t > 0 || a > -t) && (a += t), e === se.Hours) 0 === a && -12 === t && (a = 12); else if (e === se.FractionalSeconds) return function IV(e, n) { return cn(e, 3).substring(0, n) }(a, n); const c = Gt(s, je.MinusSign); return cn(a, n, c, r, o) } } function ye(e, n, t = mt.Format, r = !1) { return function (o, i) { return function TV(e, n, t, r, o, i) { switch (t) { case ae.Months: return function pV(e, n, t) { const r = pt(e), i = zt([r[ve.MonthsFormat], r[ve.MonthsStandalone]], n); return zt(i, t) }(n, o, r)[e.getMonth()]; case ae.Days: return function hV(e, n, t) { const r = pt(e), i = zt([r[ve.DaysFormat], r[ve.DaysStandalone]], n); return zt(i, t) }(n, o, r)[e.getDay()]; case ae.DayPeriods: const s = e.getHours(), a = e.getMinutes(); if (i) { const l = function yV(e) { const n = pt(e); return zE(n), (n[ve.ExtraData][2] || []).map(r => "string" == typeof r ? Vp(r) : [Vp(r[0]), Vp(r[1])]) }(n), u = function _V(e, n, t) { const r = pt(e); zE(r); const i = zt([r[ve.ExtraData][0], r[ve.ExtraData][1]], n) || []; return zt(i, t) || [] }(n, o, r), d = l.findIndex(f => { if (Array.isArray(f)) { const [h, p] = f, g = s >= h.hours && a >= h.minutes, v = s < p.hours || s === p.hours && a < p.minutes; if (h.hours < p.hours) { if (g && v) return !0 } else if (g || v) return !0 } else if (f.hours === s && f.minutes === a) return !0; return !1 }); if (-1 !== d) return u[d] } return function fV(e, n, t) { const r = pt(e), i = zt([r[ve.DayPeriodsFormat], r[ve.DayPeriodsStandalone]], n); return zt(i, t) }(n, o, r)[s < 12 ? 0 : 1]; case ae.Eras: return function gV(e, n) { return zt(pt(e)[ve.Eras], n) }(n, r)[e.getFullYear() <= 0 ? 0 : 1]; default: throw new Error(`unexpected translation type ${t}`) } }(o, i, e, n, t, r) } } function Ql(e) { return function (n, t, r) { const o = -1 * r, i = Gt(t, je.MinusSign), s = o > 0 ? Math.floor(o / 60) : Math.ceil(o / 60); switch (e) { case Jn.Short: return (o >= 0 ? "+" : "") + cn(s, 2, i) + cn(Math.abs(o % 60), 2, i); case Jn.ShortGMT: return "GMT" + (o >= 0 ? "+" : "") + cn(s, 1, i); case Jn.Long: return "GMT" + (o >= 0 ? "+" : "") + cn(s, 2, i) + ":" + cn(Math.abs(o % 60), 2, i); case Jn.Extended: return 0 === r ? "Z" : (o >= 0 ? "+" : "") + cn(s, 2, i) + ":" + cn(Math.abs(o % 60), 2, i); default: throw new Error(`Unknown zone width "${e}"`) } } } const AV = 0, Yl = 4; function qE(e) { const n = e.getDay(), t = 0 === n ? -3 : Yl - n; return Wl(e.getFullYear(), e.getMonth(), e.getDate() + t) } function jp(e, n = !1) { return function (t, r) { let o; if (n) { const i = new Date(t.getFullYear(), t.getMonth(), 1).getDay() - 1, s = t.getDate(); o = 1 + Math.floor((s + i) / 7) } else { const i = qE(t), s = function NV(e) { const n = Wl(e, AV, 1).getDay(); return Wl(e, 0, 1 + (n <= Yl ? Yl : Yl + 7) - n) }(i.getFullYear()), a = i.getTime() - s.getTime(); o = 1 + Math.round(a / 6048e5) } return cn(o, e, Gt(r, je.MinusSign)) } } function Jl(e, n = !1) { return function (t, r) { return cn(qE(t).getFullYear(), e, Gt(r, je.MinusSign), n) } } const Bp = {}; function WE(e, n) { e = e.replace(/:/g, ""); const t = Date.parse("Jan 01, 1970 00:00:00 " + e) / 6e4; return isNaN(t) ? n : t } function ZE(e) { return e instanceof Date && !isNaN(e.valueOf()) } function XE(e, n) { n = encodeURIComponent(n); for (const t of e.split(";")) { const r = t.indexOf("="), [o, i] = -1 == r ? [t, ""] : [t.slice(0, r), t.slice(r + 1)]; if (o.trim() === n) return decodeURIComponent(i) } return null } class QV { constructor(n, t, r, o) { this.$implicit = n, this.ngForOf = t, this.index = r, this.count = o } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let ca = (() => { class e { set ngForOf(t) { this._ngForOf = t, this._ngForOfDirty = !0 } set ngForTrackBy(t) { this._trackByFn = t } get ngForTrackBy() { return this._trackByFn } constructor(t, r, o) { this._viewContainer = t, this._template = r, this._differs = o, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForTemplate(t) { t && (this._template = t) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const t = this._ngForOf; !this._differ && t && (this._differ = this._differs.find(t).create(this.ngForTrackBy)) } if (this._differ) { const t = this._differ.diff(this._ngForOf); t && this._applyChanges(t) } } _applyChanges(t) { const r = this._viewContainer; t.forEachOperation((o, i, s) => { if (null == o.previousIndex) r.createEmbeddedView(this._template, new QV(o.item, this._ngForOf, -1, -1), null === s ? void 0 : s); else if (null == s) r.remove(null === i ? void 0 : i); else if (null !== i) { const a = r.get(i); r.move(a, s), tM(a, o) } }); for (let o = 0, i = r.length; o < i; o++) { const a = r.get(o).context; a.index = o, a.count = i, a.ngForOf = this._ngForOf } t.forEachIdentityChange(o => { tM(r.get(o.currentIndex), o) }) } static ngTemplateContextGuard(t, r) { return !0 } static { this.\u0275fac = function (r) { return new (r || e)(M(tn), M(Zn), M(xp)) } } static { this.\u0275dir = $({ type: e, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" }, standalone: !0 }) } } return e })(); function tM(e, n) { e.context.$implicit = n.item } let Di = (() => { class e { constructor(t, r) { this._viewContainer = t, this._context = new YV, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = r } set ngIf(t) { this._context.$implicit = this._context.ngIf = t, this._updateView() } set ngIfThen(t) { nM("ngIfThen", t), this._thenTemplateRef = t, this._thenViewRef = null, this._updateView() } set ngIfElse(t) { nM("ngIfElse", t), this._elseTemplateRef = t, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(t, r) { return !0 } static { this.\u0275fac = function (r) { return new (r || e)(M(tn), M(Zn)) } } static { this.\u0275dir = $({ type: e, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" }, standalone: !0 }) } } return e })(); class YV { constructor() { this.$implicit = null, this.ngIf = null } } function nM(e, n) { if (n && !n.createEmbeddedView) throw new Error(`${e} must be a TemplateRef, but received '${$e(n)}'.`) } function ln(e, n) { return new w(2100, !1) } const lj = new T(""), uj = new T(""); let Kl = (() => { class e { constructor(t, r, o) { this.locale = t, this.defaultTimezone = r, this.defaultOptions = o } transform(t, r, o, i) { if (null == t || "" === t || t != t) return null; try { return MV(t, r ?? this.defaultOptions?.dateFormat ?? "mediumDate", i || this.locale, o ?? this.defaultOptions?.timezone ?? this.defaultTimezone ?? void 0) } catch (s) { throw ln() } } static { this.\u0275fac = function (r) { return new (r || e)(M(gr, 16), M(lj, 24), M(uj, 24)) } } static { this.\u0275pipe = ct({ name: "date", type: e, pure: !0, standalone: !0 }) } } return e })(), Jp = (() => { class e { transform(t, r, o) { if (null == t) return null; if (!this.supports(t)) throw ln(); return t.slice(r, o) } supports(t) { return "string" == typeof t || Array.isArray(t) } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275pipe = ct({ name: "slice", type: e, pure: !1, standalone: !0 }) } } return e })(), wi = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275mod = bo({ type: e }) } static { this.\u0275inj = Ar({}) } } return e })(); const iM = "browser"; function sM(e) { return "server" === e } let wj = (() => { class e { static { this.\u0275prov = N({ token: e, providedIn: "root", factory: () => function Dj(e) { return e === iM }(b(zn)) ? new bj(b(Et), window) : new Mj }) } } return e })(); class bj { constructor(n, t) { this.document = n, this.window = t, this.offset = () => [0, 0] } setOffset(n) { this.offset = Array.isArray(n) ? () => n : n } getScrollPosition() { return [this.window.scrollX, this.window.scrollY] } scrollToPosition(n) { this.window.scrollTo(n[0], n[1]) } scrollToAnchor(n) { const t = function Ej(e, n) { const t = e.getElementById(n) || e.getElementsByName(n)[0]; if (t) return t; if ("function" == typeof e.createTreeWalker && e.body && "function" == typeof e.body.attachShadow) { const r = e.createTreeWalker(e.body, NodeFilter.SHOW_ELEMENT); let o = r.currentNode; for (; o;) { const i = o.shadowRoot; if (i) { const s = i.getElementById(n) || i.querySelector(`[name="${n}"]`); if (s) return s } o = r.nextNode() } } return null }(this.document, n); t && (this.scrollToElement(t), t.focus()) } setHistoryScrollRestoration(n) { this.window.history.scrollRestoration = n } scrollToElement(n) { const t = n.getBoundingClientRect(), r = t.left + this.window.pageXOffset, o = t.top + this.window.pageYOffset, i = this.offset(); this.window.scrollTo(r - i[0], o - i[1]) } } class Mj { setOffset(n) { } getScrollPosition() { return [0, 0] } scrollToPosition(n) { } scrollToAnchor(n) { } setHistoryScrollRestoration(n) { } } class aM { } class Kj extends rV { constructor() { super(...arguments), this.supportsDOMEvents = !0 } } class tg extends Kj { static makeCurrent() { !function nV(e) { jE ??= e }(new tg) } onAndCancel(n, t, r) { return n.addEventListener(t, r), () => { n.removeEventListener(t, r) } } dispatchEvent(n, t) { n.dispatchEvent(t) } remove(n) { n.remove() } createElement(n, t) { return (t = t || this.getDefaultDocument()).createElement(n) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(n) { return n.nodeType === Node.ELEMENT_NODE } isShadowRoot(n) { return n instanceof DocumentFragment } getGlobalEventTarget(n, t) { return "window" === t ? window : "document" === t ? n : "body" === t ? n.body : null } getBaseHref(n) { const t = function eB() { return da = da || document.querySelector("base"), da ? da.getAttribute("href") : null }(); return null == t ? null : function tB(e) { return new URL(e, document.baseURI).pathname }(t) } resetBaseElement() { da = null } getUserAgent() { return window.navigator.userAgent } getCookie(n) { return XE(document.cookie, n) } } let da = null, rB = (() => { class e { build() { return new XMLHttpRequest } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac }) } } return e })(); const ng = new T(""); let yM = (() => { class e { constructor(t, r) { this._zone = r, this._eventNameToPlugin = new Map, t.forEach(o => { o.manager = this }), this._plugins = t.slice().reverse() } addEventListener(t, r, o) { return this._findPluginFor(r).addEventListener(t, r, o) } getZone() { return this._zone } _findPluginFor(t) { let r = this._eventNameToPlugin.get(t); if (r) return r; if (r = this._plugins.find(i => i.supports(t)), !r) throw new w(5101, !1); return this._eventNameToPlugin.set(t, r), r } static { this.\u0275fac = function (r) { return new (r || e)(x(ng), x(ie)) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac }) } } return e })(); class _M { constructor(n) { this._doc = n } } const rg = "ng-app-id"; let CM = (() => { class e { constructor(t, r, o, i = {}) { this.doc = t, this.appId = r, this.nonce = o, this.platformId = i, this.styleRef = new Map, this.hostNodes = new Set, this.styleNodesInDOM = this.collectServerRenderedStyles(), this.platformIsServer = sM(i), this.resetHostNodes() } addStyles(t) { for (const r of t) 1 === this.changeUsageCount(r, 1) && this.onStyleAdded(r) } removeStyles(t) { for (const r of t) this.changeUsageCount(r, -1) <= 0 && this.onStyleRemoved(r) } ngOnDestroy() { const t = this.styleNodesInDOM; t && (t.forEach(r => r.remove()), t.clear()); for (const r of this.getAllStyles()) this.onStyleRemoved(r); this.resetHostNodes() } addHost(t) { this.hostNodes.add(t); for (const r of this.getAllStyles()) this.addStyleToHost(t, r) } removeHost(t) { this.hostNodes.delete(t) } getAllStyles() { return this.styleRef.keys() } onStyleAdded(t) { for (const r of this.hostNodes) this.addStyleToHost(r, t) } onStyleRemoved(t) { const r = this.styleRef; r.get(t)?.elements?.forEach(o => o.remove()), r.delete(t) } collectServerRenderedStyles() { const t = this.doc.head?.querySelectorAll(`style[${rg}="${this.appId}"]`); if (t?.length) { const r = new Map; return t.forEach(o => { null != o.textContent && r.set(o.textContent, o) }), r } return null } changeUsageCount(t, r) { const o = this.styleRef; if (o.has(t)) { const i = o.get(t); return i.usage += r, i.usage } return o.set(t, { usage: r, elements: [] }), r } getStyleElement(t, r) { const o = this.styleNodesInDOM, i = o?.get(r); if (i?.parentNode === t) return o.delete(r), i.removeAttribute(rg), i; { const s = this.doc.createElement("style"); return this.nonce && s.setAttribute("nonce", this.nonce), s.textContent = r, this.platformIsServer && s.setAttribute(rg, this.appId), t.appendChild(s), s } } addStyleToHost(t, r) { const o = this.getStyleElement(t, r), i = this.styleRef, s = i.get(r)?.elements; s ? s.push(o) : i.set(r, { elements: [o], usage: 1 }) } resetHostNodes() { const t = this.hostNodes; t.clear(), t.add(this.doc.head) } static { this.\u0275fac = function (r) { return new (r || e)(x(Et), x(ls), x(Ly, 8), x(zn)) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac }) } } return e })(); const og = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/Math/MathML" }, ig = /%COMP%/g, aB = new T("", { providedIn: "root", factory: () => !0 }); function wM(e, n) { return n.map(t => t.replace(ig, e)) } let bM = (() => { class e { constructor(t, r, o, i, s, a, c, l = null) { this.eventManager = t, this.sharedStylesHost = r, this.appId = o, this.removeStylesOnCompDestroy = i, this.doc = s, this.platformId = a, this.ngZone = c, this.nonce = l, this.rendererByCompId = new Map, this.platformIsServer = sM(a), this.defaultRenderer = new sg(t, s, c, this.platformIsServer) } createRenderer(t, r) { if (!t || !r) return this.defaultRenderer; this.platformIsServer && r.encapsulation === Zt.ShadowDom && (r = { ...r, encapsulation: Zt.Emulated }); const o = this.getOrCreateRenderer(t, r); return o instanceof MM ? o.applyToHost(t) : o instanceof ag && o.applyStyles(), o } getOrCreateRenderer(t, r) { const o = this.rendererByCompId; let i = o.get(r.id); if (!i) { const s = this.doc, a = this.ngZone, c = this.eventManager, l = this.sharedStylesHost, u = this.removeStylesOnCompDestroy, d = this.platformIsServer; switch (r.encapsulation) { case Zt.Emulated: i = new MM(c, l, r, this.appId, u, s, a, d); break; case Zt.ShadowDom: return new dB(c, l, t, r, s, a, this.nonce, d); default: i = new ag(c, l, r, u, s, a, d) }o.set(r.id, i) } return i } ngOnDestroy() { this.rendererByCompId.clear() } static { this.\u0275fac = function (r) { return new (r || e)(x(yM), x(CM), x(ls), x(aB), x(Et), x(zn), x(ie), x(Ly)) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac }) } } return e })(); class sg { constructor(n, t, r, o) { this.eventManager = n, this.doc = t, this.ngZone = r, this.platformIsServer = o, this.data = Object.create(null), this.throwOnSyntheticProps = !0, this.destroyNode = null } destroy() { } createElement(n, t) { return t ? this.doc.createElementNS(og[t] || t, n) : this.doc.createElement(n) } createComment(n) { return this.doc.createComment(n) } createText(n) { return this.doc.createTextNode(n) } appendChild(n, t) { (EM(n) ? n.content : n).appendChild(t) } insertBefore(n, t, r) { n && (EM(n) ? n.content : n).insertBefore(t, r) } removeChild(n, t) { t.remove() } selectRootElement(n, t) { let r = "string" == typeof n ? this.doc.querySelector(n) : n; if (!r) throw new w(-5104, !1); return t || (r.textContent = ""), r } parentNode(n) { return n.parentNode } nextSibling(n) { return n.nextSibling } setAttribute(n, t, r, o) { if (o) { t = o + ":" + t; const i = og[o]; i ? n.setAttributeNS(i, t, r) : n.setAttribute(t, r) } else n.setAttribute(t, r) } removeAttribute(n, t, r) { if (r) { const o = og[r]; o ? n.removeAttributeNS(o, t) : n.removeAttribute(`${r}:${t}`) } else n.removeAttribute(t) } addClass(n, t) { n.classList.add(t) } removeClass(n, t) { n.classList.remove(t) } setStyle(n, t, r, o) { o & (ur.DashCase | ur.Important) ? n.style.setProperty(t, r, o & ur.Important ? "important" : "") : n.style[t] = r } removeStyle(n, t, r) { r & ur.DashCase ? n.style.removeProperty(t) : n.style[t] = "" } setProperty(n, t, r) { null != n && (n[t] = r) } setValue(n, t) { n.nodeValue = t } listen(n, t, r) { if ("string" == typeof n && !(n = vr().getGlobalEventTarget(this.doc, n))) throw new Error(`Unsupported event target ${n} for event ${t}`); return this.eventManager.addEventListener(n, t, this.decoratePreventDefault(r)) } decoratePreventDefault(n) { return t => { if ("__ngUnwrap__" === t) return n; !1 === (this.platformIsServer ? this.ngZone.runGuarded(() => n(t)) : n(t)) && t.preventDefault() } } } function EM(e) { return "TEMPLATE" === e.tagName && void 0 !== e.content } class dB extends sg { constructor(n, t, r, o, i, s, a, c) { super(n, i, s, c), this.sharedStylesHost = t, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const l = wM(o.id, o.styles); for (const u of l) { const d = document.createElement("style"); a && d.setAttribute("nonce", a), d.textContent = u, this.shadowRoot.appendChild(d) } } nodeOrShadowRoot(n) { return n === this.hostEl ? this.shadowRoot : n } appendChild(n, t) { return super.appendChild(this.nodeOrShadowRoot(n), t) } insertBefore(n, t, r) { return super.insertBefore(this.nodeOrShadowRoot(n), t, r) } removeChild(n, t) { return super.removeChild(null, t) } parentNode(n) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(n))) } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } } class ag extends sg { constructor(n, t, r, o, i, s, a, c) { super(n, i, s, a), this.sharedStylesHost = t, this.removeStylesOnCompDestroy = o, this.styles = c ? wM(c, r.styles) : r.styles } applyStyles() { this.sharedStylesHost.addStyles(this.styles) } destroy() { this.removeStylesOnCompDestroy && this.sharedStylesHost.removeStyles(this.styles) } } class MM extends ag { constructor(n, t, r, o, i, s, a, c) { const l = o + "-" + r.id; super(n, t, r, i, s, a, c, l), this.contentAttr = function cB(e) { return "_ngcontent-%COMP%".replace(ig, e) }(l), this.hostAttr = function lB(e) { return "_nghost-%COMP%".replace(ig, e) }(l) } applyToHost(n) { this.applyStyles(), this.setAttribute(n, this.hostAttr, "") } createElement(n, t) { const r = super.createElement(n, t); return super.setAttribute(r, this.contentAttr, ""), r } } const IM = ["alt", "control", "meta", "shift"], hB = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, pB = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }; function SM(e) { return { appProviders: [...wB, ...e?.providers ?? []], platformProviders: CB } } const CB = [{ provide: zn, useValue: iM }, { provide: ky, useValue: function vB() { tg.makeCurrent() }, multi: !0 }, { provide: Et, useFactory: function _B() { return function $N(e) { wf = e }(document), document }, deps: [] }], wB = [{ provide: xd, useValue: "root" }, { provide: wn, useFactory: function yB() { return new wn }, deps: [] }, { provide: ng, useClass: (() => { class e extends _M { constructor(t) { super(t) } supports(t) { return !0 } addEventListener(t, r, o) { return t.addEventListener(r, o, !1), () => this.removeEventListener(t, r, o) } removeEventListener(t, r, o) { return t.removeEventListener(r, o) } static { this.\u0275fac = function (r) { return new (r || e)(x(Et)) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac }) } } return e })(), multi: !0, deps: [Et, ie, zn] }, { provide: ng, useClass: (() => { class e extends _M { constructor(t) { super(t) } supports(t) { return null != e.parseEventName(t) } addEventListener(t, r, o) { const i = e.parseEventName(r), s = e.eventCallback(i.fullKey, o, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => vr().onAndCancel(t, i.domEventName, s)) } static parseEventName(t) { const r = t.toLowerCase().split("."), o = r.shift(); if (0 === r.length || "keydown" !== o && "keyup" !== o) return null; const i = e._normalizeKey(r.pop()); let s = "", a = r.indexOf("code"); if (a > -1 && (r.splice(a, 1), s = "code."), IM.forEach(l => { const u = r.indexOf(l); u > -1 && (r.splice(u, 1), s += l + ".") }), s += i, 0 != r.length || 0 === i.length) return null; const c = {}; return c.domEventName = o, c.fullKey = s, c } static matchEventFullKeyCode(t, r) { let o = hB[t.key] || t.key, i = ""; return r.indexOf("code.") > -1 && (o = t.code, i = "code."), !(null == o || !o) && (o = o.toLowerCase(), " " === o ? o = "space" : "." === o && (o = "dot"), IM.forEach(s => { s !== o && (0, pB[s])(t) && (i += s + ".") }), i += o, i === r) } static eventCallback(t, r, o) { return i => { e.matchEventFullKeyCode(i, t) && o.runGuarded(() => r(i)) } } static _normalizeKey(t) { return "esc" === t ? "escape" : t } static { this.\u0275fac = function (r) { return new (r || e)(x(Et)) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac }) } } return e })(), multi: !0, deps: [Et] }, bM, CM, yM, { provide: wh, useExisting: bM }, { provide: aM, useClass: rB, deps: [] }, []]; let TM = (() => { class e { constructor(t) { this._doc = t } getTitle() { return this._doc.title } setTitle(t) { this._doc.title = t || "" } static { this.\u0275fac = function (r) { return new (r || e)(x(Et)) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(), OM = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: function (r) { let o = null; return o = r ? new (r || e) : x(IB), o }, providedIn: "root" }) } } return e })(), IB = (() => { class e extends OM { constructor(t) { super(), this._doc = t } sanitize(t, r) { if (null == r) return null; switch (t) { case $t.NONE: return r; case $t.HTML: return bn(r, "HTML") ? xt(r) : s_(this._doc, String(r)).toString(); case $t.STYLE: return bn(r, "Style") ? xt(r) : r; case $t.SCRIPT: if (bn(r, "Script")) return xt(r); throw new w(5200, !1); case $t.URL: return bn(r, "URL") ? xt(r) : Lc(String(r)); case $t.RESOURCE_URL: if (bn(r, "ResourceURL")) return xt(r); throw new w(5201, !1); default: throw new w(5202, !1) } } bypassSecurityTrustHtml(t) { return function l1(e) { return new r1(e) }(t) } bypassSecurityTrustStyle(t) { return function u1(e) { return new o1(e) }(t) } bypassSecurityTrustScript(t) { return function d1(e) { return new i1(e) }(t) } bypassSecurityTrustUrl(t) { return function f1(e) { return new s1(e) }(t) } bypassSecurityTrustResourceUrl(t) { return function h1(e) { return new a1(e) }(t) } static { this.\u0275fac = function (r) { return new (r || e)(x(Et)) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); function yr(e) { return this instanceof yr ? (this.v = e, this) : new yr(e) } function FM(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var t, n = e[Symbol.asyncIterator]; return n ? n.call(e) : (e = function dg(e) { var n = "function" == typeof Symbol && Symbol.iterator, t = n && e[n], r = 0; if (t) return t.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(n ? "Object is not iterable." : "Symbol.iterator is not defined.") }(e), t = {}, r("next"), r("throw"), r("return"), t[Symbol.asyncIterator] = function () { return this }, t); function r(i) { t[i] = e[i] && function (s) { return new Promise(function (a, c) { !function o(i, s, a, c) { Promise.resolve(c).then(function (l) { i({ value: l, done: a }) }, s) }(a, c, (s = e[i](s)).done, s.value) }) } } } "function" == typeof SuppressedError && SuppressedError; const kM = e => e && "number" == typeof e.length && "function" != typeof e; function LM(e) { return _e(e?.then) } function VM(e) { return _e(e[ld]) } function jM(e) { return Symbol.asyncIterator && _e(e?.[Symbol.asyncIterator]) } function BM(e) { return new TypeError(`You provided ${null !== e && "object" == typeof e ? "an invalid object" : `'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const UM = function eU() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function $M(e) { return _e(e?.[UM]) } function HM(e) { return function PM(e, n, t) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var o, r = t.apply(e, n || []), i = []; return o = Object.create(("function" == typeof AsyncIterator ? AsyncIterator : Object).prototype), a("next"), a("throw"), a("return", function s(h) { return function (p) { return Promise.resolve(p).then(h, d) } }), o[Symbol.asyncIterator] = function () { return this }, o; function a(h, p) { r[h] && (o[h] = function (g) { return new Promise(function (v, D) { i.push([h, g, v, D]) > 1 || c(h, g) }) }, p && (o[h] = p(o[h]))) } function c(h, p) { try { !function l(h) { h.value instanceof yr ? Promise.resolve(h.value.v).then(u, d) : f(i[0][2], h) }(r[h](p)) } catch (g) { f(i[0][3], g) } } function u(h) { c("next", h) } function d(h) { c("throw", h) } function f(h, p) { h(p), i.shift(), i.length && c(i[0][0], i[0][1]) } }(this, arguments, function* () { const t = e.getReader(); try { for (; ;) { const { value: r, done: o } = yield yr(t.read()); if (o) return yield yr(void 0); yield yield yr(r) } } finally { t.releaseLock() } }) } function GM(e) { return _e(e?.getReader) } function Rn(e) { if (e instanceof ke) return e; if (null != e) { if (VM(e)) return function tU(e) { return new ke(n => { const t = e[ld](); if (_e(t.subscribe)) return t.subscribe(n); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(e); if (kM(e)) return function nU(e) { return new ke(n => { for (let t = 0; t < e.length && !n.closed; t++)n.next(e[t]); n.complete() }) }(e); if (LM(e)) return function rU(e) { return new ke(n => { e.then(t => { n.closed || (n.next(t), n.complete()) }, t => n.error(t)).then(null, Am) }) }(e); if (jM(e)) return zM(e); if ($M(e)) return function oU(e) { return new ke(n => { for (const t of e) if (n.next(t), n.closed) return; n.complete() }) }(e); if (GM(e)) return function iU(e) { return zM(HM(e)) }(e) } throw BM(e) } function zM(e) { return new ke(n => { (function sU(e, n) { var t, r, o, i; return function xM(e, n, t, r) { return new (t || (t = Promise))(function (i, s) { function a(u) { try { l(r.next(u)) } catch (d) { s(d) } } function c(u) { try { l(r.throw(u)) } catch (d) { s(d) } } function l(u) { u.done ? i(u.value) : function o(i) { return i instanceof t ? i : new t(function (s) { s(i) }) }(u.value).then(a, c) } l((r = r.apply(e, n || [])).next()) }) }(this, void 0, void 0, function* () { try { for (t = FM(e); !(r = yield t.next()).done;)if (n.next(r.value), n.closed) return } catch (s) { o = { error: s } } finally { try { r && !r.done && (i = t.return) && (yield i.call(t)) } finally { if (o) throw o.error } } n.complete() }) })(e, n).catch(t => n.error(t)) }) } function Kn(e, n, t, r = 0, o = !1) { const i = n.schedule(function () { t(), o ? e.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (e.add(i), !o) return i } function qM(e, n = 0) { return Xe((t, r) => { t.subscribe(Ue(r, o => Kn(r, e, () => r.next(o), n), () => Kn(r, e, () => r.complete(), n), o => Kn(r, e, () => r.error(o), n))) }) } function WM(e, n = 0) { return Xe((t, r) => { r.add(e.schedule(() => t.subscribe(r), n)) }) } function ZM(e, n) { if (!e) throw new Error("Iterable cannot be null"); return new ke(t => { Kn(t, n, () => { const r = e[Symbol.asyncIterator](); Kn(t, n, () => { r.next().then(o => { o.done ? t.complete() : t.next(o.value) }) }, 0, !0) }) }) } function Qe(e, n) { return n ? function fU(e, n) { if (null != e) { if (VM(e)) return function aU(e, n) { return Rn(e).pipe(WM(n), qM(n)) }(e, n); if (kM(e)) return function lU(e, n) { return new ke(t => { let r = 0; return n.schedule(function () { r === e.length ? t.complete() : (t.next(e[r++]), t.closed || this.schedule()) }) }) }(e, n); if (LM(e)) return function cU(e, n) { return Rn(e).pipe(WM(n), qM(n)) }(e, n); if (jM(e)) return ZM(e, n); if ($M(e)) return function uU(e, n) { return new ke(t => { let r; return Kn(t, n, () => { r = e[UM](), Kn(t, n, () => { let o, i; try { ({ value: o, done: i } = r.next()) } catch (s) { return void t.error(s) } i ? t.complete() : t.next(o) }, 0, !0) }), () => _e(r?.return) && r.return() }) }(e, n); if (GM(e)) return function dU(e, n) { return ZM(HM(e), n) }(e, n) } throw BM(e) }(e, n) : Rn(e) } function hg(e) { return e[e.length - 1] } function QM(e) { return _e(hg(e)) ? e.pop() : void 0 } function ou(e) { return function hU(e) { return e && _e(e.schedule) }(hg(e)) ? e.pop() : void 0 } function U(...e) { return Qe(e, ou(e)) } const { isArray: pU } = Array, { getPrototypeOf: gU, prototype: mU, keys: vU } = Object; function YM(e) { if (1 === e.length) { const n = e[0]; if (pU(n)) return { args: n, keys: null }; if (function yU(e) { return e && "object" == typeof e && gU(e) === mU }(n)) { const t = vU(n); return { args: t.map(r => n[r]), keys: t } } } return { args: e, keys: null } } const { isArray: _U } = Array; function JM(e) { return K(n => function CU(e, n) { return _U(n) ? e(...n) : e(n) }(e, n)) } function XM(e, n) { return e.reduce((t, r, o) => (t[r] = n[o], t), {}) } function pg(...e) { const n = ou(e), t = QM(e), { args: r, keys: o } = YM(e); if (0 === r.length) return Qe([], n); const i = new ke(function DU(e, n, t = Tr) { return r => { KM(n, () => { const { length: o } = e, i = new Array(o); let s = o, a = o; for (let c = 0; c < o; c++)KM(n, () => { const l = Qe(e[c], n); let u = !1; l.subscribe(Ue(r, d => { i[c] = d, u || (u = !0, a--), a || r.next(t(i.slice())) }, () => { --s || r.complete() })) }, r) }, r) } }(r, n, o ? s => XM(o, s) : Tr)); return t ? i.pipe(JM(t)) : i } function KM(e, n, t) { e ? Kn(t, e, n) : n() } const iu = ed(e => function () { e(this), this.name = "EmptyError", this.message = "no elements in sequence" }); function it(e, n, t = 1 / 0) { return _e(n) ? it((r, o) => K((i, s) => n(r, i, o, s))(Rn(e(r, o))), t) : ("number" == typeof n && (t = n), Xe((r, o) => function wU(e, n, t, r, o, i, s, a) { const c = []; let l = 0, u = 0, d = !1; const f = () => { d && !c.length && !l && n.complete() }, h = g => l < r ? p(g) : c.push(g), p = g => { i && n.next(g), l++; let v = !1; Rn(t(g, u++)).subscribe(Ue(n, D => { o?.(D), i ? h(D) : n.next(D) }, () => { v = !0 }, void 0, () => { if (v) try { for (l--; c.length && l < r;) { const D = c.shift(); s ? Kn(n, s, () => p(D)) : p(D) } f() } catch (D) { n.error(D) } })) }; return e.subscribe(Ue(n, h, () => { d = !0, f() })), () => { a?.() } }(r, o, e, t))) } function fa(e = 1 / 0) { return it(Tr, e) } function gg(...e) { return function bU() { return fa(1) }()(Qe(e, ou(e))) } function eI(e) { return new ke(n => { Rn(e()).subscribe(n) }) } function su(e, n) { const t = _e(e) ? e : () => e, r = o => o.error(t()); return new ke(n ? o => n.schedule(r, 0, o) : r) } const Pn = new ke(e => e.complete()); function mg() { return Xe((e, n) => { let t = null; e._refCount++; const r = Ue(n, void 0, void 0, void 0, () => { if (!e || e._refCount <= 0 || 0 < --e._refCount) return void (t = null); const o = e._connection, i = t; t = null, o && (!i || o === i) && o.unsubscribe(), n.unsubscribe() }); e.subscribe(r), r.closed || (t = e.connect()) }) } class tI extends ke { constructor(n, t) { super(), this.source = n, this.subjectFactory = t, this._subject = null, this._refCount = 0, this._connection = null, Rm(n) && (this.lift = n.lift) } _subscribe(n) { return this.getSubject().subscribe(n) } getSubject() { const n = this._subject; return (!n || n.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; const { _connection: n } = this; this._subject = this._connection = null, n?.unsubscribe() } connect() { let n = this._connection; if (!n) { n = this._connection = new at; const t = this.getSubject(); n.add(this.source.subscribe(Ue(t, void 0, () => { this._teardown(), t.complete() }, r => { this._teardown(), t.error(r) }, () => this._teardown()))), n.closed && (this._connection = null, n = at.EMPTY) } return n } refCount() { return mg()(this) } } function un(e, n) { return Xe((t, r) => { let o = null, i = 0, s = !1; const a = () => s && !o && r.complete(); t.subscribe(Ue(r, c => { o?.unsubscribe(); let l = 0; const u = i++; Rn(e(c, u)).subscribe(o = Ue(r, d => r.next(n ? n(c, d, u, l++) : d), () => { o = null, a() })) }, () => { s = !0, a() })) }) } function Ei(e) { return e <= 0 ? () => Pn : Xe((n, t) => { let r = 0; n.subscribe(Ue(t, o => { ++r <= e && (t.next(o), e <= r && t.complete()) })) }) } function er(e, n) { return Xe((t, r) => { let o = 0; t.subscribe(Ue(r, i => e.call(n, i, o++) && r.next(i))) }) } function au(e) { return Xe((n, t) => { let r = !1; n.subscribe(Ue(t, o => { r = !0, t.next(o) }, () => { r || t.next(e), t.complete() })) }) } function nI(e = IU) { return Xe((n, t) => { let r = !1; n.subscribe(Ue(t, o => { r = !0, t.next(o) }, () => r ? t.complete() : t.error(e()))) }) } function IU() { return new iu } function no(e, n) { const t = arguments.length >= 2; return r => r.pipe(e ? er((o, i) => e(o, i, r)) : Tr, Ei(1), t ? au(n) : nI(() => new iu)) } function Mi(e, n) { return _e(n) ? it(e, n, 1) : it(e, 1) } function vt(e, n, t) { const r = _e(e) || n || t ? { next: e, error: n, complete: t } : e; return r ? Xe((o, i) => { var s; null === (s = r.subscribe) || void 0 === s || s.call(r); let a = !0; o.subscribe(Ue(i, c => { var l; null === (l = r.next) || void 0 === l || l.call(r, c), i.next(c) }, () => { var c; a = !1, null === (c = r.complete) || void 0 === c || c.call(r), i.complete() }, c => { var l; a = !1, null === (l = r.error) || void 0 === l || l.call(r, c), i.error(c) }, () => { var c, l; a && (null === (c = r.unsubscribe) || void 0 === c || c.call(r)), null === (l = r.finalize) || void 0 === l || l.call(r) })) }) : Tr } function Ii(e) { return Xe((n, t) => { let i, r = null, o = !1; r = n.subscribe(Ue(t, void 0, void 0, s => { i = Rn(e(s, Ii(e)(n))), r ? (r.unsubscribe(), r = null, i.subscribe(t)) : o = !0 })), o && (r.unsubscribe(), r = null, i.subscribe(t)) }) } function vg(e) { return e <= 0 ? () => Pn : Xe((n, t) => { let r = []; n.subscribe(Ue(t, o => { r.push(o), e < r.length && r.shift() }, () => { for (const o of r) t.next(o); t.complete() }, void 0, () => { r = null })) }) } function cu(e) { return Xe((n, t) => { try { n.subscribe(t) } finally { t.add(e) } }) } const q = "primary", ha = Symbol("RouteTitle"); class xU { constructor(n) { this.params = n || {} } has(n) { return Object.prototype.hasOwnProperty.call(this.params, n) } get(n) { if (this.has(n)) { const t = this.params[n]; return Array.isArray(t) ? t[0] : t } return null } getAll(n) { if (this.has(n)) { const t = this.params[n]; return Array.isArray(t) ? t : [t] } return [] } get keys() { return Object.keys(this.params) } } function Si(e) { return new xU(e) } function RU(e, n, t) { const r = t.path.split("/"); if (r.length > e.length || "full" === t.pathMatch && (n.hasChildren() || r.length < e.length)) return null; const o = {}; for (let i = 0; i < r.length; i++) { const s = r[i], a = e[i]; if (":" === s[0]) o[s.substring(1)] = a; else if (s !== a.path) return null } return { consumed: e.slice(0, r.length), posParams: o } } function Fn(e, n) { const t = e ? yg(e) : void 0, r = n ? yg(n) : void 0; if (!t || !r || t.length != r.length) return !1; let o; for (let i = 0; i < t.length; i++)if (o = t[i], !rI(e[o], n[o])) return !1; return !0 } function yg(e) { return [...Object.keys(e), ...Object.getOwnPropertySymbols(e)] } function rI(e, n) { if (Array.isArray(e) && Array.isArray(n)) { if (e.length !== n.length) return !1; const t = [...e].sort(), r = [...n].sort(); return t.every((o, i) => r[i] === o) } return e === n } function oI(e) { return e.length > 0 ? e[e.length - 1] : null } function _r(e) { return function SB(e) { return !!e && (e instanceof ke || _e(e.lift) && _e(e.subscribe)) }(e) ? e : Xs(e) ? Qe(Promise.resolve(e)) : U(e) } const FU = { exact: function aI(e, n, t) { if (!oo(e.segments, n.segments) || !lu(e.segments, n.segments, t) || e.numberOfChildren !== n.numberOfChildren) return !1; for (const r in n.children) if (!e.children[r] || !aI(e.children[r], n.children[r], t)) return !1; return !0 }, subset: cI }, iI = { exact: function kU(e, n) { return Fn(e, n) }, subset: function LU(e, n) { return Object.keys(n).length <= Object.keys(e).length && Object.keys(n).every(t => rI(e[t], n[t])) }, ignored: () => !0 }; function sI(e, n, t) { return FU[t.paths](e.root, n.root, t.matrixParams) && iI[t.queryParams](e.queryParams, n.queryParams) && !("exact" === t.fragment && e.fragment !== n.fragment) } function cI(e, n, t) { return lI(e, n, n.segments, t) } function lI(e, n, t, r) { if (e.segments.length > t.length) { const o = e.segments.slice(0, t.length); return !(!oo(o, t) || n.hasChildren() || !lu(o, t, r)) } if (e.segments.length === t.length) { if (!oo(e.segments, t) || !lu(e.segments, t, r)) return !1; for (const o in n.children) if (!e.children[o] || !cI(e.children[o], n.children[o], r)) return !1; return !0 } { const o = t.slice(0, e.segments.length), i = t.slice(e.segments.length); return !!(oo(e.segments, o) && lu(e.segments, o, r) && e.children[q]) && lI(e.children[q], n, i, r) } } function lu(e, n, t) { return n.every((r, o) => iI[t](e[o].parameters, r.parameters)) } class ro { constructor(n = new de([], {}), t = {}, r = null) { this.root = n, this.queryParams = t, this.fragment = r } get queryParamMap() { return this._queryParamMap ??= Si(this.queryParams), this._queryParamMap } toString() { return BU.serialize(this) } } class de { constructor(n, t) { this.segments = n, this.children = t, this.parent = null, Object.values(t).forEach(r => r.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return du(this) } } class pa { constructor(n, t) { this.path = n, this.parameters = t } get parameterMap() { return this._parameterMap ??= Si(this.parameters), this._parameterMap } toString() { return fI(this) } } function oo(e, n) { return e.length === n.length && e.every((t, r) => t.path === n[r].path) } let Ti = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: () => new uu, providedIn: "root" }) } } return e })(); class uu { parse(n) { const t = new JU(n); return new ro(t.parseRootSegment(), t.parseQueryParams(), t.parseFragment()) } serialize(n) { const t = `/${ga(n.root, !0)}`, r = function HU(e) { const n = Object.entries(e).map(([t, r]) => Array.isArray(r) ? r.map(o => `${fu(t)}=${fu(o)}`).join("&") : `${fu(t)}=${fu(r)}`).filter(t => t); return n.length ? `?${n.join("&")}` : "" }(n.queryParams); return `${t}${r}${"string" == typeof n.fragment ? `#${function UU(e) { return encodeURI(e) }(n.fragment)}` : ""}` } } const BU = new uu; function du(e) { return e.segments.map(n => fI(n)).join("/") } function ga(e, n) { if (!e.hasChildren()) return du(e); if (n) { const t = e.children[q] ? ga(e.children[q], !1) : "", r = []; return Object.entries(e.children).forEach(([o, i]) => { o !== q && r.push(`${o}:${ga(i, !1)}`) }), r.length > 0 ? `${t}(${r.join("//")})` : t } { const t = function jU(e, n) { let t = []; return Object.entries(e.children).forEach(([r, o]) => { r === q && (t = t.concat(n(o, r))) }), Object.entries(e.children).forEach(([r, o]) => { r !== q && (t = t.concat(n(o, r))) }), t }(e, (r, o) => o === q ? [ga(e.children[q], !1)] : [`${o}:${ga(r, !1)}`]); return 1 === Object.keys(e.children).length && null != e.children[q] ? `${du(e)}/${t[0]}` : `${du(e)}/(${t.join("//")})` } } function uI(e) { return encodeURIComponent(e).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function fu(e) { return uI(e).replace(/%3B/gi, ";") } function _g(e) { return uI(e).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function hu(e) { return decodeURIComponent(e) } function dI(e) { return hu(e.replace(/\+/g, "%20")) } function fI(e) { return `${_g(e.path)}${function $U(e) { return Object.entries(e).map(([n, t]) => `;${_g(n)}=${_g(t)}`).join("") }(e.parameters)}` } const GU = /^[^\/()?;#]+/; function Cg(e) { const n = e.match(GU); return n ? n[0] : "" } const zU = /^[^\/()?;=#]+/, WU = /^[^=?&#]+/, QU = /^[^&#]+/; class JU { constructor(n) { this.url = n, this.remaining = n } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new de([], {}) : new de([], this.parseChildren()) } parseQueryParams() { const n = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(n) } while (this.consumeOptional("&")); return n } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const n = []; for (this.peekStartsWith("(") || n.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), n.push(this.parseSegment()); let t = {}; this.peekStartsWith("/(") && (this.capture("/"), t = this.parseParens(!0)); let r = {}; return this.peekStartsWith("(") && (r = this.parseParens(!1)), (n.length > 0 || Object.keys(t).length > 0) && (r[q] = new de(n, t)), r } parseSegment() { const n = Cg(this.remaining); if ("" === n && this.peekStartsWith(";")) throw new w(4009, !1); return this.capture(n), new pa(hu(n), this.parseMatrixParams()) } parseMatrixParams() { const n = {}; for (; this.consumeOptional(";");)this.parseParam(n); return n } parseParam(n) { const t = function qU(e) { const n = e.match(zU); return n ? n[0] : "" }(this.remaining); if (!t) return; this.capture(t); let r = ""; if (this.consumeOptional("=")) { const o = Cg(this.remaining); o && (r = o, this.capture(r)) } n[hu(t)] = hu(r) } parseQueryParam(n) { const t = function ZU(e) { const n = e.match(WU); return n ? n[0] : "" }(this.remaining); if (!t) return; this.capture(t); let r = ""; if (this.consumeOptional("=")) { const s = function YU(e) { const n = e.match(QU); return n ? n[0] : "" }(this.remaining); s && (r = s, this.capture(r)) } const o = dI(t), i = dI(r); if (n.hasOwnProperty(o)) { let s = n[o]; Array.isArray(s) || (s = [s], n[o] = s), s.push(i) } else n[o] = i } parseParens(n) { const t = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const r = Cg(this.remaining), o = this.remaining[r.length]; if ("/" !== o && ")" !== o && ";" !== o) throw new w(4010, !1); let i; r.indexOf(":") > -1 ? (i = r.slice(0, r.indexOf(":")), this.capture(i), this.capture(":")) : n && (i = q); const s = this.parseChildren(); t[i] = 1 === Object.keys(s).length ? s[q] : new de([], s), this.consumeOptional("//") } return t } peekStartsWith(n) { return this.remaining.startsWith(n) } consumeOptional(n) { return !!this.peekStartsWith(n) && (this.remaining = this.remaining.substring(n.length), !0) } capture(n) { if (!this.consumeOptional(n)) throw new w(4011, !1) } } function hI(e) { return e.segments.length > 0 ? new de([], { [q]: e }) : e } function pI(e) { const n = {}; for (const [r, o] of Object.entries(e.children)) { const i = pI(o); if (r === q && 0 === i.segments.length && i.hasChildren()) for (const [s, a] of Object.entries(i.children)) n[s] = a; else (i.segments.length > 0 || i.hasChildren()) && (n[r] = i) } return function XU(e) { if (1 === e.numberOfChildren && e.children[q]) { const n = e.children[q]; return new de(e.segments.concat(n.segments), n.children) } return e }(new de(e.segments, n)) } function io(e) { return e instanceof ro } function gI(e) { let n; const o = hI(function t(i) { const s = {}; for (const c of i.children) { const l = t(c); s[c.outlet] = l } const a = new de(i.url, s); return i === e && (n = a), a }(e.root)); return n ?? o } function mI(e, n, t, r) { let o = e; for (; o.parent;)o = o.parent; if (0 === n.length) return Dg(o, o, o, t, r); const i = function e$(e) { if ("string" == typeof e[0] && 1 === e.length && "/" === e[0]) return new yI(!0, 0, e); let n = 0, t = !1; const r = e.reduce((o, i, s) => { if ("object" == typeof i && null != i) { if (i.outlets) { const a = {}; return Object.entries(i.outlets).forEach(([c, l]) => { a[c] = "string" == typeof l ? l.split("/") : l }), [...o, { outlets: a }] } if (i.segmentPath) return [...o, i.segmentPath] } return "string" != typeof i ? [...o, i] : 0 === s ? (i.split("/").forEach((a, c) => { 0 == c && "." === a || (0 == c && "" === a ? t = !0 : ".." === a ? n++ : "" != a && o.push(a)) }), o) : [...o, i] }, []); return new yI(t, n, r) }(n); if (i.toRoot()) return Dg(o, o, new de([], {}), t, r); const s = function t$(e, n, t) { if (e.isAbsolute) return new gu(n, !0, 0); if (!t) return new gu(n, !1, NaN); if (null === t.parent) return new gu(t, !0, 0); const r = pu(e.commands[0]) ? 0 : 1; return function n$(e, n, t) { let r = e, o = n, i = t; for (; i > o;) { if (i -= o, r = r.parent, !r) throw new w(4005, !1); o = r.segments.length } return new gu(r, !1, o - i) }(t, t.segments.length - 1 + r, e.numberOfDoubleDots) }(i, o, e), a = s.processChildren ? va(s.segmentGroup, s.index, i.commands) : _I(s.segmentGroup, s.index, i.commands); return Dg(o, s.segmentGroup, a, t, r) } function pu(e) { return "object" == typeof e && null != e && !e.outlets && !e.segmentPath } function ma(e) { return "object" == typeof e && null != e && e.outlets } function Dg(e, n, t, r, o) { let s, i = {}; r && Object.entries(r).forEach(([c, l]) => { i[c] = Array.isArray(l) ? l.map(u => `${u}`) : `${l}` }), s = e === n ? t : vI(e, n, t); const a = hI(pI(s)); return new ro(a, i, o) } function vI(e, n, t) { const r = {}; return Object.entries(e.children).forEach(([o, i]) => { r[o] = i === n ? t : vI(i, n, t) }), new de(e.segments, r) } class yI { constructor(n, t, r) { if (this.isAbsolute = n, this.numberOfDoubleDots = t, this.commands = r, n && r.length > 0 && pu(r[0])) throw new w(4003, !1); const o = r.find(ma); if (o && o !== oI(r)) throw new w(4004, !1) } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class gu { constructor(n, t, r) { this.segmentGroup = n, this.processChildren = t, this.index = r } } function _I(e, n, t) { if (e ??= new de([], {}), 0 === e.segments.length && e.hasChildren()) return va(e, n, t); const r = function o$(e, n, t) { let r = 0, o = n; const i = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; o < e.segments.length;) { if (r >= t.length) return i; const s = e.segments[o], a = t[r]; if (ma(a)) break; const c = `${a}`, l = r < t.length - 1 ? t[r + 1] : null; if (o > 0 && void 0 === c) break; if (c && l && "object" == typeof l && void 0 === l.outlets) { if (!DI(c, l, s)) return i; r += 2 } else { if (!DI(c, {}, s)) return i; r++ } o++ } return { match: !0, pathIndex: o, commandIndex: r } }(e, n, t), o = t.slice(r.commandIndex); if (r.match && r.pathIndex < e.segments.length) { const i = new de(e.segments.slice(0, r.pathIndex), {}); return i.children[q] = new de(e.segments.slice(r.pathIndex), e.children), va(i, 0, o) } return r.match && 0 === o.length ? new de(e.segments, {}) : r.match && !e.hasChildren() ? wg(e, n, t) : r.match ? va(e, 0, o) : wg(e, n, t) } function va(e, n, t) { if (0 === t.length) return new de(e.segments, {}); { const r = function r$(e) { return ma(e[0]) ? e[0].outlets : { [q]: e } }(t), o = {}; if (Object.keys(r).some(i => i !== q) && e.children[q] && 1 === e.numberOfChildren && 0 === e.children[q].segments.length) { const i = va(e.children[q], n, t); return new de(e.segments, i.children) } return Object.entries(r).forEach(([i, s]) => { "string" == typeof s && (s = [s]), null !== s && (o[i] = _I(e.children[i], n, s)) }), Object.entries(e.children).forEach(([i, s]) => { void 0 === r[i] && (o[i] = s) }), new de(e.segments, o) } } function wg(e, n, t) { const r = e.segments.slice(0, n); let o = 0; for (; o < t.length;) { const i = t[o]; if (ma(i)) { const c = i$(i.outlets); return new de(r, c) } if (0 === o && pu(t[0])) { r.push(new pa(e.segments[n].path, CI(t[0]))), o++; continue } const s = ma(i) ? i.outlets[q] : `${i}`, a = o < t.length - 1 ? t[o + 1] : null; s && a && pu(a) ? (r.push(new pa(s, CI(a))), o += 2) : (r.push(new pa(s, {})), o++) } return new de(r, {}) } function i$(e) { const n = {}; return Object.entries(e).forEach(([t, r]) => { "string" == typeof r && (r = [r]), null !== r && (n[t] = wg(new de([], {}), 0, r)) }), n } function CI(e) { const n = {}; return Object.entries(e).forEach(([t, r]) => n[t] = `${r}`), n } function DI(e, n, t) { return e == t.path && Fn(n, t.parameters) } const ya = "imperative"; var X = function (e) { return e[e.NavigationStart = 0] = "NavigationStart", e[e.NavigationEnd = 1] = "NavigationEnd", e[e.NavigationCancel = 2] = "NavigationCancel", e[e.NavigationError = 3] = "NavigationError", e[e.RoutesRecognized = 4] = "RoutesRecognized", e[e.ResolveStart = 5] = "ResolveStart", e[e.ResolveEnd = 6] = "ResolveEnd", e[e.GuardsCheckStart = 7] = "GuardsCheckStart", e[e.GuardsCheckEnd = 8] = "GuardsCheckEnd", e[e.RouteConfigLoadStart = 9] = "RouteConfigLoadStart", e[e.RouteConfigLoadEnd = 10] = "RouteConfigLoadEnd", e[e.ChildActivationStart = 11] = "ChildActivationStart", e[e.ChildActivationEnd = 12] = "ChildActivationEnd", e[e.ActivationStart = 13] = "ActivationStart", e[e.ActivationEnd = 14] = "ActivationEnd", e[e.Scroll = 15] = "Scroll", e[e.NavigationSkipped = 16] = "NavigationSkipped", e }(X || {}); class kn { constructor(n, t) { this.id = n, this.url = t } } class mu extends kn { constructor(n, t, r = "imperative", o = null) { super(n, t), this.type = X.NavigationStart, this.navigationTrigger = r, this.restoredState = o } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class tr extends kn { constructor(n, t, r) { super(n, t), this.urlAfterRedirects = r, this.type = X.NavigationEnd } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } var Lt = function (e) { return e[e.Redirect = 0] = "Redirect", e[e.SupersededByNewNavigation = 1] = "SupersededByNewNavigation", e[e.NoDataFromResolver = 2] = "NoDataFromResolver", e[e.GuardRejected = 3] = "GuardRejected", e }(Lt || {}), vu = function (e) { return e[e.IgnoredSameUrlNavigation = 0] = "IgnoredSameUrlNavigation", e[e.IgnoredByUrlHandlingStrategy = 1] = "IgnoredByUrlHandlingStrategy", e }(vu || {}); class so extends kn { constructor(n, t, r, o) { super(n, t), this.reason = r, this.code = o, this.type = X.NavigationCancel } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class Ai extends kn { constructor(n, t, r, o) { super(n, t), this.reason = r, this.code = o, this.type = X.NavigationSkipped } } class bg extends kn { constructor(n, t, r, o) { super(n, t), this.error = r, this.target = o, this.type = X.NavigationError } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class wI extends kn { constructor(n, t, r, o) { super(n, t), this.urlAfterRedirects = r, this.state = o, this.type = X.RoutesRecognized } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class s$ extends kn { constructor(n, t, r, o) { super(n, t), this.urlAfterRedirects = r, this.state = o, this.type = X.GuardsCheckStart } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class a$ extends kn { constructor(n, t, r, o, i) { super(n, t), this.urlAfterRedirects = r, this.state = o, this.shouldActivate = i, this.type = X.GuardsCheckEnd } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class c$ extends kn { constructor(n, t, r, o) { super(n, t), this.urlAfterRedirects = r, this.state = o, this.type = X.ResolveStart } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class l$ extends kn { constructor(n, t, r, o) { super(n, t), this.urlAfterRedirects = r, this.state = o, this.type = X.ResolveEnd } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class u$ { constructor(n) { this.route = n, this.type = X.RouteConfigLoadStart } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class d$ { constructor(n) { this.route = n, this.type = X.RouteConfigLoadEnd } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class f$ { constructor(n) { this.snapshot = n, this.type = X.ChildActivationStart } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class h$ { constructor(n) { this.snapshot = n, this.type = X.ChildActivationEnd } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class p$ { constructor(n) { this.snapshot = n, this.type = X.ActivationStart } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class g$ { constructor(n) { this.snapshot = n, this.type = X.ActivationEnd } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class bI { constructor(n, t, r) { this.routerEvent = n, this.position = t, this.anchor = r, this.type = X.Scroll } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } class Eg { } class yu { constructor(n, t) { this.url = n, this.navigationBehaviorOptions = t } } function dn(e) { return e.outlet || q } function _a(e) { if (!e) return null; if (e.routeConfig?._injector) return e.routeConfig._injector; for (let n = e.parent; n; n = n.parent) { const t = n.routeConfig; if (t?._loadedInjector) return t._loadedInjector; if (t?._injector) return t._injector } return null } class D$ { get injector() { return _a(this.route?.snapshot) ?? this.rootInjector } set injector(n) { } constructor(n) { this.rootInjector = n, this.outlet = null, this.route = null, this.children = new Ca(this.rootInjector), this.attachRef = null } } let Ca = (() => { class e { constructor(t) { this.rootInjector = t, this.contexts = new Map } onChildOutletCreated(t, r) { const o = this.getOrCreateContext(t); o.outlet = r, this.contexts.set(t, o) } onChildOutletDestroyed(t) { const r = this.getContext(t); r && (r.outlet = null, r.attachRef = null) } onOutletDeactivated() { const t = this.contexts; return this.contexts = new Map, t } onOutletReAttached(t) { this.contexts = t } getOrCreateContext(t) { let r = this.getContext(t); return r || (r = new D$(this.rootInjector), this.contexts.set(t, r)), r } getContext(t) { return this.contexts.get(t) || null } static { this.\u0275fac = function (r) { return new (r || e)(x(lt)) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); class EI { constructor(n) { this._root = n } get root() { return this._root.value } parent(n) { const t = this.pathFromRoot(n); return t.length > 1 ? t[t.length - 2] : null } children(n) { const t = Mg(n, this._root); return t ? t.children.map(r => r.value) : [] } firstChild(n) { const t = Mg(n, this._root); return t && t.children.length > 0 ? t.children[0].value : null } siblings(n) { const t = Ig(n, this._root); return t.length < 2 ? [] : t[t.length - 2].children.map(o => o.value).filter(o => o !== n) } pathFromRoot(n) { return Ig(n, this._root).map(t => t.value) } } function Mg(e, n) { if (e === n.value) return n; for (const t of n.children) { const r = Mg(e, t); if (r) return r } return null } function Ig(e, n) { if (e === n.value) return [n]; for (const t of n.children) { const r = Ig(e, t); if (r.length) return r.unshift(n), r } return [] } class fn { constructor(n, t) { this.value = n, this.children = t } toString() { return `TreeNode(${this.value})` } } function Ni(e) { const n = {}; return e && e.children.forEach(t => n[t.value.outlet] = t), n } class MI extends EI { constructor(n, t) { super(n), this.snapshot = t, Sg(this, n) } toString() { return this.snapshot.toString() } } function II(e) { const n = function w$(e) { const i = new Cu([], {}, {}, "", {}, q, e, null, {}); return new SI("", new fn(i, [])) }(e), t = new Vt([new pa("", {})]), r = new Vt({}), o = new Vt({}), i = new Vt({}), s = new Vt(""), a = new ao(t, r, i, s, o, q, e, n.root); return a.snapshot = n.root, new MI(new fn(a, []), n) } class ao { constructor(n, t, r, o, i, s, a, c) { this.urlSubject = n, this.paramsSubject = t, this.queryParamsSubject = r, this.fragmentSubject = o, this.dataSubject = i, this.outlet = s, this.component = a, this._futureSnapshot = c, this.title = this.dataSubject?.pipe(K(l => l[ha])) ?? U(void 0), this.url = n, this.params = t, this.queryParams = r, this.fragment = o, this.data = i } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap ??= this.params.pipe(K(n => Si(n))), this._paramMap } get queryParamMap() { return this._queryParamMap ??= this.queryParams.pipe(K(n => Si(n))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function _u(e, n, t = "emptyOnly") { let r; const { routeConfig: o } = e; return r = null === n || "always" !== t && "" !== o?.path && (n.component || n.routeConfig?.loadComponent) ? { params: { ...e.params }, data: { ...e.data }, resolve: { ...e.data, ...e._resolvedData ?? {} } } : { params: { ...n.params, ...e.params }, data: { ...n.data, ...e.data }, resolve: { ...e.data, ...n.data, ...o?.data, ...e._resolvedData } }, o && AI(o) && (r.resolve[ha] = o.title), r } class Cu { get title() { return this.data?.[ha] } constructor(n, t, r, o, i, s, a, c, l) { this.url = n, this.params = t, this.queryParams = r, this.fragment = o, this.data = i, this.outlet = s, this.component = a, this.routeConfig = c, this._resolve = l } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap ??= Si(this.params), this._paramMap } get queryParamMap() { return this._queryParamMap ??= Si(this.queryParams), this._queryParamMap } toString() { return `Route(url:'${this.url.map(r => r.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class SI extends EI { constructor(n, t) { super(t), this.url = n, Sg(this, t) } toString() { return TI(this._root) } } function Sg(e, n) { n.value._routerState = e, n.children.forEach(t => Sg(e, t)) } function TI(e) { const n = e.children.length > 0 ? ` { ${e.children.map(TI).join(", ")} } ` : ""; return `${e.value}${n}` } function Tg(e) { if (e.snapshot) { const n = e.snapshot, t = e._futureSnapshot; e.snapshot = t, Fn(n.queryParams, t.queryParams) || e.queryParamsSubject.next(t.queryParams), n.fragment !== t.fragment && e.fragmentSubject.next(t.fragment), Fn(n.params, t.params) || e.paramsSubject.next(t.params), function PU(e, n) { if (e.length !== n.length) return !1; for (let t = 0; t < e.length; ++t)if (!Fn(e[t], n[t])) return !1; return !0 }(n.url, t.url) || e.urlSubject.next(t.url), Fn(n.data, t.data) || e.dataSubject.next(t.data) } else e.snapshot = e._futureSnapshot, e.dataSubject.next(e._futureSnapshot.data) } function Ag(e, n) { const t = Fn(e.params, n.params) && function VU(e, n) { return oo(e, n) && e.every((t, r) => Fn(t.parameters, n[r].parameters)) }(e.url, n.url); return t && !(!e.parent != !n.parent) && (!e.parent || Ag(e.parent, n.parent)) } function AI(e) { return "string" == typeof e.title || null === e.title } let Ng = (() => { class e { constructor() { this.activated = null, this._activatedRoute = null, this.name = q, this.activateEvents = new Te, this.deactivateEvents = new Te, this.attachEvents = new Te, this.detachEvents = new Te, this.parentContexts = b(Ca), this.location = b(tn), this.changeDetector = b(ta), this.inputBinder = b(Du, { optional: !0 }), this.supportsBindingToComponentInputs = !0 } get activatedComponentRef() { return this.activated } ngOnChanges(t) { if (t.name) { const { firstChange: r, previousValue: o } = t.name; if (r) return; this.isTrackedInParentContexts(o) && (this.deactivate(), this.parentContexts.onChildOutletDestroyed(o)), this.initializeOutletWithName() } } ngOnDestroy() { this.isTrackedInParentContexts(this.name) && this.parentContexts.onChildOutletDestroyed(this.name), this.inputBinder?.unsubscribeFromRouteData(this) } isTrackedInParentContexts(t) { return this.parentContexts.getContext(t)?.outlet === this } ngOnInit() { this.initializeOutletWithName() } initializeOutletWithName() { if (this.parentContexts.onChildOutletCreated(this.name, this), this.activated) return; const t = this.parentContexts.getContext(this.name); t?.route && (t.attachRef ? this.attach(t.attachRef, t.route) : this.activateWith(t.route, t.injector)) } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new w(4012, !1); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new w(4012, !1); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new w(4012, !1); this.location.detach(); const t = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(t.instance), t } attach(t, r) { this.activated = t, this._activatedRoute = r, this.location.insert(t.hostView), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.attachEvents.emit(t.instance) } deactivate() { if (this.activated) { const t = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(t) } } activateWith(t, r) { if (this.isActivated) throw new w(4013, !1); this._activatedRoute = t; const o = this.location, s = t.snapshot.component, a = this.parentContexts.getOrCreateContext(this.name).children, c = new Og(t, a, o.injector); this.activated = o.createComponent(s, { index: o.length, injector: c, environmentInjector: r }), this.changeDetector.markForCheck(), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.activateEvents.emit(this.activated.instance) } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275dir = $({ type: e, selectors: [["router-outlet"]], inputs: { name: "name" }, outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"], standalone: !0, features: [Bt] }) } } return e })(); class Og { __ngOutletInjector(n) { return new Og(this.route, this.childContexts, n) } constructor(n, t, r) { this.route = n, this.childContexts = t, this.parent = r } get(n, t) { return n === ao ? this.route : n === Ca ? this.childContexts : this.parent.get(n, t) } } const Du = new T(""); let NI = (() => { class e { constructor() { this.outletDataSubscriptions = new Map } bindActivatedRouteToOutletComponent(t) { this.unsubscribeFromRouteData(t), this.subscribeToRouteData(t) } unsubscribeFromRouteData(t) { this.outletDataSubscriptions.get(t)?.unsubscribe(), this.outletDataSubscriptions.delete(t) } subscribeToRouteData(t) { const { activatedRoute: r } = t, o = pg([r.queryParams, r.params, r.data]).pipe(un(([i, s, a], c) => (a = { ...i, ...s, ...a }, 0 === c ? U(a) : Promise.resolve(a)))).subscribe(i => { if (!t.isActivated || !t.activatedComponentRef || t.activatedRoute !== r || null === r.component) return void this.unsubscribeFromRouteData(t); const s = function tV(e) { const n = Y(e); if (!n) return null; const t = new Rs(n); return { get selector() { return t.selector }, get type() { return t.componentType }, get inputs() { return t.inputs }, get outputs() { return t.outputs }, get ngContentSelectors() { return t.ngContentSelectors }, get isStandalone() { return n.standalone }, get isSignal() { return n.signals } } }(r.component); if (s) for (const { templateName: a } of s.inputs) t.activatedComponentRef.setInput(a, i[a]); else this.unsubscribeFromRouteData(t) }); this.outletDataSubscriptions.set(t, o) } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac }) } } return e })(); function Da(e, n, t) { if (t && e.shouldReuseRoute(n.value, t.value.snapshot)) { const r = t.value; r._futureSnapshot = n.value; const o = function E$(e, n, t) { return n.children.map(r => { for (const o of t.children) if (e.shouldReuseRoute(r.value, o.value.snapshot)) return Da(e, r, o); return Da(e, r) }) }(e, n, t); return new fn(r, o) } { if (e.shouldAttach(n.value)) { const i = e.retrieve(n.value); if (null !== i) { const s = i.route; return s.value._futureSnapshot = n.value, s.children = n.children.map(a => Da(e, a)), s } } const r = function M$(e) { return new ao(new Vt(e.url), new Vt(e.params), new Vt(e.queryParams), new Vt(e.fragment), new Vt(e.data), e.outlet, e.component, e) }(n.value), o = n.children.map(i => Da(e, i)); return new fn(r, o) } } class xg { constructor(n, t) { this.redirectTo = n, this.navigationBehaviorOptions = t } } const OI = "ngNavigationCancelingError"; function wu(e, n) { const { redirectTo: t, navigationBehaviorOptions: r } = io(n) ? { redirectTo: n, navigationBehaviorOptions: void 0 } : n, o = xI(!1, Lt.Redirect); return o.url = t, o.navigationBehaviorOptions = r, o } function xI(e, n) { const t = new Error(`NavigationCancelingError: ${e || ""}`); return t[OI] = !0, t.cancellationCode = n, t } function RI(e) { return !!e && e[OI] } class T$ { constructor(n, t, r, o, i) { this.routeReuseStrategy = n, this.futureState = t, this.currState = r, this.forwardEvent = o, this.inputBindingEnabled = i } activate(n) { const t = this.futureState._root, r = this.currState ? this.currState._root : null; this.deactivateChildRoutes(t, r, n), Tg(this.futureState.root), this.activateChildRoutes(t, r, n) } deactivateChildRoutes(n, t, r) { const o = Ni(t); n.children.forEach(i => { const s = i.value.outlet; this.deactivateRoutes(i, o[s], r), delete o[s] }), Object.values(o).forEach(i => { this.deactivateRouteAndItsChildren(i, r) }) } deactivateRoutes(n, t, r) { const o = n.value, i = t ? t.value : null; if (o === i) if (o.component) { const s = r.getContext(o.outlet); s && this.deactivateChildRoutes(n, t, s.children) } else this.deactivateChildRoutes(n, t, r); else i && this.deactivateRouteAndItsChildren(t, r) } deactivateRouteAndItsChildren(n, t) { n.value.component && this.routeReuseStrategy.shouldDetach(n.value.snapshot) ? this.detachAndStoreRouteSubtree(n, t) : this.deactivateRouteAndOutlet(n, t) } detachAndStoreRouteSubtree(n, t) { const r = t.getContext(n.value.outlet), o = r && n.value.component ? r.children : t, i = Ni(n); for (const s of Object.values(i)) this.deactivateRouteAndItsChildren(s, o); if (r && r.outlet) { const s = r.outlet.detach(), a = r.children.onOutletDeactivated(); this.routeReuseStrategy.store(n.value.snapshot, { componentRef: s, route: n, contexts: a }) } } deactivateRouteAndOutlet(n, t) { const r = t.getContext(n.value.outlet), o = r && n.value.component ? r.children : t, i = Ni(n); for (const s of Object.values(i)) this.deactivateRouteAndItsChildren(s, o); r && (r.outlet && (r.outlet.deactivate(), r.children.onOutletDeactivated()), r.attachRef = null, r.route = null) } activateChildRoutes(n, t, r) { const o = Ni(t); n.children.forEach(i => { this.activateRoutes(i, o[i.value.outlet], r), this.forwardEvent(new g$(i.value.snapshot)) }), n.children.length && this.forwardEvent(new h$(n.value.snapshot)) } activateRoutes(n, t, r) { const o = n.value, i = t ? t.value : null; if (Tg(o), o === i) if (o.component) { const s = r.getOrCreateContext(o.outlet); this.activateChildRoutes(n, t, s.children) } else this.activateChildRoutes(n, t, r); else if (o.component) { const s = r.getOrCreateContext(o.outlet); if (this.routeReuseStrategy.shouldAttach(o.snapshot)) { const a = this.routeReuseStrategy.retrieve(o.snapshot); this.routeReuseStrategy.store(o.snapshot, null), s.children.onOutletReAttached(a.contexts), s.attachRef = a.componentRef, s.route = a.route.value, s.outlet && s.outlet.attach(a.componentRef, a.route.value), Tg(a.route.value), this.activateChildRoutes(n, null, s.children) } else s.attachRef = null, s.route = o, s.outlet && s.outlet.activateWith(o, s.injector), this.activateChildRoutes(n, null, s.children) } else this.activateChildRoutes(n, null, r) } } class PI { constructor(n) { this.path = n, this.route = this.path[this.path.length - 1] } } class bu { constructor(n, t) { this.component = n, this.route = t } } function A$(e, n, t) { const r = e._root; return wa(r, n ? n._root : null, t, [r.value]) } function Oi(e, n) { const t = Symbol(), r = n.get(e, t); return r === t ? "function" != typeof e || function gT(e) { return null !== qa(e) }(e) ? n.get(e) : e : r } function wa(e, n, t, r, o = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = Ni(n); return e.children.forEach(s => { (function O$(e, n, t, r, o = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = e.value, s = n ? n.value : null, a = t ? t.getContext(e.value.outlet) : null; if (s && i.routeConfig === s.routeConfig) { const c = function x$(e, n, t) { if ("function" == typeof t) return t(e, n); switch (t) { case "pathParamsChange": return !oo(e.url, n.url); case "pathParamsOrQueryParamsChange": return !oo(e.url, n.url) || !Fn(e.queryParams, n.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !Ag(e, n) || !Fn(e.queryParams, n.queryParams); default: return !Ag(e, n) } }(s, i, i.routeConfig.runGuardsAndResolvers); c ? o.canActivateChecks.push(new PI(r)) : (i.data = s.data, i._resolvedData = s._resolvedData), wa(e, n, i.component ? a ? a.children : null : t, r, o), c && a && a.outlet && a.outlet.isActivated && o.canDeactivateChecks.push(new bu(a.outlet.component, s)) } else s && ba(n, a, o), o.canActivateChecks.push(new PI(r)), wa(e, null, i.component ? a ? a.children : null : t, r, o) })(s, i[s.value.outlet], t, r.concat([s.value]), o), delete i[s.value.outlet] }), Object.entries(i).forEach(([s, a]) => ba(a, t.getContext(s), o)), o } function ba(e, n, t) { const r = Ni(e), o = e.value; Object.entries(r).forEach(([i, s]) => { ba(s, o.component ? n ? n.children.getContext(i) : null : n, t) }), t.canDeactivateChecks.push(new bu(o.component && n && n.outlet && n.outlet.isActivated ? n.outlet.component : null, o)) } function Ea(e) { return "function" == typeof e } function FI(e) { return e instanceof iu || "EmptyError" === e?.name } const Eu = Symbol("INITIAL_VALUE"); function xi() { return un(e => pg(e.map(n => n.pipe(Ei(1), function MU(...e) { const n = ou(e); return Xe((t, r) => { (n ? gg(e, t, n) : gg(e, t)).subscribe(r) }) }(Eu)))).pipe(K(n => { for (const t of n) if (!0 !== t) { if (t === Eu) return Eu; if (!1 === t || j$(t)) return t } return !0 }), er(n => n !== Eu), Ei(1))) } function j$(e) { return io(e) || e instanceof xg } function kI(e) { return function iT(...e) { return Nm(e) }(vt(n => { if ("boolean" != typeof n) throw wu(0, n) }), K(n => !0 === n)) } class Rg { constructor(n) { this.segmentGroup = n || null } } class Mu extends Error { constructor(n) { super(), this.urlTree = n } } function Ri(e) { return su(new Rg(e)) } class X$ { constructor(n, t) { this.urlSerializer = n, this.urlTree = t } lineralizeSegments(n, t) { let r = [], o = t.root; for (; ;) { if (r = r.concat(o.segments), 0 === o.numberOfChildren) return U(r); if (o.numberOfChildren > 1 || !o.children[q]) return su(new w(4e3, !1)); o = o.children[q] } } applyRedirectCommands(n, t, r, o, i) { if ("string" != typeof t) { const a = t, { queryParams: c, fragment: l, routeConfig: u, url: d, outlet: f, params: h, data: p, title: g } = o, v = mn(i, () => a({ params: h, data: p, queryParams: c, fragment: l, routeConfig: u, url: d, outlet: f, title: g })); if (v instanceof ro) throw new Mu(v); t = v } const s = this.applyRedirectCreateUrlTree(t, this.urlSerializer.parse(t), n, r); if ("/" === t[0]) throw new Mu(s); return s } applyRedirectCreateUrlTree(n, t, r, o) { const i = this.createSegmentGroup(n, t.root, r, o); return new ro(i, this.createQueryParams(t.queryParams, this.urlTree.queryParams), t.fragment) } createQueryParams(n, t) { const r = {}; return Object.entries(n).forEach(([o, i]) => { if ("string" == typeof i && ":" === i[0]) { const a = i.substring(1); r[o] = t[a] } else r[o] = i }), r } createSegmentGroup(n, t, r, o) { const i = this.createSegments(n, t.segments, r, o); let s = {}; return Object.entries(t.children).forEach(([a, c]) => { s[a] = this.createSegmentGroup(n, c, r, o) }), new de(i, s) } createSegments(n, t, r, o) { return t.map(i => ":" === i.path[0] ? this.findPosParam(n, i, o) : this.findOrReturn(i, r)) } findPosParam(n, t, r) { const o = r[t.path.substring(1)]; if (!o) throw new w(4001, !1); return o } findOrReturn(n, t) { let r = 0; for (const o of t) { if (o.path === n.path) return t.splice(r), o; r++ } return n } } const Pg = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} }; function K$(e, n, t, r, o) { const i = LI(e, n, t); return i.matched ? (r = function m$(e, n) { return e.providers && !e._injector && (e._injector = sl(e.providers, n, `Route: ${e.path}`)), e._injector ?? n }(n, r), function Q$(e, n, t, r) { const o = n.canMatch; return o && 0 !== o.length ? U(o.map(s => { const a = Oi(s, e); return _r(function V$(e) { return e && Ea(e.canMatch) }(a) ? a.canMatch(n, t) : mn(e, () => a(n, t))) })).pipe(xi(), kI()) : U(!0) }(r, n, t).pipe(K(s => !0 === s ? i : { ...Pg }))) : U(i) } function LI(e, n, t) { if ("**" === n.path) return function e3(e) { return { matched: !0, parameters: e.length > 0 ? oI(e).parameters : {}, consumedSegments: e, remainingSegments: [], positionalParamSegments: {} } }(t); if ("" === n.path) return "full" === n.pathMatch && (e.hasChildren() || t.length > 0) ? { ...Pg } : { matched: !0, consumedSegments: [], remainingSegments: t, parameters: {}, positionalParamSegments: {} }; const o = (n.matcher || RU)(t, e, n); if (!o) return { ...Pg }; const i = {}; Object.entries(o.posParams ?? {}).forEach(([a, c]) => { i[a] = c.path }); const s = o.consumed.length > 0 ? { ...i, ...o.consumed[o.consumed.length - 1].parameters } : i; return { matched: !0, consumedSegments: o.consumed, remainingSegments: t.slice(o.consumed.length), parameters: s, positionalParamSegments: o.posParams ?? {} } } function VI(e, n, t, r) { return t.length > 0 && function r3(e, n, t) { return t.some(r => Iu(e, n, r) && dn(r) !== q) }(e, t, r) ? { segmentGroup: new de(n, n3(r, new de(t, e.children))), slicedSegments: [] } : 0 === t.length && function o3(e, n, t) { return t.some(r => Iu(e, n, r)) }(e, t, r) ? { segmentGroup: new de(e.segments, t3(e, t, r, e.children)), slicedSegments: t } : { segmentGroup: new de(e.segments, e.children), slicedSegments: t } } function t3(e, n, t, r) { const o = {}; for (const i of t) if (Iu(e, n, i) && !r[dn(i)]) { const s = new de([], {}); o[dn(i)] = s } return { ...r, ...o } } function n3(e, n) { const t = {}; t[q] = n; for (const r of e) if ("" === r.path && dn(r) !== q) { const o = new de([], {}); t[dn(r)] = o } return t } function Iu(e, n, t) { return (!(e.hasChildren() || n.length > 0) || "full" !== t.pathMatch) && "" === t.path } class s3 { } class l3 { constructor(n, t, r, o, i, s, a) { this.injector = n, this.configLoader = t, this.rootComponentType = r, this.config = o, this.urlTree = i, this.paramsInheritanceStrategy = s, this.urlSerializer = a, this.applyRedirects = new X$(this.urlSerializer, this.urlTree), this.absoluteRedirectCount = 0, this.allowRedirects = !0 } noMatchError(n) { return new w(4002, `'${n.segmentGroup}'`) } recognize() { const n = VI(this.urlTree.root, [], [], this.config).segmentGroup; return this.match(n).pipe(K(({ children: t, rootSnapshot: r }) => { const o = new fn(r, t), i = new SI("", o), s = function KU(e, n, t = null, r = null) { return mI(gI(e), n, t, r) }(r, [], this.urlTree.queryParams, this.urlTree.fragment); return s.queryParams = this.urlTree.queryParams, i.url = this.urlSerializer.serialize(s), { state: i, tree: s } })) } match(n) { const t = new Cu([], Object.freeze({}), Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, Object.freeze({}), q, this.rootComponentType, null, {}); return this.processSegmentGroup(this.injector, this.config, n, q, t).pipe(K(r => ({ children: r, rootSnapshot: t })), Ii(r => { if (r instanceof Mu) return this.urlTree = r.urlTree, this.match(r.urlTree.root); throw r instanceof Rg ? this.noMatchError(r) : r })) } processSegmentGroup(n, t, r, o, i) { return 0 === r.segments.length && r.hasChildren() ? this.processChildren(n, t, r, i) : this.processSegment(n, t, r, r.segments, o, !0, i).pipe(K(s => s instanceof fn ? [s] : [])) } processChildren(n, t, r, o) { const i = []; for (const s of Object.keys(r.children)) "primary" === s ? i.unshift(s) : i.push(s); return Qe(i).pipe(Mi(s => { const a = r.children[s], c = function C$(e, n) { const t = e.filter(r => dn(r) === n); return t.push(...e.filter(r => dn(r) !== n)), t }(t, s); return this.processSegmentGroup(n, c, a, s, o) }), function TU(e, n) { return Xe(function SU(e, n, t, r, o) { return (i, s) => { let a = t, c = n, l = 0; i.subscribe(Ue(s, u => { const d = l++; c = a ? e(c, u, d) : (a = !0, u), r && s.next(c) }, o && (() => { a && s.next(c), s.complete() }))) } }(e, n, arguments.length >= 2, !0)) }((s, a) => (s.push(...a), s)), au(null), function AU(e, n) { const t = arguments.length >= 2; return r => r.pipe(e ? er((o, i) => e(o, i, r)) : Tr, vg(1), t ? au(n) : nI(() => new iu)) }(), it(s => { if (null === s) return Ri(r); const a = jI(s); return function u3(e) { e.sort((n, t) => n.value.outlet === q ? -1 : t.value.outlet === q ? 1 : n.value.outlet.localeCompare(t.value.outlet)) }(a), U(a) })) } processSegment(n, t, r, o, i, s, a) { return Qe(t).pipe(Mi(c => this.processSegmentAgainstRoute(c._injector ?? n, t, c, r, o, i, s, a).pipe(Ii(l => { if (l instanceof Rg) return U(null); throw l }))), no(c => !!c), Ii(c => { if (FI(c)) return function i3(e, n, t) { return 0 === n.length && !e.children[t] }(r, o, i) ? U(new s3) : Ri(r); throw c })) } processSegmentAgainstRoute(n, t, r, o, i, s, a, c) { return dn(r) === s || s !== q && Iu(o, i, r) ? void 0 === r.redirectTo ? this.matchSegmentAgainstRoute(n, o, r, i, s, c) : this.allowRedirects && a ? this.expandSegmentAgainstRouteUsingRedirect(n, o, t, r, i, s, c) : Ri(o) : Ri(o) } expandSegmentAgainstRouteUsingRedirect(n, t, r, o, i, s, a) { const { matched: c, parameters: l, consumedSegments: u, positionalParamSegments: d, remainingSegments: f } = LI(t, o, i); if (!c) return Ri(t); "string" == typeof o.redirectTo && "/" === o.redirectTo[0] && (this.absoluteRedirectCount++, this.absoluteRedirectCount > 31 && (this.allowRedirects = !1)); const h = new Cu(i, l, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, BI(o), dn(o), o.component ?? o._loadedComponent ?? null, o, UI(o)), p = _u(h, a, this.paramsInheritanceStrategy); h.params = Object.freeze(p.params), h.data = Object.freeze(p.data); const g = this.applyRedirects.applyRedirectCommands(u, o.redirectTo, d, h, n); return this.applyRedirects.lineralizeSegments(o, g).pipe(it(v => this.processSegment(n, r, t, v.concat(f), s, !1, a))) } matchSegmentAgainstRoute(n, t, r, o, i, s) { const a = K$(t, r, o, n); return "**" === r.path && (t.children = {}), a.pipe(un(c => c.matched ? this.getChildConfig(n = r._injector ?? n, r, o).pipe(un(({ routes: l }) => { const u = r._loadedInjector ?? n, { parameters: d, consumedSegments: f, remainingSegments: h } = c, p = new Cu(f, d, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, BI(r), dn(r), r.component ?? r._loadedComponent ?? null, r, UI(r)), g = _u(p, s, this.paramsInheritanceStrategy); p.params = Object.freeze(g.params), p.data = Object.freeze(g.data); const { segmentGroup: v, slicedSegments: D } = VI(t, f, h, l); if (0 === D.length && v.hasChildren()) return this.processChildren(u, l, v, p).pipe(K(A => new fn(p, A))); if (0 === l.length && 0 === D.length) return U(new fn(p, [])); const _ = dn(r) === i; return this.processSegment(u, l, v, D, _ ? q : i, !0, p).pipe(K(A => new fn(p, A instanceof fn ? [A] : []))) })) : Ri(t))) } getChildConfig(n, t, r) { return t.children ? U({ routes: t.children, injector: n }) : t.loadChildren ? void 0 !== t._loadedRoutes ? U({ routes: t._loadedRoutes, injector: t._loadedInjector }) : function Z$(e, n, t, r) { const o = n.canLoad; return void 0 === o || 0 === o.length ? U(!0) : U(o.map(s => { const a = Oi(s, e); return _r(function P$(e) { return e && Ea(e.canLoad) }(a) ? a.canLoad(n, t) : mn(e, () => a(n, t))) })).pipe(xi(), kI()) }(n, t, r).pipe(it(o => o ? this.configLoader.loadChildren(n, t).pipe(vt(i => { t._loadedRoutes = i.routes, t._loadedInjector = i.injector })) : function J$() { return su(xI(!1, Lt.GuardRejected)) }())) : U({ routes: [], injector: n }) } } function d3(e) { const n = e.value.routeConfig; return n && "" === n.path } function jI(e) { const n = [], t = new Set; for (const r of e) { if (!d3(r)) { n.push(r); continue } const o = n.find(i => r.value.routeConfig === i.value.routeConfig); void 0 !== o ? (o.children.push(...r.children), t.add(o)) : n.push(r) } for (const r of t) { const o = jI(r.children); n.push(new fn(r.value, o)) } return n.filter(r => !t.has(r)) } function BI(e) { return e.data || {} } function UI(e) { return e.resolve || {} } function $I(e) { const n = e.children.map(t => $I(t)).flat(); return [e, ...n] } function Fg(e) { return un(n => { const t = e(n); return t ? Qe(t).pipe(K(() => n)) : U(n) }) } let HI = (() => { class e { buildTitle(t) { let r, o = t.root; for (; void 0 !== o;)r = this.getResolvedTitleForRoute(o) ?? r, o = o.children.find(i => i.outlet === q); return r } getResolvedTitleForRoute(t) { return t.data[ha] } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: () => b(v3), providedIn: "root" }) } } return e })(), v3 = (() => { class e extends HI { constructor(t) { super(), this.title = t } updateTitle(t) { const r = this.buildTitle(t); void 0 !== r && this.title.setTitle(r) } static { this.\u0275fac = function (r) { return new (r || e)(x(TM)) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); const Pi = new T("", { providedIn: "root", factory: () => ({}) }); let GI = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275cmp = gn({ type: e, selectors: [["ng-component"]], standalone: !0, features: [Nn], decls: 1, vars: 0, template: function (r, o) { 1 & r && k(0, "router-outlet") }, dependencies: [Ng], encapsulation: 2 }) } } return e })(); function kg(e) { const n = e.children && e.children.map(kg), t = n ? { ...e, children: n } : { ...e }; return !t.component && !t.loadComponent && (n || t.loadChildren) && t.outlet && t.outlet !== q && (t.component = GI), t } const Fi = new T(""); let Lg = (() => { class e { constructor() { this.componentLoaders = new WeakMap, this.childrenLoaders = new WeakMap, this.compiler = b(Jb) } loadComponent(t) { if (this.componentLoaders.get(t)) return this.componentLoaders.get(t); if (t._loadedComponent) return U(t._loadedComponent); this.onLoadStartListener && this.onLoadStartListener(t); const r = _r(t.loadComponent()).pipe(K(zI), vt(i => { this.onLoadEndListener && this.onLoadEndListener(t), t._loadedComponent = i }), cu(() => { this.componentLoaders.delete(t) })), o = new tI(r, () => new It).pipe(mg()); return this.componentLoaders.set(t, o), o } loadChildren(t, r) { if (this.childrenLoaders.get(r)) return this.childrenLoaders.get(r); if (r._loadedRoutes) return U({ routes: r._loadedRoutes, injector: r._loadedInjector }); this.onLoadStartListener && this.onLoadStartListener(r); const i = function y3(e, n, t, r) { return _r(e.loadChildren()).pipe(K(zI), it(o => o instanceof lD || Array.isArray(o) ? U(o) : Qe(n.compileModuleAsync(o))), K(o => { r && r(e); let i, s, a = !1; return Array.isArray(o) ? (s = o, !0) : (i = o.create(t).injector, s = i.get(Fi, [], { optional: !0, self: !0 }).flat()), { routes: s.map(kg), injector: i } })) }(r, this.compiler, t, this.onLoadEndListener).pipe(cu(() => { this.childrenLoaders.delete(r) })), s = new tI(i, () => new It).pipe(mg()); return this.childrenLoaders.set(r, s), s } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); function zI(e) { return function _3(e) { return e && "object" == typeof e && "default" in e }(e) ? e.default : e } let Vg = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: () => b(C3), providedIn: "root" }) } } return e })(), C3 = (() => { class e { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, r) { return t } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); const qI = new T(""), WI = new T(""); function D3(e, n, t) { const r = e.get(WI), o = e.get(Et); return e.get(ie).runOutsideAngular(() => { if (!o.startViewTransition || r.skipNextTransition) return r.skipNextTransition = !1, new Promise(l => setTimeout(l)); let i; const s = new Promise(l => { i = l }), a = o.startViewTransition(() => (i(), function w3(e) { return new Promise(n => { fl({ read: () => setTimeout(n) }, { injector: e }) }) }(e))), { onViewTransitionCreated: c } = r; return c && mn(e, () => c({ transition: a, from: n, to: t })), s }) } const ZI = new T(""); let Su = (() => { class e { get hasRequestedNavigation() { return 0 !== this.navigationId } constructor() { this.currentNavigation = null, this.currentTransition = null, this.lastSuccessfulNavigation = null, this.events = new It, this.transitionAbortSubject = new It, this.configLoader = b(Lg), this.environmentInjector = b(lt), this.urlSerializer = b(Ti), this.rootContexts = b(Ca), this.location = b(sa), this.inputBindingEnabled = null !== b(Du, { optional: !0 }), this.titleStrategy = b(HI), this.options = b(Pi, { optional: !0 }) || {}, this.paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly", this.urlHandlingStrategy = b(Vg), this.createViewTransition = b(qI, { optional: !0 }), this.navigationErrorHandler = b(ZI, { optional: !0 }), this.navigationId = 0, this.afterPreactivation = () => U(void 0), this.rootComponentType = null, this.configLoader.onLoadEndListener = o => this.events.next(new d$(o)), this.configLoader.onLoadStartListener = o => this.events.next(new u$(o)) } complete() { this.transitions?.complete() } handleNavigationRequest(t) { const r = ++this.navigationId; this.transitions?.next({ ...this.transitions.value, ...t, id: r }) } setupNavigations(t, r, o) { return this.transitions = new Vt({ id: 0, currentUrlTree: r, currentRawUrl: r, extractedUrl: this.urlHandlingStrategy.extract(r), urlAfterRedirects: this.urlHandlingStrategy.extract(r), rawUrl: r, extras: {}, resolve: () => { }, reject: () => { }, promise: Promise.resolve(!0), source: ya, restoredState: null, currentSnapshot: o.snapshot, targetSnapshot: null, currentRouterState: o, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.transitions.pipe(er(i => 0 !== i.id), K(i => ({ ...i, extractedUrl: this.urlHandlingStrategy.extract(i.rawUrl) })), un(i => { let s = !1, a = !1; return U(i).pipe(un(c => { if (this.navigationId > i.id) return this.cancelNavigationTransition(i, "", Lt.SupersededByNewNavigation), Pn; this.currentTransition = i, this.currentNavigation = { id: c.id, initialUrl: c.rawUrl, extractedUrl: c.extractedUrl, targetBrowserUrl: "string" == typeof c.extras.browserUrl ? this.urlSerializer.parse(c.extras.browserUrl) : c.extras.browserUrl, trigger: c.source, extras: c.extras, previousNavigation: this.lastSuccessfulNavigation ? { ...this.lastSuccessfulNavigation, previousNavigation: null } : null }; const l = !t.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl(); if (!l && "reload" !== (c.extras.onSameUrlNavigation ?? t.onSameUrlNavigation)) { const d = ""; return this.events.next(new Ai(c.id, this.urlSerializer.serialize(c.rawUrl), d, vu.IgnoredSameUrlNavigation)), c.resolve(!1), Pn } if (this.urlHandlingStrategy.shouldProcessUrl(c.rawUrl)) return U(c).pipe(un(d => { const f = this.transitions?.getValue(); return this.events.next(new mu(d.id, this.urlSerializer.serialize(d.extractedUrl), d.source, d.restoredState)), f !== this.transitions?.getValue() ? Pn : Promise.resolve(d) }), function f3(e, n, t, r, o, i) { return it(s => function a3(e, n, t, r, o, i, s = "emptyOnly") { return new l3(e, n, t, r, o, s, i).recognize() }(e, n, t, r, s.extractedUrl, o, i).pipe(K(({ state: a, tree: c }) => ({ ...s, targetSnapshot: a, urlAfterRedirects: c })))) }(this.environmentInjector, this.configLoader, this.rootComponentType, t.config, this.urlSerializer, this.paramsInheritanceStrategy), vt(d => { i.targetSnapshot = d.targetSnapshot, i.urlAfterRedirects = d.urlAfterRedirects, this.currentNavigation = { ...this.currentNavigation, finalUrl: d.urlAfterRedirects }; const f = new wI(d.id, this.urlSerializer.serialize(d.extractedUrl), this.urlSerializer.serialize(d.urlAfterRedirects), d.targetSnapshot); this.events.next(f) })); if (l && this.urlHandlingStrategy.shouldProcessUrl(c.currentRawUrl)) { const { id: d, extractedUrl: f, source: h, restoredState: p, extras: g } = c, v = new mu(d, this.urlSerializer.serialize(f), h, p); this.events.next(v); const D = II(this.rootComponentType).snapshot; return this.currentTransition = i = { ...c, targetSnapshot: D, urlAfterRedirects: f, extras: { ...g, skipLocationChange: !1, replaceUrl: !1 } }, this.currentNavigation.finalUrl = f, U(i) } { const d = ""; return this.events.next(new Ai(c.id, this.urlSerializer.serialize(c.extractedUrl), d, vu.IgnoredByUrlHandlingStrategy)), c.resolve(!1), Pn } }), vt(c => { const l = new s$(c.id, this.urlSerializer.serialize(c.extractedUrl), this.urlSerializer.serialize(c.urlAfterRedirects), c.targetSnapshot); this.events.next(l) }), K(c => (this.currentTransition = i = { ...c, guards: A$(c.targetSnapshot, c.currentSnapshot, this.rootContexts) }, i)), function B$(e, n) { return it(t => { const { targetSnapshot: r, currentSnapshot: o, guards: { canActivateChecks: i, canDeactivateChecks: s } } = t; return 0 === s.length && 0 === i.length ? U({ ...t, guardsResult: !0 }) : function U$(e, n, t, r) { return Qe(e).pipe(it(o => function W$(e, n, t, r, o) { const i = n && n.routeConfig ? n.routeConfig.canDeactivate : null; return i && 0 !== i.length ? U(i.map(a => { const c = _a(n) ?? o, l = Oi(a, c); return _r(function L$(e) { return e && Ea(e.canDeactivate) }(l) ? l.canDeactivate(e, n, t, r) : mn(c, () => l(e, n, t, r))).pipe(no()) })).pipe(xi()) : U(!0) }(o.component, o.route, t, n, r)), no(o => !0 !== o, !0)) }(s, r, o, e).pipe(it(a => a && function R$(e) { return "boolean" == typeof e }(a) ? function $$(e, n, t, r) { return Qe(n).pipe(Mi(o => gg(function G$(e, n) { return null !== e && n && n(new f$(e)), U(!0) }(o.route.parent, r), function H$(e, n) { return null !== e && n && n(new p$(e)), U(!0) }(o.route, r), function q$(e, n, t) { const r = n[n.length - 1], i = n.slice(0, n.length - 1).reverse().map(s => function N$(e) { const n = e.routeConfig ? e.routeConfig.canActivateChild : null; return n && 0 !== n.length ? { node: e, guards: n } : null }(s)).filter(s => null !== s).map(s => eI(() => U(s.guards.map(c => { const l = _a(s.node) ?? t, u = Oi(c, l); return _r(function k$(e) { return e && Ea(e.canActivateChild) }(u) ? u.canActivateChild(r, e) : mn(l, () => u(r, e))).pipe(no()) })).pipe(xi()))); return U(i).pipe(xi()) }(e, o.path, t), function z$(e, n, t) { const r = n.routeConfig ? n.routeConfig.canActivate : null; if (!r || 0 === r.length) return U(!0); const o = r.map(i => eI(() => { const s = _a(n) ?? t, a = Oi(i, s); return _r(function F$(e) { return e && Ea(e.canActivate) }(a) ? a.canActivate(n, e) : mn(s, () => a(n, e))).pipe(no()) })); return U(o).pipe(xi()) }(e, o.route, t))), no(o => !0 !== o, !0)) }(r, i, e, n) : U(a)), K(a => ({ ...t, guardsResult: a }))) }) }(this.environmentInjector, c => this.events.next(c)), vt(c => { if (i.guardsResult = c.guardsResult, c.guardsResult && "boolean" != typeof c.guardsResult) throw wu(0, c.guardsResult); const l = new a$(c.id, this.urlSerializer.serialize(c.extractedUrl), this.urlSerializer.serialize(c.urlAfterRedirects), c.targetSnapshot, !!c.guardsResult); this.events.next(l) }), er(c => !!c.guardsResult || (this.cancelNavigationTransition(c, "", Lt.GuardRejected), !1)), Fg(c => { if (c.guards.canActivateChecks.length) return U(c).pipe(vt(l => { const u = new c$(l.id, this.urlSerializer.serialize(l.extractedUrl), this.urlSerializer.serialize(l.urlAfterRedirects), l.targetSnapshot); this.events.next(u) }), un(l => { let u = !1; return U(l).pipe(function h3(e, n) { return it(t => { const { targetSnapshot: r, guards: { canActivateChecks: o } } = t; if (!o.length) return U(t); const i = new Set(o.map(c => c.route)), s = new Set; for (const c of i) if (!s.has(c)) for (const l of $I(c)) s.add(l); let a = 0; return Qe(s).pipe(Mi(c => i.has(c) ? function p3(e, n, t, r) { const o = e.routeConfig, i = e._resolve; return void 0 !== o?.title && !AI(o) && (i[ha] = o.title), function g3(e, n, t, r) { const o = yg(e); if (0 === o.length) return U({}); const i = {}; return Qe(o).pipe(it(s => function m3(e, n, t, r) { const o = _a(n) ?? r, i = Oi(e, o); return _r(i.resolve ? i.resolve(n, t) : mn(o, () => i(n, t))) }(e[s], n, t, r).pipe(no(), vt(a => { if (a instanceof xg) throw wu(new uu, a); i[s] = a }))), vg(1), function NU(e) { return K(() => e) }(i), Ii(s => FI(s) ? Pn : su(s))) }(i, e, n, r).pipe(K(s => (e._resolvedData = s, e.data = _u(e, e.parent, t).resolve, null))) }(c, r, e, n) : (c.data = _u(c, c.parent, e).resolve, U(void 0))), vt(() => a++), vg(1), it(c => a === s.size ? U(t) : Pn)) }) }(this.paramsInheritanceStrategy, this.environmentInjector), vt({ next: () => u = !0, complete: () => { u || this.cancelNavigationTransition(l, "", Lt.NoDataFromResolver) } })) }), vt(l => { const u = new l$(l.id, this.urlSerializer.serialize(l.extractedUrl), this.urlSerializer.serialize(l.urlAfterRedirects), l.targetSnapshot); this.events.next(u) })) }), Fg(c => { const l = u => { const d = []; u.routeConfig?.loadComponent && !u.routeConfig._loadedComponent && d.push(this.configLoader.loadComponent(u.routeConfig).pipe(vt(f => { u.component = f }), K(() => { }))); for (const f of u.children) d.push(...l(f)); return d }; return pg(l(c.targetSnapshot.root)).pipe(au(null), Ei(1)) }), Fg(() => this.afterPreactivation()), un(() => { const { currentSnapshot: c, targetSnapshot: l } = i, u = this.createViewTransition?.(this.environmentInjector, c.root, l.root); return u ? Qe(u).pipe(K(() => i)) : U(i) }), K(c => { const l = function b$(e, n, t) { const r = Da(e, n._root, t ? t._root : void 0); return new MI(r, n) }(t.routeReuseStrategy, c.targetSnapshot, c.currentRouterState); return this.currentTransition = i = { ...c, targetRouterState: l }, this.currentNavigation.targetRouterState = l, i }), vt(() => { this.events.next(new Eg) }), ((e, n, t, r) => K(o => (new T$(n, o.targetRouterState, o.currentRouterState, t, r).activate(e), o)))(this.rootContexts, t.routeReuseStrategy, c => this.events.next(c), this.inputBindingEnabled), Ei(1), vt({ next: c => { s = !0, this.lastSuccessfulNavigation = this.currentNavigation, this.events.next(new tr(c.id, this.urlSerializer.serialize(c.extractedUrl), this.urlSerializer.serialize(c.urlAfterRedirects))), this.titleStrategy?.updateTitle(c.targetRouterState.snapshot), c.resolve(!0) }, complete: () => { s = !0 } }), function OU(e) { return Xe((n, t) => { Rn(e).subscribe(Ue(t, () => t.complete(), rd)), !t.closed && n.subscribe(t) }) }(this.transitionAbortSubject.pipe(vt(c => { throw c }))), cu(() => { !s && !a && this.cancelNavigationTransition(i, "", Lt.SupersededByNewNavigation), this.currentTransition?.id === i.id && (this.currentNavigation = null, this.currentTransition = null) }), Ii(c => { if (a = !0, RI(c)) this.events.next(new so(i.id, this.urlSerializer.serialize(i.extractedUrl), c.message, c.cancellationCode)), function I$(e) { return RI(e) && io(e.url) }(c) ? this.events.next(new yu(c.url, c.navigationBehaviorOptions)) : i.resolve(!1); else { const l = new bg(i.id, this.urlSerializer.serialize(i.extractedUrl), c, i.targetSnapshot ?? void 0); try { const u = mn(this.environmentInjector, () => this.navigationErrorHandler?.(l)); if (u instanceof xg) { const { message: d, cancellationCode: f } = wu(0, u); this.events.next(new so(i.id, this.urlSerializer.serialize(i.extractedUrl), d, f)), this.events.next(new yu(u.redirectTo, u.navigationBehaviorOptions)) } else { this.events.next(l); const d = t.errorHandler(c); i.resolve(!!d) } } catch (u) { this.options.resolveNavigationPromiseOnError ? i.resolve(!1) : i.reject(u) } } return Pn })) })) } cancelNavigationTransition(t, r, o) { const i = new so(t.id, this.urlSerializer.serialize(t.extractedUrl), r, o); this.events.next(i), t.resolve(!1) } isUpdatingInternalState() { return this.currentTransition?.extractedUrl.toString() !== this.currentTransition?.currentUrlTree.toString() } isUpdatedBrowserUrl() { const t = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(!0))), r = this.currentNavigation?.targetBrowserUrl ?? this.currentNavigation?.extractedUrl; return t.toString() !== r?.toString() && !this.currentNavigation?.extras.skipLocationChange } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); function b3(e) { return e !== ya } let E3 = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: () => b(I3), providedIn: "root" }) } } return e })(); class M3 { shouldDetach(n) { return !1 } store(n, t) { } shouldAttach(n) { return !1 } retrieve(n) { return null } shouldReuseRoute(n, t) { return n.routeConfig === t.routeConfig } } let I3 = (() => { class e extends M3 { static { this.\u0275fac = (() => { let t; return function (o) { return (t || (t = Ye(e)))(o || e) } })() } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(), QI = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: () => b(S3), providedIn: "root" }) } } return e })(), S3 = (() => { class e extends QI { constructor() { super(...arguments), this.location = b(sa), this.urlSerializer = b(Ti), this.options = b(Pi, { optional: !0 }) || {}, this.canceledNavigationResolution = this.options.canceledNavigationResolution || "replace", this.urlHandlingStrategy = b(Vg), this.urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred", this.currentUrlTree = new ro, this.rawUrlTree = this.currentUrlTree, this.currentPageId = 0, this.lastSuccessfulId = -1, this.routerState = II(null), this.stateMemento = this.createStateMemento() } getCurrentUrlTree() { return this.currentUrlTree } getRawUrlTree() { return this.rawUrlTree } restoredState() { return this.location.getState() } get browserPageId() { return "computed" !== this.canceledNavigationResolution ? this.currentPageId : this.restoredState()?.\u0275routerPageId ?? this.currentPageId } getRouterState() { return this.routerState } createStateMemento() { return { rawUrlTree: this.rawUrlTree, currentUrlTree: this.currentUrlTree, routerState: this.routerState } } registerNonRouterCurrentEntryChangeListener(t) { return this.location.subscribe(r => { "popstate" === r.type && t(r.url, r.state) }) } handleRouterEvent(t, r) { if (t instanceof mu) this.stateMemento = this.createStateMemento(); else if (t instanceof Ai) this.rawUrlTree = r.initialUrl; else if (t instanceof wI) { if ("eager" === this.urlUpdateStrategy && !r.extras.skipLocationChange) { const o = this.urlHandlingStrategy.merge(r.finalUrl, r.initialUrl); this.setBrowserUrl(r.targetBrowserUrl ?? o, r) } } else t instanceof Eg ? (this.currentUrlTree = r.finalUrl, this.rawUrlTree = this.urlHandlingStrategy.merge(r.finalUrl, r.initialUrl), this.routerState = r.targetRouterState, "deferred" === this.urlUpdateStrategy && !r.extras.skipLocationChange && this.setBrowserUrl(r.targetBrowserUrl ?? this.rawUrlTree, r)) : t instanceof so && (t.code === Lt.GuardRejected || t.code === Lt.NoDataFromResolver) ? this.restoreHistory(r) : t instanceof bg ? this.restoreHistory(r, !0) : t instanceof tr && (this.lastSuccessfulId = t.id, this.currentPageId = this.browserPageId) } setBrowserUrl(t, r) { const o = t instanceof ro ? this.urlSerializer.serialize(t) : t; if (this.location.isCurrentPathEqualTo(o) || r.extras.replaceUrl) { const s = { ...r.extras.state, ...this.generateNgRouterState(r.id, this.browserPageId) }; this.location.replaceState(o, "", s) } else { const i = { ...r.extras.state, ...this.generateNgRouterState(r.id, this.browserPageId + 1) }; this.location.go(o, "", i) } } restoreHistory(t, r = !1) { if ("computed" === this.canceledNavigationResolution) { const i = this.currentPageId - this.browserPageId; 0 !== i ? this.location.historyGo(i) : this.currentUrlTree === t.finalUrl && 0 === i && (this.resetState(t), this.resetUrlToCurrentUrlTree()) } else "replace" === this.canceledNavigationResolution && (r && this.resetState(t), this.resetUrlToCurrentUrlTree()) } resetState(t) { this.routerState = this.stateMemento.routerState, this.currentUrlTree = this.stateMemento.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.finalUrl ?? this.rawUrlTree) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } generateNgRouterState(t, r) { return "computed" === this.canceledNavigationResolution ? { navigationId: t, \u0275routerPageId: r } : { navigationId: t } } static { this.\u0275fac = (() => { let t; return function (o) { return (t || (t = Ye(e)))(o || e) } })() } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); var Ma = function (e) { return e[e.COMPLETE = 0] = "COMPLETE", e[e.FAILED = 1] = "FAILED", e[e.REDIRECTING = 2] = "REDIRECTING", e }(Ma || {}); function YI(e, n) { e.events.pipe(er(t => t instanceof tr || t instanceof so || t instanceof bg || t instanceof Ai), K(t => t instanceof tr || t instanceof Ai ? Ma.COMPLETE : t instanceof so && (t.code === Lt.Redirect || t.code === Lt.SupersededByNewNavigation) ? Ma.REDIRECTING : Ma.FAILED), er(t => t !== Ma.REDIRECTING), Ei(1)).subscribe(() => { n() }) } function T3(e) { throw e } const A3 = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, N3 = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let Mt = (() => { class e { get currentUrlTree() { return this.stateManager.getCurrentUrlTree() } get rawUrlTree() { return this.stateManager.getRawUrlTree() } get events() { return this._events } get routerState() { return this.stateManager.getRouterState() } constructor() { this.disposed = !1, this.console = b(Bb), this.stateManager = b(QI), this.options = b(Pi, { optional: !0 }) || {}, this.pendingTasks = b(cr), this.urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred", this.navigationTransitions = b(Su), this.urlSerializer = b(Ti), this.location = b(sa), this.urlHandlingStrategy = b(Vg), this._events = new It, this.errorHandler = this.options.errorHandler || T3, this.navigated = !1, this.routeReuseStrategy = b(E3), this.onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore", this.config = b(Fi, { optional: !0 })?.flat() ?? [], this.componentInputBindingEnabled = !!b(Du, { optional: !0 }), this.eventsSubscription = new at, this.resetConfig(this.config), this.navigationTransitions.setupNavigations(this, this.currentUrlTree, this.routerState).subscribe({ error: t => { this.console.warn(t) } }), this.subscribeToNavigationEvents() } subscribeToNavigationEvents() { const t = this.navigationTransitions.events.subscribe(r => { try { const o = this.navigationTransitions.currentTransition, i = this.navigationTransitions.currentNavigation; if (null !== o && null !== i) if (this.stateManager.handleRouterEvent(r, i), r instanceof so && r.code !== Lt.Redirect && r.code !== Lt.SupersededByNewNavigation) this.navigated = !0; else if (r instanceof tr) this.navigated = !0; else if (r instanceof yu) { const s = r.navigationBehaviorOptions, a = this.urlHandlingStrategy.merge(r.url, o.currentRawUrl), c = { browserUrl: o.extras.browserUrl, info: o.extras.info, skipLocationChange: o.extras.skipLocationChange, replaceUrl: o.extras.replaceUrl || "eager" === this.urlUpdateStrategy || b3(o.source), ...s }; this.scheduleNavigation(a, ya, null, c, { resolve: o.resolve, reject: o.reject, promise: o.promise }) } (function x3(e) { return !(e instanceof Eg || e instanceof yu) })(r) && this._events.next(r) } catch (o) { this.navigationTransitions.transitionAbortSubject.next(o) } }); this.eventsSubscription.add(t) } resetRootComponentType(t) { this.routerState.root.component = t, this.navigationTransitions.rootComponentType = t } initialNavigation() { this.setUpLocationChangeListener(), this.navigationTransitions.hasRequestedNavigation || this.navigateToSyncWithBrowser(this.location.path(!0), ya, this.stateManager.restoredState()) } setUpLocationChangeListener() { this.nonRouterCurrentEntryChangeSubscription ??= this.stateManager.registerNonRouterCurrentEntryChangeListener((t, r) => { setTimeout(() => { this.navigateToSyncWithBrowser(t, "popstate", r) }, 0) }) } navigateToSyncWithBrowser(t, r, o) { const i = { replaceUrl: !0 }, s = o?.navigationId ? o : null; if (o) { const c = { ...o }; delete c.navigationId, delete c.\u0275routerPageId, 0 !== Object.keys(c).length && (i.state = c) } const a = this.parseUrl(t); this.scheduleNavigation(a, r, s, i) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.navigationTransitions.currentNavigation } get lastSuccessfulNavigation() { return this.navigationTransitions.lastSuccessfulNavigation } resetConfig(t) { this.config = t.map(kg), this.navigated = !1 } ngOnDestroy() { this.dispose() } dispose() { this.navigationTransitions.complete(), this.nonRouterCurrentEntryChangeSubscription && (this.nonRouterCurrentEntryChangeSubscription.unsubscribe(), this.nonRouterCurrentEntryChangeSubscription = void 0), this.disposed = !0, this.eventsSubscription.unsubscribe() } createUrlTree(t, r = {}) { const { relativeTo: o, queryParams: i, fragment: s, queryParamsHandling: a, preserveFragment: c } = r, l = c ? this.currentUrlTree.fragment : s; let d, u = null; switch (a ?? this.options.defaultQueryParamsHandling) { case "merge": u = { ...this.currentUrlTree.queryParams, ...i }; break; case "preserve": u = this.currentUrlTree.queryParams; break; default: u = i || null }null !== u && (u = this.removeEmptyProps(u)); try { d = gI(o ? o.snapshot : this.routerState.snapshot.root) } catch { ("string" != typeof t[0] || "/" !== t[0][0]) && (t = []), d = this.currentUrlTree.root } return mI(d, t, u, l ?? null) } navigateByUrl(t, r = { skipLocationChange: !1 }) { const o = io(t) ? t : this.parseUrl(t), i = this.urlHandlingStrategy.merge(o, this.rawUrlTree); return this.scheduleNavigation(i, ya, null, r) } navigate(t, r = { skipLocationChange: !1 }) { return function O3(e) { for (let n = 0; n < e.length; n++)if (null == e[n]) throw new w(4008, !1) }(t), this.navigateByUrl(this.createUrlTree(t, r), r) } serializeUrl(t) { return this.urlSerializer.serialize(t) } parseUrl(t) { try { return this.urlSerializer.parse(t) } catch { return this.urlSerializer.parse("/") } } isActive(t, r) { let o; if (o = !0 === r ? { ...A3 } : !1 === r ? { ...N3 } : r, io(t)) return sI(this.currentUrlTree, t, o); const i = this.parseUrl(t); return sI(this.currentUrlTree, i, o) } removeEmptyProps(t) { return Object.entries(t).reduce((r, [o, i]) => (null != i && (r[o] = i), r), {}) } scheduleNavigation(t, r, o, i, s) { if (this.disposed) return Promise.resolve(!1); let a, c, l; s ? (a = s.resolve, c = s.reject, l = s.promise) : l = new Promise((d, f) => { a = d, c = f }); const u = this.pendingTasks.add(); return YI(this, () => { queueMicrotask(() => this.pendingTasks.remove(u)) }), this.navigationTransitions.handleNavigationRequest({ source: r, restoredState: o, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, rawUrl: t, extras: i, resolve: a, reject: c, promise: l, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), l.catch(d => Promise.reject(d)) } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(), Ia = (() => { class e { constructor(t, r, o, i, s, a) { this.router = t, this.route = r, this.tabIndexAttribute = o, this.renderer = i, this.el = s, this.locationStrategy = a, this.href = null, this.onChanges = new It, this.preserveFragment = !1, this.skipLocationChange = !1, this.replaceUrl = !1, this.routerLinkInput = null; const c = s.nativeElement.tagName?.toLowerCase(); this.isAnchorElement = "a" === c || "area" === c, this.isAnchorElement ? this.subscription = t.events.subscribe(l => { l instanceof tr && this.updateHref() }) : this.setTabIndexIfNotOnNativeEl("0") } setTabIndexIfNotOnNativeEl(t) { null != this.tabIndexAttribute || this.isAnchorElement || this.applyAttributeValue("tabindex", t) } ngOnChanges(t) { this.isAnchorElement && this.updateHref(), this.onChanges.next(this) } set routerLink(t) { null == t ? (this.routerLinkInput = null, this.setTabIndexIfNotOnNativeEl(null)) : (this.routerLinkInput = io(t) || Array.isArray(t) ? t : [t], this.setTabIndexIfNotOnNativeEl("0")) } onClick(t, r, o, i, s) { const a = this.urlTree; return !!(null === a || this.isAnchorElement && (0 !== t || r || o || i || s || "string" == typeof this.target && "_self" != this.target)) || (this.router.navigateByUrl(a, { skipLocationChange: this.skipLocationChange, replaceUrl: this.replaceUrl, state: this.state, info: this.info }), !this.isAnchorElement) } ngOnDestroy() { this.subscription?.unsubscribe() } updateHref() { const t = this.urlTree; this.href = null !== t && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(t)) : null; const r = null === this.href ? null : function l_(e, n, t) { return function N1(e, n) { return "src" === n && ("embed" === e || "frame" === e || "iframe" === e || "media" === e || "script" === e) || "href" === n && ("base" === e || "link" === e) ? c_ : en }(n, t)(e) }(this.href, this.el.nativeElement.tagName.toLowerCase(), "href"); this.applyAttributeValue("href", r) } applyAttributeValue(t, r) { const o = this.renderer, i = this.el.nativeElement; null !== r ? o.setAttribute(i, t, r) : o.removeAttribute(i, t) } get urlTree() { return null === this.routerLinkInput ? null : io(this.routerLinkInput) ? this.routerLinkInput : this.router.createUrlTree(this.routerLinkInput, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: this.preserveFragment }) } static { this.\u0275fac = function (r) { return new (r || e)(M(Mt), M(ao), function os(e) { return function JA(e, n) { if ("class" === n) return e.classes; if ("style" === n) return e.styles; const t = e.attrs; if (t) { const r = t.length; let o = 0; for (; o < r;) { const i = t[o]; if (Jm(i)) break; if (0 === i) o += 2; else if ("number" == typeof i) for (o++; o < r && "string" == typeof t[o];)o++; else { if (i === n) return t[o + 1]; o += 2 } } } return null }(le(), e) }("tabindex"), M(Qn), M(Ot), M(eo)) } } static { this.\u0275dir = $({ type: e, selectors: [["", "routerLink", ""]], hostVars: 1, hostBindings: function (r, o) { 1 & r && re("click", function (s) { return o.onClick(s.button, s.ctrlKey, s.shiftKey, s.altKey, s.metaKey) }), 2 & r && nn("target", o.target) }, inputs: { target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", state: "state", info: "info", relativeTo: "relativeTo", preserveFragment: [2, "preserveFragment", "preserveFragment", _i], skipLocationChange: [2, "skipLocationChange", "skipLocationChange", _i], replaceUrl: [2, "replaceUrl", "replaceUrl", _i], routerLink: "routerLink" }, standalone: !0, features: [cD, Bt] }) } } return e })(), jg = (() => { class e { get isActive() { return this._isActive } constructor(t, r, o, i, s) { this.router = t, this.element = r, this.renderer = o, this.cdr = i, this.link = s, this.classes = [], this._isActive = !1, this.routerLinkActiveOptions = { exact: !1 }, this.isActiveChange = new Te, this.routerEventsSubscription = t.events.subscribe(a => { a instanceof tr && this.update() }) } ngAfterContentInit() { U(this.links.changes, U(null)).pipe(fa()).subscribe(t => { this.update(), this.subscribeToEachLinkOnChanges() }) } subscribeToEachLinkOnChanges() { this.linkInputChangesSubscription?.unsubscribe(); const t = [...this.links.toArray(), this.link].filter(r => !!r).map(r => r.onChanges); this.linkInputChangesSubscription = Qe(t).pipe(fa()).subscribe(r => { this._isActive !== this.isLinkActive(this.router)(r) && this.update() }) } set routerLinkActive(t) { const r = Array.isArray(t) ? t : t.split(" "); this.classes = r.filter(o => !!o) } ngOnChanges(t) { this.update() } ngOnDestroy() { this.routerEventsSubscription.unsubscribe(), this.linkInputChangesSubscription?.unsubscribe() } update() { !this.links || !this.router.navigated || queueMicrotask(() => { const t = this.hasActiveLinks(); this.classes.forEach(r => { t ? this.renderer.addClass(this.element.nativeElement, r) : this.renderer.removeClass(this.element.nativeElement, r) }), t && void 0 !== this.ariaCurrentWhenActive ? this.renderer.setAttribute(this.element.nativeElement, "aria-current", this.ariaCurrentWhenActive.toString()) : this.renderer.removeAttribute(this.element.nativeElement, "aria-current"), this._isActive !== t && (this._isActive = t, this.cdr.markForCheck(), this.isActiveChange.emit(t)) }) } isLinkActive(t) { const r = function R3(e) { return !!e.paths }(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : this.routerLinkActiveOptions.exact || !1; return o => { const i = o.urlTree; return !!i && t.isActive(i, r) } } hasActiveLinks() { const t = this.isLinkActive(this.router); return this.link && t(this.link) || this.links.some(t) } static { this.\u0275fac = function (r) { return new (r || e)(M(Mt), M(Ot), M(Qn), M(ta), M(Ia, 8)) } } static { this.\u0275dir = $({ type: e, selectors: [["", "routerLinkActive", ""]], contentQueries: function (r, o, i) { if (1 & r && function Ww(e, n, t, r) { BC(e, n, t, r) }(i, Ia, 5), 2 & r) { let s; (function Zw(e) { const n = C(), t = Z(), r = Xd(); mc(r + 1); const o = Rh(t, r); if (e.dirty && function wA(e) { return !(4 & ~e[R]) }(n) === !(2 & ~o.metadata.flags)) { if (null === o.matches) e.reset([]); else { const i = $C(n, r); e.reset(i, my), e.notifyOnChanges() } return !0 } return !1 })(s = Qw()) && (o.links = s) } }, inputs: { routerLinkActiveOptions: "routerLinkActiveOptions", ariaCurrentWhenActive: "ariaCurrentWhenActive", routerLinkActive: "routerLinkActive" }, outputs: { isActiveChange: "isActiveChange" }, exportAs: ["routerLinkActive"], standalone: !0, features: [Bt] }) } } return e })(); class JI { } let P3 = (() => { class e { constructor(t, r, o, i, s) { this.router = t, this.injector = o, this.preloadingStrategy = i, this.loader = s } setUpPreloading() { this.subscription = this.router.events.pipe(er(t => t instanceof tr), Mi(() => this.preload())).subscribe(() => { }) } preload() { return this.processRoutes(this.injector, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(t, r) { const o = []; for (const i of r) { i.providers && !i._injector && (i._injector = sl(i.providers, t, `Route: ${i.path}`)); const s = i._injector ?? t, a = i._loadedInjector ?? s; (i.loadChildren && !i._loadedRoutes && void 0 === i.canLoad || i.loadComponent && !i._loadedComponent) && o.push(this.preloadConfig(s, i)), (i.children || i._loadedRoutes) && o.push(this.processRoutes(a, i.children ?? i._loadedRoutes)) } return Qe(o).pipe(fa()) } preloadConfig(t, r) { return this.preloadingStrategy.preload(r, () => { let o; o = r.loadChildren && void 0 === r.canLoad ? this.loader.loadChildren(t, r) : U(null); const i = o.pipe(it(s => null === s ? U(void 0) : (r._loadedRoutes = s.routes, r._loadedInjector = s.injector, this.processRoutes(s.injector ?? t, s.routes)))); return r.loadComponent && !r._loadedComponent ? Qe([i, this.loader.loadComponent(r)]).pipe(fa()) : i }) } static { this.\u0275fac = function (r) { return new (r || e)(x(Mt), x(Jb), x(lt), x(JI), x(Lg)) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); const Bg = new T(""); let XI = (() => { class e { constructor(t, r, o, i, s = {}) { this.urlSerializer = t, this.transitions = r, this.viewportScroller = o, this.zone = i, this.options = s, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, s.scrollPositionRestoration ||= "disabled", s.anchorScrolling ||= "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.transitions.events.subscribe(t => { t instanceof mu ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = t.navigationTrigger, this.restoredId = t.restoredState ? t.restoredState.navigationId : 0) : t instanceof tr ? (this.lastId = t.id, this.scheduleScrollEvent(t, this.urlSerializer.parse(t.urlAfterRedirects).fragment)) : t instanceof Ai && t.code === vu.IgnoredSameUrlNavigation && (this.lastSource = void 0, this.restoredId = 0, this.scheduleScrollEvent(t, this.urlSerializer.parse(t.url).fragment)) }) } consumeScrollEvents() { return this.transitions.events.subscribe(t => { t instanceof bI && (t.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(t.position) : t.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(t.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(t, r) { this.zone.runOutsideAngular(() => { setTimeout(() => { this.zone.run(() => { this.transitions.events.next(new bI(t, "popstate" === this.lastSource ? this.store[this.restoredId] : null, r)) }) }, 0) }) } ngOnDestroy() { this.routerEventsSubscription?.unsubscribe(), this.scrollEventsSubscription?.unsubscribe() } static { this.\u0275fac = function (r) { !function P_() { throw new Error("invalid") }() } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac }) } } return e })(); function KI(e) { return e.routerState.root } function Ln(e, n) { return { \u0275kind: e, \u0275providers: n } } function e0() { const e = b(Je); return n => { const t = e.get(On); if (n !== t.components[0]) return; const r = e.get(Mt), o = e.get(t0); 1 === e.get(Ug) && r.initialNavigation(), e.get(n0, null, J.Optional)?.setUpPreloading(), e.get(Bg, null, J.Optional)?.init(), r.resetRootComponentType(t.componentTypes[0]), o.closed || (o.next(), o.complete(), o.unsubscribe()) } } const t0 = new T("", { factory: () => new It }), Ug = new T("", { providedIn: "root", factory: () => 1 }), n0 = new T(""); function j3(e) { return Ln(0, [{ provide: n0, useExisting: P3 }, { provide: JI, useExisting: e }]) } function U3(e) { return Ln(9, [{ provide: qI, useValue: D3 }, { provide: WI, useValue: { skipNextTransition: !!e?.skipInitialTransition, ...e } }]) } const r0 = new T("ROUTER_FORROOT_GUARD"), $3 = [sa, { provide: Ti, useClass: uu }, Mt, Ca, { provide: ao, useFactory: KI, deps: [Mt] }, Lg, []]; let $g = (() => { class e { constructor(t) { } static forRoot(t, r) { return { ngModule: e, providers: [$3, [], { provide: Fi, multi: !0, useValue: t }, { provide: r0, useFactory: q3, deps: [[Mt, new Ja, new Xa]] }, { provide: Pi, useValue: r || {} }, r?.useHash ? { provide: eo, useClass: sV } : { provide: eo, useClass: $E }, { provide: Bg, useFactory: () => { const e = b(wj), n = b(ie), t = b(Pi), r = b(Su), o = b(Ti); return t.scrollOffset && e.setOffset(t.scrollOffset), new XI(o, r, e, n, t) } }, r?.preloadingStrategy ? j3(r.preloadingStrategy).\u0275providers : [], r?.initialNavigation ? W3(r) : [], r?.bindToComponentInputs ? Ln(8, [NI, { provide: Du, useExisting: NI }]).\u0275providers : [], r?.enableViewTransitions ? U3().\u0275providers : [], [{ provide: o0, useFactory: e0 }, { provide: Ks, multi: !0, useExisting: o0 }]] } } static forChild(t) { return { ngModule: e, providers: [{ provide: Fi, multi: !0, useValue: t }] } } static { this.\u0275fac = function (r) { return new (r || e)(x(r0, 8)) } } static { this.\u0275mod = bo({ type: e }) } static { this.\u0275inj = Ar({}) } } return e })(); function q3(e) { return "guarded" } function W3(e) { return ["disabled" === e.initialNavigation ? Ln(3, [{ provide: bp, multi: !0, useFactory: () => { const n = b(Mt); return () => { n.setUpLocationChangeListener() } } }, { provide: Ug, useValue: 2 }]).\u0275providers : [], "enabledBlocking" === e.initialNavigation ? Ln(2, [{ provide: Ug, useValue: 0 }, { provide: bp, multi: !0, deps: [Je], useFactory: n => { const t = n.get(oV, Promise.resolve()); return () => t.then(() => new Promise(r => { const o = n.get(Mt), i = n.get(t0); YI(o, () => { r(!0) }), n.get(Su).afterPreactivation = () => (r(!0), i.closed ? U(void 0) : i), o.initialNavigation() })) } }]).\u0275providers : []] } const o0 = new T(""); let Q3 = (() => { class e { static \u0275fac = function (r) { return new (r || e) }; static \u0275cmp = gn({ type: e, selectors: [["app-home"]], standalone: !0, features: [Nn], decls: 2, vars: 0, template: function (r, o) { 1 & r && (y(0, "p"), E(1, "home works!"), m()) } }) } return e })(), s0 = (() => { class e { constructor(t, r) { this._renderer = t, this._elementRef = r, this.onChange = o => { }, this.onTouched = () => { } } setProperty(t, r) { this._renderer.setProperty(this._elementRef.nativeElement, t, r) } registerOnTouched(t) { this.onTouched = t } registerOnChange(t) { this.onChange = t } setDisabledState(t) { this.setProperty("disabled", t) } static { this.\u0275fac = function (r) { return new (r || e)(M(Qn), M(Ot)) } } static { this.\u0275dir = $({ type: e }) } } return e })(), co = (() => { class e extends s0 { static { this.\u0275fac = (() => { let t; return function (o) { return (t || (t = Ye(e)))(o || e) } })() } static { this.\u0275dir = $({ type: e, features: [ue] }) } } return e })(); const Vn = new T(""), X3 = { provide: Vn, useExisting: pe(() => Sa), multi: !0 }, eH = new T(""); let Sa = (() => { class e extends s0 { constructor(t, r, o) { super(t, r), this._compositionMode = o, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function K3() { const e = vr() ? vr().getUserAgent() : ""; return /android (\d+)/.test(e.toLowerCase()) }()) } writeValue(t) { this.setProperty("value", t ?? "") } _handleInput(t) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(t) } _compositionStart() { this._composing = !0 } _compositionEnd(t) { this._composing = !1, this._compositionMode && this.onChange(t) } static { this.\u0275fac = function (r) { return new (r || e)(M(Qn), M(Ot), M(eH, 8)) } } static { this.\u0275dir = $({ type: e, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (r, o) { 1 & r && re("input", function (s) { return o._handleInput(s.target.value) })("blur", function () { return o.onTouched() })("compositionstart", function () { return o._compositionStart() })("compositionend", function (s) { return o._compositionEnd(s.target.value) }) }, features: [Ee([X3]), ue] }) } } return e })(); const st = new T(""), Dr = new T(""); function d0(e) { return function Cr(e) { return null == e || ("string" == typeof e || Array.isArray(e)) && 0 === e.length }(e.value) ? { required: !0 } : null } function Tu(e) { return null } function v0(e) { return null != e } function y0(e) { return Xs(e) ? Qe(e) : e } function _0(e) { let n = {}; return e.forEach(t => { n = null != t ? { ...n, ...t } : n }), 0 === Object.keys(n).length ? null : n } function C0(e, n) { return n.map(t => t(e)) } function D0(e) { return e.map(n => function nH(e) { return !e.validate }(n) ? n : t => n.validate(t)) } function Hg(e) { return null != e ? function w0(e) { if (!e) return null; const n = e.filter(v0); return 0 == n.length ? null : function (t) { return _0(C0(t, n)) } }(D0(e)) : null } function Gg(e) { return null != e ? function b0(e) { if (!e) return null; const n = e.filter(v0); return 0 == n.length ? null : function (t) { return function Y3(...e) { const n = QM(e), { args: t, keys: r } = YM(e), o = new ke(i => { const { length: s } = t; if (!s) return void i.complete(); const a = new Array(s); let c = s, l = s; for (let u = 0; u < s; u++) { let d = !1; Rn(t[u]).subscribe(Ue(i, f => { d || (d = !0, l--), a[u] = f }, () => c--, void 0, () => { (!c || !d) && (l || i.next(r ? XM(r, a) : a), i.complete()) })) } }); return n ? o.pipe(JM(n)) : o }(C0(t, n).map(y0)).pipe(K(_0)) } }(D0(e)) : null } function E0(e, n) { return null === e ? [n] : Array.isArray(e) ? [...e, n] : [e, n] } function zg(e) { return e ? Array.isArray(e) ? e : [e] : [] } function Au(e, n) { return Array.isArray(e) ? e.includes(n) : e === n } function S0(e, n) { const t = zg(n); return zg(e).forEach(o => { Au(t, o) || t.push(o) }), t } function T0(e, n) { return zg(n).filter(t => !Au(e, t)) } class A0 { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(n) { this._rawValidators = n || [], this._composedValidatorFn = Hg(this._rawValidators) } _setAsyncValidators(n) { this._rawAsyncValidators = n || [], this._composedAsyncValidatorFn = Gg(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(n) { this._onDestroyCallbacks.push(n) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(n => n()), this._onDestroyCallbacks = [] } reset(n = void 0) { this.control && this.control.reset(n) } hasError(n, t) { return !!this.control && this.control.hasError(n, t) } getError(n, t) { return this.control ? this.control.getError(n, t) : null } } class yt extends A0 { get formDirective() { return null } get path() { return null } } class wr extends A0 { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class N0 { constructor(n) { this._cd = n } get isTouched() { return this._cd?.control?._touched?.(), !!this._cd?.control?.touched } get isUntouched() { return !!this._cd?.control?.untouched } get isPristine() { return this._cd?.control?._pristine?.(), !!this._cd?.control?.pristine } get isDirty() { return !!this._cd?.control?.dirty } get isValid() { return this._cd?.control?._status?.(), !!this._cd?.control?.valid } get isInvalid() { return !!this._cd?.control?.invalid } get isPending() { return !!this._cd?.control?.pending } get isSubmitted() { return this._cd?._submitted?.(), !!this._cd?.submitted } } let qg = (() => { class e extends N0 { constructor(t) { super(t) } static { this.\u0275fac = function (r) { return new (r || e)(M(wr, 2)) } } static { this.\u0275dir = $({ type: e, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (r, o) { 2 & r && pi("ng-untouched", o.isUntouched)("ng-touched", o.isTouched)("ng-pristine", o.isPristine)("ng-dirty", o.isDirty)("ng-valid", o.isValid)("ng-invalid", o.isInvalid)("ng-pending", o.isPending) }, features: [ue] }) } } return e })(), O0 = (() => { class e extends N0 { constructor(t) { super(t) } static { this.\u0275fac = function (r) { return new (r || e)(M(yt, 10)) } } static { this.\u0275dir = $({ type: e, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 16, hostBindings: function (r, o) { 2 & r && pi("ng-untouched", o.isUntouched)("ng-touched", o.isTouched)("ng-pristine", o.isPristine)("ng-dirty", o.isDirty)("ng-valid", o.isValid)("ng-invalid", o.isInvalid)("ng-pending", o.isPending)("ng-submitted", o.isSubmitted) }, features: [ue] }) } } return e })(); const Ta = "VALID", Ou = "INVALID", ki = "PENDING", Aa = "DISABLED"; class Li { } class R0 extends Li { constructor(n, t) { super(), this.value = n, this.source = t } } class Qg extends Li { constructor(n, t) { super(), this.pristine = n, this.source = t } } class Yg extends Li { constructor(n, t) { super(), this.touched = n, this.source = t } } class xu extends Li { constructor(n, t) { super(), this.status = n, this.source = t } } function Jg(e) { return (Ru(e) ? e.validators : e) || null } function Xg(e, n) { return (Ru(n) ? n.asyncValidators : e) || null } function Ru(e) { return null != e && !Array.isArray(e) && "object" == typeof e } class Kg { constructor(n, t) { this._pendingDirty = !1, this._hasOwnPendingAsyncValidator = null, this._pendingTouched = !1, this._onCollectionChange = () => { }, this._parent = null, this._status = ia(() => this.statusReactive()), this.statusReactive = Wo(void 0), this._pristine = ia(() => this.pristineReactive()), this.pristineReactive = Wo(!0), this._touched = ia(() => this.touchedReactive()), this.touchedReactive = Wo(!1), this._events = new It, this.events = this._events.asObservable(), this._onDisabledChange = [], this._assignValidators(n), this._assignAsyncValidators(t) } get validator() { return this._composedValidatorFn } set validator(n) { this._rawValidators = this._composedValidatorFn = n } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(n) { this._rawAsyncValidators = this._composedAsyncValidatorFn = n } get parent() { return this._parent } get status() { return xn(this.statusReactive) } set status(n) { xn(() => this.statusReactive.set(n)) } get valid() { return this.status === Ta } get invalid() { return this.status === Ou } get pending() { return this.status == ki } get disabled() { return this.status === Aa } get enabled() { return this.status !== Aa } get pristine() { return xn(this.pristineReactive) } set pristine(n) { xn(() => this.pristineReactive.set(n)) } get dirty() { return !this.pristine } get touched() { return xn(this.touchedReactive) } set touched(n) { xn(() => this.touchedReactive.set(n)) } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(n) { this._assignValidators(n) } setAsyncValidators(n) { this._assignAsyncValidators(n) } addValidators(n) { this.setValidators(S0(n, this._rawValidators)) } addAsyncValidators(n) { this.setAsyncValidators(S0(n, this._rawAsyncValidators)) } removeValidators(n) { this.setValidators(T0(n, this._rawValidators)) } removeAsyncValidators(n) { this.setAsyncValidators(T0(n, this._rawAsyncValidators)) } hasValidator(n) { return Au(this._rawValidators, n) } hasAsyncValidator(n) { return Au(this._rawAsyncValidators, n) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(n = {}) { const t = !1 === this.touched; this.touched = !0; const r = n.sourceControl ?? this; this._parent && !n.onlySelf && this._parent.markAsTouched({ ...n, sourceControl: r }), t && !1 !== n.emitEvent && this._events.next(new Yg(!0, r)) } markAllAsTouched(n = {}) { this.markAsTouched({ onlySelf: !0, emitEvent: n.emitEvent, sourceControl: this }), this._forEachChild(t => t.markAllAsTouched(n)) } markAsUntouched(n = {}) { const t = !0 === this.touched; this.touched = !1, this._pendingTouched = !1; const r = n.sourceControl ?? this; this._forEachChild(o => { o.markAsUntouched({ onlySelf: !0, emitEvent: n.emitEvent, sourceControl: r }) }), this._parent && !n.onlySelf && this._parent._updateTouched(n, r), t && !1 !== n.emitEvent && this._events.next(new Yg(!1, r)) } markAsDirty(n = {}) { const t = !0 === this.pristine; this.pristine = !1; const r = n.sourceControl ?? this; this._parent && !n.onlySelf && this._parent.markAsDirty({ ...n, sourceControl: r }), t && !1 !== n.emitEvent && this._events.next(new Qg(!1, r)) } markAsPristine(n = {}) { const t = !1 === this.pristine; this.pristine = !0, this._pendingDirty = !1; const r = n.sourceControl ?? this; this._forEachChild(o => { o.markAsPristine({ onlySelf: !0, emitEvent: n.emitEvent }) }), this._parent && !n.onlySelf && this._parent._updatePristine(n, r), t && !1 !== n.emitEvent && this._events.next(new Qg(!0, r)) } markAsPending(n = {}) { this.status = ki; const t = n.sourceControl ?? this; !1 !== n.emitEvent && (this._events.next(new xu(this.status, t)), this.statusChanges.emit(this.status)), this._parent && !n.onlySelf && this._parent.markAsPending({ ...n, sourceControl: t }) } disable(n = {}) { const t = this._parentMarkedDirty(n.onlySelf); this.status = Aa, this.errors = null, this._forEachChild(o => { o.disable({ ...n, onlySelf: !0 }) }), this._updateValue(); const r = n.sourceControl ?? this; !1 !== n.emitEvent && (this._events.next(new R0(this.value, r)), this._events.next(new xu(this.status, r)), this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors({ ...n, skipPristineCheck: t }, this), this._onDisabledChange.forEach(o => o(!0)) } enable(n = {}) { const t = this._parentMarkedDirty(n.onlySelf); this.status = Ta, this._forEachChild(r => { r.enable({ ...n, onlySelf: !0 }) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: n.emitEvent }), this._updateAncestors({ ...n, skipPristineCheck: t }, this), this._onDisabledChange.forEach(r => r(!1)) } _updateAncestors(n, t) { this._parent && !n.onlySelf && (this._parent.updateValueAndValidity(n), n.skipPristineCheck || this._parent._updatePristine({}, t), this._parent._updateTouched({}, t)) } setParent(n) { this._parent = n } getRawValue() { return this.value } updateValueAndValidity(n = {}) { if (this._setInitialStatus(), this._updateValue(), this.enabled) { const r = this._cancelExistingSubscription(); this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === Ta || this.status === ki) && this._runAsyncValidator(r, n.emitEvent) } const t = n.sourceControl ?? this; !1 !== n.emitEvent && (this._events.next(new R0(this.value, t)), this._events.next(new xu(this.status, t)), this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !n.onlySelf && this._parent.updateValueAndValidity({ ...n, sourceControl: t }) } _updateTreeValidity(n = { emitEvent: !0 }) { this._forEachChild(t => t._updateTreeValidity(n)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: n.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? Aa : Ta } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(n, t) { if (this.asyncValidator) { this.status = ki, this._hasOwnPendingAsyncValidator = { emitEvent: !1 !== t }; const r = y0(this.asyncValidator(this)); this._asyncValidationSubscription = r.subscribe(o => { this._hasOwnPendingAsyncValidator = null, this.setErrors(o, { emitEvent: t, shouldHaveEmitted: n }) }) } } _cancelExistingSubscription() { if (this._asyncValidationSubscription) { this._asyncValidationSubscription.unsubscribe(); const n = this._hasOwnPendingAsyncValidator?.emitEvent ?? !1; return this._hasOwnPendingAsyncValidator = null, n } return !1 } setErrors(n, t = {}) { this.errors = n, this._updateControlsErrors(!1 !== t.emitEvent, this, t.shouldHaveEmitted) } get(n) { let t = n; return null == t || (Array.isArray(t) || (t = t.split(".")), 0 === t.length) ? null : t.reduce((r, o) => r && r._find(o), this) } getError(n, t) { const r = t ? this.get(t) : this; return r && r.errors ? r.errors[n] : null } hasError(n, t) { return !!this.getError(n, t) } get root() { let n = this; for (; n._parent;)n = n._parent; return n } _updateControlsErrors(n, t, r) { this.status = this._calculateStatus(), n && this.statusChanges.emit(this.status), (n || r) && this._events.next(new xu(this.status, t)), this._parent && this._parent._updateControlsErrors(n, t, r) } _initObservables() { this.valueChanges = new Te, this.statusChanges = new Te } _calculateStatus() { return this._allControlsDisabled() ? Aa : this.errors ? Ou : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(ki) ? ki : this._anyControlsHaveStatus(Ou) ? Ou : Ta } _anyControlsHaveStatus(n) { return this._anyControls(t => t.status === n) } _anyControlsDirty() { return this._anyControls(n => n.dirty) } _anyControlsTouched() { return this._anyControls(n => n.touched) } _updatePristine(n, t) { const r = !this._anyControlsDirty(), o = this.pristine !== r; this.pristine = r, this._parent && !n.onlySelf && this._parent._updatePristine(n, t), o && this._events.next(new Qg(this.pristine, t)) } _updateTouched(n = {}, t) { this.touched = this._anyControlsTouched(), this._events.next(new Yg(this.touched, t)), this._parent && !n.onlySelf && this._parent._updateTouched(n, t) } _registerOnCollectionChange(n) { this._onCollectionChange = n } _setUpdateStrategy(n) { Ru(n) && null != n.updateOn && (this._updateOn = n.updateOn) } _parentMarkedDirty(n) { return !n && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } _find(n) { return null } _assignValidators(n) { this._rawValidators = Array.isArray(n) ? n.slice() : n, this._composedValidatorFn = function lH(e) { return Array.isArray(e) ? Hg(e) : e || null }(this._rawValidators) } _assignAsyncValidators(n) { this._rawAsyncValidators = Array.isArray(n) ? n.slice() : n, this._composedAsyncValidatorFn = function uH(e) { return Array.isArray(e) ? Gg(e) : e || null }(this._rawAsyncValidators) } } class em extends Kg { constructor(n, t, r) { super(Jg(t), Xg(r, t)), this.controls = n, this._initObservables(), this._setUpdateStrategy(t), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } registerControl(n, t) { return this.controls[n] ? this.controls[n] : (this.controls[n] = t, t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange), t) } addControl(n, t, r = {}) { this.registerControl(n, t), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } removeControl(n, t = {}) { this.controls[n] && this.controls[n]._registerOnCollectionChange(() => { }), delete this.controls[n], this.updateValueAndValidity({ emitEvent: t.emitEvent }), this._onCollectionChange() } setControl(n, t, r = {}) { this.controls[n] && this.controls[n]._registerOnCollectionChange(() => { }), delete this.controls[n], t && this.registerControl(n, t), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } contains(n) { return this.controls.hasOwnProperty(n) && this.controls[n].enabled } setValue(n, t = {}) { (function F0(e, n, t) { e._forEachChild((r, o) => { if (void 0 === t[o]) throw new w(1002, "") }) })(this, 0, n), Object.keys(n).forEach(r => { (function P0(e, n, t) { const r = e.controls; if (!(n ? Object.keys(r) : r).length) throw new w(1e3, ""); if (!r[t]) throw new w(1001, "") })(this, !0, r), this.controls[r].setValue(n[r], { onlySelf: !0, emitEvent: t.emitEvent }) }), this.updateValueAndValidity(t) } patchValue(n, t = {}) { null != n && (Object.keys(n).forEach(r => { const o = this.controls[r]; o && o.patchValue(n[r], { onlySelf: !0, emitEvent: t.emitEvent }) }), this.updateValueAndValidity(t)) } reset(n = {}, t = {}) { this._forEachChild((r, o) => { r.reset(n ? n[o] : null, { onlySelf: !0, emitEvent: t.emitEvent }) }), this._updatePristine(t, this), this._updateTouched(t, this), this.updateValueAndValidity(t) } getRawValue() { return this._reduceChildren({}, (n, t, r) => (n[r] = t.getRawValue(), n)) } _syncPendingControls() { let n = this._reduceChildren(!1, (t, r) => !!r._syncPendingControls() || t); return n && this.updateValueAndValidity({ onlySelf: !0 }), n } _forEachChild(n) { Object.keys(this.controls).forEach(t => { const r = this.controls[t]; r && n(r, t) }) } _setUpControls() { this._forEachChild(n => { n.setParent(this), n._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(n) { for (const [t, r] of Object.entries(this.controls)) if (this.contains(t) && n(r)) return !0; return !1 } _reduceValue() { return this._reduceChildren({}, (t, r, o) => ((r.enabled || this.disabled) && (t[o] = r.value), t)) } _reduceChildren(n, t) { let r = n; return this._forEachChild((o, i) => { r = t(r, o, i) }), r } _allControlsDisabled() { for (const n of Object.keys(this.controls)) if (this.controls[n].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _find(n) { return this.controls.hasOwnProperty(n) ? this.controls[n] : null } } const Vi = new T("CallSetDisabledState", { providedIn: "root", factory: () => Pu }), Pu = "always"; function Na(e, n, t = Pu) { tm(e, n), n.valueAccessor.writeValue(e.value), (e.disabled || "always" === t) && n.valueAccessor.setDisabledState?.(e.disabled), function hH(e, n) { n.valueAccessor.registerOnChange(t => { e._pendingValue = t, e._pendingChange = !0, e._pendingDirty = !0, "change" === e.updateOn && k0(e, n) }) }(e, n), function gH(e, n) { const t = (r, o) => { n.valueAccessor.writeValue(r), o && n.viewToModelUpdate(r) }; e.registerOnChange(t), n._registerOnDestroy(() => { e._unregisterOnChange(t) }) }(e, n), function pH(e, n) { n.valueAccessor.registerOnTouched(() => { e._pendingTouched = !0, "blur" === e.updateOn && e._pendingChange && k0(e, n), "submit" !== e.updateOn && e.markAsTouched() }) }(e, n), function fH(e, n) { if (n.valueAccessor.setDisabledState) { const t = r => { n.valueAccessor.setDisabledState(r) }; e.registerOnDisabledChange(t), n._registerOnDestroy(() => { e._unregisterOnDisabledChange(t) }) } }(e, n) } function Lu(e, n) { e.forEach(t => { t.registerOnValidatorChange && t.registerOnValidatorChange(n) }) } function tm(e, n) { const t = function M0(e) { return e._rawValidators }(e); null !== n.validator ? e.setValidators(E0(t, n.validator)) : "function" == typeof t && e.setValidators([t]); const r = function I0(e) { return e._rawAsyncValidators }(e); null !== n.asyncValidator ? e.setAsyncValidators(E0(r, n.asyncValidator)) : "function" == typeof r && e.setAsyncValidators([r]); const o = () => e.updateValueAndValidity(); Lu(n._rawValidators, o), Lu(n._rawAsyncValidators, o) } function k0(e, n) { e._pendingDirty && e.markAsDirty(), e.setValue(e._pendingValue, { emitModelToViewChange: !1 }), n.viewToModelUpdate(e._pendingValue), e._pendingChange = !1 } const CH = { provide: yt, useExisting: pe(() => ju) }, Oa = Promise.resolve(); let ju = (() => { class e extends yt { get submitted() { return xn(this.submittedReactive) } constructor(t, r, o) { super(), this.callSetDisabledState = o, this._submitted = ia(() => this.submittedReactive()), this.submittedReactive = Wo(!1), this._directives = new Set, this.ngSubmit = new Te, this.form = new em({}, Hg(t), Gg(r)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(t) { Oa.then(() => { const r = this._findContainer(t.path); t.control = r.registerControl(t.name, t.control), Na(t.control, t, this.callSetDisabledState), t.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.add(t) }) } getControl(t) { return this.form.get(t.path) } removeControl(t) { Oa.then(() => { const r = this._findContainer(t.path); r && r.removeControl(t.name), this._directives.delete(t) }) } addFormGroup(t) { Oa.then(() => { const r = this._findContainer(t.path), o = new em({}); (function L0(e, n) { tm(e, n) })(o, t), r.registerControl(t.name, o), o.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(t) { Oa.then(() => { const r = this._findContainer(t.path); r && r.removeControl(t.name) }) } getFormGroup(t) { return this.form.get(t.path) } updateModel(t, r) { Oa.then(() => { this.form.get(t.path).setValue(r) }) } setValue(t) { this.control.setValue(t) } onSubmit(t) { return this.submittedReactive.set(!0), function V0(e, n) { e._syncPendingControls(), n.forEach(t => { const r = t.control; "submit" === r.updateOn && r._pendingChange && (t.viewToModelUpdate(r._pendingValue), r._pendingChange = !1) }) }(this.form, this._directives), this.ngSubmit.emit(t), "dialog" === t?.target?.method } onReset() { this.resetForm() } resetForm(t = void 0) { this.form.reset(t), this.submittedReactive.set(!1) } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(t) { return t.pop(), t.length ? this.form.get(t) : this.form } static { this.\u0275fac = function (r) { return new (r || e)(M(st, 10), M(Dr, 10), M(Vi, 8)) } } static { this.\u0275dir = $({ type: e, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function (r, o) { 1 & r && re("submit", function (s) { return o.onSubmit(s) })("reset", function () { return o.onReset() }) }, inputs: { options: [0, "ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [Ee([CH]), ue] }) } } return e })(); function j0(e, n) { const t = e.indexOf(n); t > -1 && e.splice(t, 1) } function B0(e) { return "object" == typeof e && null !== e && 2 === Object.keys(e).length && "value" in e && "disabled" in e } const U0 = class extends Kg { constructor(n = null, t, r) { super(Jg(t), Xg(r, t)), this.defaultValue = null, this._onChange = [], this._pendingChange = !1, this._applyFormState(n), this._setUpdateStrategy(t), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }), Ru(t) && (t.nonNullable || t.initialValueIsDefault) && (this.defaultValue = B0(n) ? n.value : n) } setValue(n, t = {}) { this.value = this._pendingValue = n, this._onChange.length && !1 !== t.emitModelToViewChange && this._onChange.forEach(r => r(this.value, !1 !== t.emitViewToModelChange)), this.updateValueAndValidity(t) } patchValue(n, t = {}) { this.setValue(n, t) } reset(n = this.defaultValue, t = {}) { this._applyFormState(n), this.markAsPristine(t), this.markAsUntouched(t), this.setValue(this.value, t), this._pendingChange = !1 } _updateValue() { } _anyControls(n) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(n) { this._onChange.push(n) } _unregisterOnChange(n) { j0(this._onChange, n) } registerOnDisabledChange(n) { this._onDisabledChange.push(n) } _unregisterOnDisabledChange(n) { j0(this._onDisabledChange, n) } _forEachChild(n) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(n) { B0(n) ? (this.value = this._pendingValue = n.value, n.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = n } }, bH = { provide: wr, useExisting: pe(() => Bu) }, G0 = Promise.resolve(); let Bu = (() => { class e extends wr { constructor(t, r, o, i, s, a) { super(), this._changeDetectorRef = s, this.callSetDisabledState = a, this.control = new U0, this._registered = !1, this.name = "", this.update = new Te, this._parent = t, this._setValidators(r), this._setAsyncValidators(o), this.valueAccessor = function om(e, n) { if (!n) return null; let t, r, o; return Array.isArray(n), n.forEach(i => { i.constructor === Sa ? t = i : function yH(e) { return Object.getPrototypeOf(e.constructor) === co }(i) ? r = i : o = i }), o || r || t || null }(0, i) } ngOnChanges(t) { if (this._checkForErrors(), !this._registered || "name" in t) { if (this._registered && (this._checkName(), this.formDirective)) { const r = t.name.previousValue; this.formDirective.removeControl({ name: r, path: this._getPath(r) }) } this._setUpControl() } "isDisabled" in t && this._updateDisabled(t), function rm(e, n) { if (!e.hasOwnProperty("model")) return !1; const t = e.model; return !!t.isFirstChange() || !Object.is(n, t.currentValue) }(t, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._getPath(this.name) } get formDirective() { return this._parent ? this._parent.formDirective : null } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !(!this.options || !this.options.standalone) } _setUpStandalone() { Na(this.control, this, this.callSetDisabledState), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._isStandalone() || this._checkParentType(), this._checkName() } _checkParentType() { } _checkName() { this.options && this.options.name && (this.name = this.options.name), this._isStandalone() } _updateValue(t) { G0.then(() => { this.control.setValue(t, { emitViewToModelChange: !1 }), this._changeDetectorRef?.markForCheck() }) } _updateDisabled(t) { const r = t.isDisabled.currentValue, o = 0 !== r && _i(r); G0.then(() => { o && !this.control.disabled ? this.control.disable() : !o && this.control.disabled && this.control.enable(), this._changeDetectorRef?.markForCheck() }) } _getPath(t) { return this._parent ? function Fu(e, n) { return [...n.path, e] }(t, this._parent) : [t] } static { this.\u0275fac = function (r) { return new (r || e)(M(yt, 9), M(st, 10), M(Dr, 10), M(Vn, 10), M(ta, 8), M(Vi, 8)) } } static { this.\u0275dir = $({ type: e, selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]], inputs: { name: "name", isDisabled: [0, "disabled", "isDisabled"], model: [0, "ngModel", "model"], options: [0, "ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngModel"], features: [Ee([bH]), ue, Bt] }) } } return e })(), z0 = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275dir = $({ type: e, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }) } } return e })(); const RH = { provide: Vn, useExisting: pe(() => Uu), multi: !0 }; function K0(e, n) { return null == e ? `${n}` : (n && "object" == typeof n && (n = "Object"), `${e}: ${n}`.slice(0, 50)) } let Uu = (() => { class e extends co { constructor() { super(...arguments), this._optionMap = new Map, this._idCounter = 0, this._compareWith = Object.is } set compareWith(t) { this._compareWith = t } writeValue(t) { this.value = t; const o = K0(this._getOptionId(t), t); this.setProperty("value", o) } registerOnChange(t) { this.onChange = r => { this.value = this._getOptionValue(r), t(this.value) } } _registerOption() { return (this._idCounter++).toString() } _getOptionId(t) { for (const r of this._optionMap.keys()) if (this._compareWith(this._optionMap.get(r), t)) return r; return null } _getOptionValue(t) { const r = function PH(e) { return e.split(":")[0] }(t); return this._optionMap.has(r) ? this._optionMap.get(r) : t } static { this.\u0275fac = (() => { let t; return function (o) { return (t || (t = Ye(e)))(o || e) } })() } static { this.\u0275dir = $({ type: e, selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]], hostBindings: function (r, o) { 1 & r && re("change", function (s) { return o.onChange(s.target.value) })("blur", function () { return o.onTouched() }) }, inputs: { compareWith: "compareWith" }, features: [Ee([RH]), ue] }) } } return e })(), eS = (() => { class e { constructor(t, r, o) { this._element = t, this._renderer = r, this._select = o, this._select && (this.id = this._select._registerOption()) } set ngValue(t) { null != this._select && (this._select._optionMap.set(this.id, t), this._setElementValue(K0(this.id, t)), this._select.writeValue(this._select.value)) } set value(t) { this._setElementValue(t), this._select && this._select.writeValue(this._select.value) } _setElementValue(t) { this._renderer.setProperty(this._element.nativeElement, "value", t) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } static { this.\u0275fac = function (r) { return new (r || e)(M(Ot), M(Qn), M(Uu, 9)) } } static { this.\u0275dir = $({ type: e, selectors: [["option"]], inputs: { ngValue: "ngValue", value: "value" } }) } } return e })(); const FH = { provide: Vn, useExisting: pe(() => cm), multi: !0 }; function tS(e, n) { return null == e ? `${n}` : ("string" == typeof n && (n = `'${n}'`), n && "object" == typeof n && (n = "Object"), `${e}: ${n}`.slice(0, 50)) } let cm = (() => { class e extends co { constructor() { super(...arguments), this._optionMap = new Map, this._idCounter = 0, this._compareWith = Object.is } set compareWith(t) { this._compareWith = t } writeValue(t) { let r; if (this.value = t, Array.isArray(t)) { const o = t.map(i => this._getOptionId(i)); r = (i, s) => { i._setSelected(o.indexOf(s.toString()) > -1) } } else r = (o, i) => { o._setSelected(!1) }; this._optionMap.forEach(r) } registerOnChange(t) { this.onChange = r => { const o = [], i = r.selectedOptions; if (void 0 !== i) { const s = i; for (let a = 0; a < s.length; a++) { const l = this._getOptionValue(s[a].value); o.push(l) } } else { const s = r.options; for (let a = 0; a < s.length; a++) { const c = s[a]; if (c.selected) { const l = this._getOptionValue(c.value); o.push(l) } } } this.value = o, t(o) } } _registerOption(t) { const r = (this._idCounter++).toString(); return this._optionMap.set(r, t), r } _getOptionId(t) { for (const r of this._optionMap.keys()) if (this._compareWith(this._optionMap.get(r)._value, t)) return r; return null } _getOptionValue(t) { const r = function kH(e) { return e.split(":")[0] }(t); return this._optionMap.has(r) ? this._optionMap.get(r)._value : t } static { this.\u0275fac = (() => { let t; return function (o) { return (t || (t = Ye(e)))(o || e) } })() } static { this.\u0275dir = $({ type: e, selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]], hostBindings: function (r, o) { 1 & r && re("change", function (s) { return o.onChange(s.target) })("blur", function () { return o.onTouched() }) }, inputs: { compareWith: "compareWith" }, features: [Ee([FH]), ue] }) } } return e })(), nS = (() => { class e { constructor(t, r, o) { this._element = t, this._renderer = r, this._select = o, this._select && (this.id = this._select._registerOption(this)) } set ngValue(t) { null != this._select && (this._value = t, this._setElementValue(tS(this.id, t)), this._select.writeValue(this._select.value)) } set value(t) { this._select ? (this._value = t, this._setElementValue(tS(this.id, t)), this._select.writeValue(this._select.value)) : this._setElementValue(t) } _setElementValue(t) { this._renderer.setProperty(this._element.nativeElement, "value", t) } _setSelected(t) { this._renderer.setProperty(this._element.nativeElement, "selected", t) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } static { this.\u0275fac = function (r) { return new (r || e)(M(Ot), M(Qn), M(cm, 9)) } } static { this.\u0275dir = $({ type: e, selectors: [["option"]], inputs: { ngValue: "ngValue", value: "value" } }) } } return e })(), lo = (() => { class e { constructor() { this._validator = Tu } ngOnChanges(t) { if (this.inputName in t) { const r = this.normalizeInput(t[this.inputName].currentValue); this._enabled = this.enabled(r), this._validator = this._enabled ? this.createValidator(r) : Tu, this._onChange && this._onChange() } } validate(t) { return this._validator(t) } registerOnValidatorChange(t) { this._onChange = t } enabled(t) { return null != t } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275dir = $({ type: e, features: [Bt] }) } } return e })(); const jH = { provide: st, useExisting: pe(() => $u), multi: !0 }; let $u = (() => { class e extends lo { constructor() { super(...arguments), this.inputName = "required", this.normalizeInput = _i, this.createValidator = t => d0 } enabled(t) { return t } static { this.\u0275fac = (() => { let t; return function (o) { return (t || (t = Ye(e)))(o || e) } })() } static { this.\u0275dir = $({ type: e, selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]], hostVars: 1, hostBindings: function (r, o) { 2 & r && nn("required", o._enabled ? "" : null) }, inputs: { required: "required" }, features: [Ee([jH]), ue] }) } } return e })(), zH = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275mod = bo({ type: e }) } static { this.\u0275inj = Ar({}) } } return e })(), fS = (() => { class e { static withConfig(t) { return { ngModule: e, providers: [{ provide: Vi, useValue: t.callSetDisabledState ?? Pu }] } } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275mod = bo({ type: e }) } static { this.\u0275inj = Ar({ imports: [zH] }) } } return e })(); function hS(e, n, t, r, o, i, s) { try { var a = e[i](s), c = a.value } catch (l) { return void t(l) } a.done ? n(c) : Promise.resolve(c).then(r, o) } function pS(e) { return function () { var n = this, t = arguments; return new Promise(function (r, o) { var i = e.apply(n, t); function s(c) { hS(i, r, o, s, a, "next", c) } function a(c) { hS(i, r, o, s, a, "throw", c) } s(void 0) }) } } class Hu { } class Gu { } class qt { constructor(n) { this.normalizedNames = new Map, this.lazyUpdate = null, n ? "string" == typeof n ? this.lazyInit = () => { this.headers = new Map, n.split("\n").forEach(t => { const r = t.indexOf(":"); if (r > 0) { const o = t.slice(0, r), i = o.toLowerCase(), s = t.slice(r + 1).trim(); this.maybeSetNormalizedName(o, i), this.headers.has(i) ? this.headers.get(i).push(s) : this.headers.set(i, [s]) } }) } : typeof Headers < "u" && n instanceof Headers ? (this.headers = new Map, n.forEach((t, r) => { this.setHeaderEntries(r, t) })) : this.lazyInit = () => { this.headers = new Map, Object.entries(n).forEach(([t, r]) => { this.setHeaderEntries(t, r) }) } : this.headers = new Map } has(n) { return this.init(), this.headers.has(n.toLowerCase()) } get(n) { this.init(); const t = this.headers.get(n.toLowerCase()); return t && t.length > 0 ? t[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(n) { return this.init(), this.headers.get(n.toLowerCase()) || null } append(n, t) { return this.clone({ name: n, value: t, op: "a" }) } set(n, t) { return this.clone({ name: n, value: t, op: "s" }) } delete(n, t) { return this.clone({ name: n, value: t, op: "d" }) } maybeSetNormalizedName(n, t) { this.normalizedNames.has(t) || this.normalizedNames.set(t, n) } init() { this.lazyInit && (this.lazyInit instanceof qt ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(n => this.applyUpdate(n)), this.lazyUpdate = null)) } copyFrom(n) { n.init(), Array.from(n.headers.keys()).forEach(t => { this.headers.set(t, n.headers.get(t)), this.normalizedNames.set(t, n.normalizedNames.get(t)) }) } clone(n) { const t = new qt; return t.lazyInit = this.lazyInit && this.lazyInit instanceof qt ? this.lazyInit : this, t.lazyUpdate = (this.lazyUpdate || []).concat([n]), t } applyUpdate(n) { const t = n.name.toLowerCase(); switch (n.op) { case "a": case "s": let r = n.value; if ("string" == typeof r && (r = [r]), 0 === r.length) return; this.maybeSetNormalizedName(n.name, t); const o = ("a" === n.op ? this.headers.get(t) : void 0) || []; o.push(...r), this.headers.set(t, o); break; case "d": const i = n.value; if (i) { let s = this.headers.get(t); if (!s) return; s = s.filter(a => -1 === i.indexOf(a)), 0 === s.length ? (this.headers.delete(t), this.normalizedNames.delete(t)) : this.headers.set(t, s) } else this.headers.delete(t), this.normalizedNames.delete(t) } } setHeaderEntries(n, t) { const r = (Array.isArray(t) ? t : [t]).map(i => i.toString()), o = n.toLowerCase(); this.headers.set(o, r), this.maybeSetNormalizedName(n, o) } forEach(n) { this.init(), Array.from(this.normalizedNames.keys()).forEach(t => n(this.normalizedNames.get(t), this.headers.get(t))) } } class WH { encodeKey(n) { return gS(n) } encodeValue(n) { return gS(n) } decodeKey(n) { return decodeURIComponent(n) } decodeValue(n) { return decodeURIComponent(n) } } const QH = /%(\d[a-f0-9])/gi, YH = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "3D": "=", "3F": "?", "2F": "/" }; function gS(e) { return encodeURIComponent(e).replace(QH, (n, t) => YH[t] ?? n) } function zu(e) { return `${e}` } class br { constructor(n = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = n.encoder || new WH, n.fromString) { if (n.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function ZH(e, n) { const t = new Map; return e.length > 0 && e.replace(/^\?/, "").split("&").forEach(o => { const i = o.indexOf("="), [s, a] = -1 == i ? [n.decodeKey(o), ""] : [n.decodeKey(o.slice(0, i)), n.decodeValue(o.slice(i + 1))], c = t.get(s) || []; c.push(a), t.set(s, c) }), t }(n.fromString, this.encoder) } else n.fromObject ? (this.map = new Map, Object.keys(n.fromObject).forEach(t => { const r = n.fromObject[t], o = Array.isArray(r) ? r.map(zu) : [zu(r)]; this.map.set(t, o) })) : this.map = null } has(n) { return this.init(), this.map.has(n) } get(n) { this.init(); const t = this.map.get(n); return t ? t[0] : null } getAll(n) { return this.init(), this.map.get(n) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(n, t) { return this.clone({ param: n, value: t, op: "a" }) } appendAll(n) { const t = []; return Object.keys(n).forEach(r => { const o = n[r]; Array.isArray(o) ? o.forEach(i => { t.push({ param: r, value: i, op: "a" }) }) : t.push({ param: r, value: o, op: "a" }) }), this.clone(t) } set(n, t) { return this.clone({ param: n, value: t, op: "s" }) } delete(n, t) { return this.clone({ param: n, value: t, op: "d" }) } toString() { return this.init(), this.keys().map(n => { const t = this.encoder.encodeKey(n); return this.map.get(n).map(r => t + "=" + this.encoder.encodeValue(r)).join("&") }).filter(n => "" !== n).join("&") } clone(n) { const t = new br({ encoder: this.encoder }); return t.cloneFrom = this.cloneFrom || this, t.updates = (this.updates || []).concat(n), t } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(n => this.map.set(n, this.cloneFrom.map.get(n))), this.updates.forEach(n => { switch (n.op) { case "a": case "s": const t = ("a" === n.op ? this.map.get(n.param) : void 0) || []; t.push(zu(n.value)), this.map.set(n.param, t); break; case "d": if (void 0 === n.value) { this.map.delete(n.param); break } { let r = this.map.get(n.param) || []; const o = r.indexOf(zu(n.value)); -1 !== o && r.splice(o, 1), r.length > 0 ? this.map.set(n.param, r) : this.map.delete(n.param) } } }), this.cloneFrom = this.updates = null) } } class JH { constructor() { this.map = new Map } set(n, t) { return this.map.set(n, t), this } get(n) { return this.map.has(n) || this.map.set(n, n.defaultValue()), this.map.get(n) } delete(n) { return this.map.delete(n), this } has(n) { return this.map.has(n) } keys() { return this.map.keys() } } function mS(e) { return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer } function vS(e) { return typeof Blob < "u" && e instanceof Blob } function yS(e) { return typeof FormData < "u" && e instanceof FormData } class xa { constructor(n, t, r, o) { let i; if (this.url = t, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = n.toUpperCase(), function XH(e) { switch (e) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || o ? (this.body = void 0 !== r ? r : null, i = o) : i = r, i && (this.reportProgress = !!i.reportProgress, this.withCredentials = !!i.withCredentials, i.responseType && (this.responseType = i.responseType), i.headers && (this.headers = i.headers), i.context && (this.context = i.context), i.params && (this.params = i.params), this.transferCache = i.transferCache), this.headers ??= new qt, this.context ??= new JH, this.params) { const s = this.params.toString(); if (0 === s.length) this.urlWithParams = t; else { const a = t.indexOf("?"); this.urlWithParams = t + (-1 === a ? "?" : a < t.length - 1 ? "&" : "") + s } } else this.params = new br, this.urlWithParams = t } serializeBody() { return null === this.body ? null : "string" == typeof this.body || mS(this.body) || vS(this.body) || yS(this.body) || function KH(e) { return typeof URLSearchParams < "u" && e instanceof URLSearchParams }(this.body) ? this.body : this.body instanceof br ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || yS(this.body) ? null : vS(this.body) ? this.body.type || null : mS(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof br ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(n = {}) { const t = n.method || this.method, r = n.url || this.url, o = n.responseType || this.responseType, i = n.transferCache ?? this.transferCache, s = void 0 !== n.body ? n.body : this.body, a = n.withCredentials ?? this.withCredentials, c = n.reportProgress ?? this.reportProgress; let l = n.headers || this.headers, u = n.params || this.params; const d = n.context ?? this.context; return void 0 !== n.setHeaders && (l = Object.keys(n.setHeaders).reduce((f, h) => f.set(h, n.setHeaders[h]), l)), n.setParams && (u = Object.keys(n.setParams).reduce((f, h) => f.set(h, n.setParams[h]), u)), new xa(t, r, s, { params: u, headers: l, context: d, reportProgress: c, responseType: o, withCredentials: a, transferCache: i }) } } var Er = function (e) { return e[e.Sent = 0] = "Sent", e[e.UploadProgress = 1] = "UploadProgress", e[e.ResponseHeader = 2] = "ResponseHeader", e[e.DownloadProgress = 3] = "DownloadProgress", e[e.Response = 4] = "Response", e[e.User = 5] = "User", e }(Er || {}); class lm { constructor(n, t = 200, r = "OK") { this.headers = n.headers || new qt, this.status = void 0 !== n.status ? n.status : t, this.statusText = n.statusText || r, this.url = n.url || null, this.ok = this.status >= 200 && this.status < 300 } } class qu extends lm { constructor(n = {}) { super(n), this.type = Er.ResponseHeader } clone(n = {}) { return new qu({ headers: n.headers || this.headers, status: void 0 !== n.status ? n.status : this.status, statusText: n.statusText || this.statusText, url: n.url || this.url || void 0 }) } } class uo extends lm { constructor(n = {}) { super(n), this.type = Er.Response, this.body = void 0 !== n.body ? n.body : null } clone(n = {}) { return new uo({ body: void 0 !== n.body ? n.body : this.body, headers: n.headers || this.headers, status: void 0 !== n.status ? n.status : this.status, statusText: n.statusText || this.statusText, url: n.url || this.url || void 0 }) } } class ji extends lm { constructor(n) { super(n, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${n.url || "(unknown url)"}` : `Http failure response for ${n.url || "(unknown url)"}: ${n.status} ${n.statusText}`, this.error = n.error || null } } function um(e, n) { return { body: n, headers: e.headers, context: e.context, observe: e.observe, params: e.params, reportProgress: e.reportProgress, responseType: e.responseType, withCredentials: e.withCredentials, transferCache: e.transferCache } } let CS = (() => { class e { constructor(t) { this.handler = t } request(t, r, o = {}) { let i; if (t instanceof xa) i = t; else { let c, l; c = o.headers instanceof qt ? o.headers : new qt(o.headers), o.params && (l = o.params instanceof br ? o.params : new br({ fromObject: o.params })), i = new xa(t, r, void 0 !== o.body ? o.body : null, { headers: c, context: o.context, params: l, reportProgress: o.reportProgress, responseType: o.responseType || "json", withCredentials: o.withCredentials, transferCache: o.transferCache }) } const s = U(i).pipe(Mi(c => this.handler.handle(c))); if (t instanceof xa || "events" === o.observe) return s; const a = s.pipe(er(c => c instanceof uo)); switch (o.observe || "body") { case "body": switch (i.responseType) { case "arraybuffer": return a.pipe(K(c => { if (null !== c.body && !(c.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return c.body })); case "blob": return a.pipe(K(c => { if (null !== c.body && !(c.body instanceof Blob)) throw new Error("Response is not a Blob."); return c.body })); case "text": return a.pipe(K(c => { if (null !== c.body && "string" != typeof c.body) throw new Error("Response is not a string."); return c.body })); default: return a.pipe(K(c => c.body)) }case "response": return a; default: throw new Error(`Unreachable: unhandled observe type ${o.observe}}`) } } delete(t, r = {}) { return this.request("DELETE", t, r) } get(t, r = {}) { return this.request("GET", t, r) } head(t, r = {}) { return this.request("HEAD", t, r) } jsonp(t, r) { return this.request("JSONP", t, { params: (new br).append(r, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(t, r = {}) { return this.request("OPTIONS", t, r) } patch(t, r, o = {}) { return this.request("PATCH", t, um(o, r)) } post(t, r, o = {}) { return this.request("POST", t, um(o, r)) } put(t, r, o = {}) { return this.request("PUT", t, um(o, r)) } static { this.\u0275fac = function (r) { return new (r || e)(x(Hu)) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac }) } } return e })(); const n4 = /^\)\]\}',?\n/; function DS(e) { if (e.url) return e.url; const n = "X-Request-URL".toLocaleLowerCase(); return e.headers.get(n) } let dm = (() => { class e { constructor() { this.fetchImpl = b(o4, { optional: !0 })?.fetch ?? ((...t) => globalThis.fetch(...t)), this.ngZone = b(ie) } handle(t) { return new ke(r => { const o = new AbortController; return this.doRequest(t, o.signal, r).then(fm, i => r.error(new ji({ error: i }))), () => o.abort() }) } doRequest(t, r, o) { var i = this; return pS(function* () { const s = i.createRequestInit(t); let a; try { const p = i.ngZone.runOutsideAngular(() => i.fetchImpl(t.urlWithParams, { signal: r, ...s })); (function i4(e) { e.then(fm, fm) })(p), o.next({ type: Er.Sent }), a = yield p } catch (p) { return void o.error(new ji({ error: p, status: p.status ?? 0, statusText: p.statusText, url: t.urlWithParams, headers: p.headers })) } const c = new qt(a.headers), l = a.statusText, u = DS(a) ?? t.urlWithParams; let d = a.status, f = null; if (t.reportProgress && o.next(new qu({ headers: c, status: d, statusText: l, url: u })), a.body) { const p = a.headers.get("content-length"), g = [], v = a.body.getReader(); let _, A, D = 0; const F = typeof Zone < "u" && Zone.current; yield i.ngZone.runOutsideAngular(pS(function* () { for (; ;) { const { done: ne, value: Ne } = yield v.read(); if (ne) break; if (g.push(Ne), D += Ne.length, t.reportProgress) { A = "text" === t.responseType ? (A ?? "") + (_ ??= new TextDecoder).decode(Ne, { stream: !0 }) : void 0; const nr = () => o.next({ type: Er.DownloadProgress, total: p ? +p : void 0, loaded: D, partialText: A }); F ? F.run(nr) : nr() } } })); const Q = i.concatChunks(g, D); try { const ne = a.headers.get("Content-Type") ?? ""; f = i.parseBody(t, Q, ne) } catch (ne) { return void o.error(new ji({ error: ne, headers: new qt(a.headers), status: a.status, statusText: a.statusText, url: DS(a) ?? t.urlWithParams })) } } 0 === d && (d = f ? 200 : 0), d >= 200 && d < 300 ? (o.next(new uo({ body: f, headers: c, status: d, statusText: l, url: u })), o.complete()) : o.error(new ji({ error: f, headers: c, status: d, statusText: l, url: u })) })() } parseBody(t, r, o) { switch (t.responseType) { case "json": const i = (new TextDecoder).decode(r).replace(n4, ""); return "" === i ? null : JSON.parse(i); case "text": return (new TextDecoder).decode(r); case "blob": return new Blob([r], { type: o }); case "arraybuffer": return r.buffer } } createRequestInit(t) { const r = {}, o = t.withCredentials ? "include" : void 0; if (t.headers.forEach((i, s) => r[i] = s.join(",")), t.headers.has("Accept") || (r.Accept = "application/json, text/plain, */*"), !t.headers.has("Content-Type")) { const i = t.detectContentTypeHeader(); null !== i && (r["Content-Type"] = i) } return { body: t.serializeBody(), method: t.method, headers: r, credentials: o } } concatChunks(t, r) { const o = new Uint8Array(r); let i = 0; for (const s of t) o.set(s, i), i += s.length; return o } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac }) } } return e })(); class o4 { } function fm() { } function wS(e, n) { return n(e) } const Ra = new T(""), bS = new T(""), ES = new T("", { providedIn: "root", factory: () => !0 }); let MS = (() => { class e extends Hu { constructor(t, r) { super(), this.backend = t, this.injector = r, this.chain = null, this.pendingTasks = b(cr), this.contributeToStability = b(ES) } handle(t) { if (null === this.chain) { const r = Array.from(new Set([...this.injector.get(Ra), ...this.injector.get(bS, [])])); this.chain = r.reduceRight((o, i) => function a4(e, n, t) { return (r, o) => mn(t, () => n(r, i => e(i, o))) }(o, i, this.injector), wS) } if (this.contributeToStability) { const r = this.pendingTasks.add(); return this.chain(t, o => this.backend.handle(o)).pipe(cu(() => this.pendingTasks.remove(r))) } return this.chain(t, r => this.backend.handle(r)) } static { this.\u0275fac = function (r) { return new (r || e)(x(Gu), x(lt)) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac }) } } return e })(); const p4 = /^\)\]\}',?\n/; let SS = (() => { class e { constructor(t) { this.xhrFactory = t } handle(t) { if ("JSONP" === t.method) throw new w(-2800, !1); const r = this.xhrFactory; return (r.\u0275loadImpl ? Qe(r.\u0275loadImpl()) : U(null)).pipe(un(() => new ke(i => { const s = r.build(); if (s.open(t.method, t.urlWithParams), t.withCredentials && (s.withCredentials = !0), t.headers.forEach((g, v) => s.setRequestHeader(g, v.join(","))), t.headers.has("Accept") || s.setRequestHeader("Accept", "application/json, text/plain, */*"), !t.headers.has("Content-Type")) { const g = t.detectContentTypeHeader(); null !== g && s.setRequestHeader("Content-Type", g) } if (t.responseType) { const g = t.responseType.toLowerCase(); s.responseType = "json" !== g ? g : "text" } const a = t.serializeBody(); let c = null; const l = () => { if (null !== c) return c; const g = s.statusText || "OK", v = new qt(s.getAllResponseHeaders()), D = function g4(e) { return "responseURL" in e && e.responseURL ? e.responseURL : /^X-Request-URL:/m.test(e.getAllResponseHeaders()) ? e.getResponseHeader("X-Request-URL") : null }(s) || t.url; return c = new qu({ headers: v, status: s.status, statusText: g, url: D }), c }, u = () => { let { headers: g, status: v, statusText: D, url: _ } = l(), A = null; 204 !== v && (A = typeof s.response > "u" ? s.responseText : s.response), 0 === v && (v = A ? 200 : 0); let F = v >= 200 && v < 300; if ("json" === t.responseType && "string" == typeof A) { const Q = A; A = A.replace(p4, ""); try { A = "" !== A ? JSON.parse(A) : null } catch (ne) { A = Q, F && (F = !1, A = { error: ne, text: A }) } } F ? (i.next(new uo({ body: A, headers: g, status: v, statusText: D, url: _ || void 0 })), i.complete()) : i.error(new ji({ error: A, headers: g, status: v, statusText: D, url: _ || void 0 })) }, d = g => { const { url: v } = l(), D = new ji({ error: g, status: s.status || 0, statusText: s.statusText || "Unknown Error", url: v || void 0 }); i.error(D) }; let f = !1; const h = g => { f || (i.next(l()), f = !0); let v = { type: Er.DownloadProgress, loaded: g.loaded }; g.lengthComputable && (v.total = g.total), "text" === t.responseType && s.responseText && (v.partialText = s.responseText), i.next(v) }, p = g => { let v = { type: Er.UploadProgress, loaded: g.loaded }; g.lengthComputable && (v.total = g.total), i.next(v) }; return s.addEventListener("load", u), s.addEventListener("error", d), s.addEventListener("timeout", d), s.addEventListener("abort", d), t.reportProgress && (s.addEventListener("progress", h), null !== a && s.upload && s.upload.addEventListener("progress", p)), s.send(a), i.next({ type: Er.Sent }), () => { s.removeEventListener("error", d), s.removeEventListener("abort", d), s.removeEventListener("load", u), s.removeEventListener("timeout", d), t.reportProgress && (s.removeEventListener("progress", h), null !== a && s.upload && s.upload.removeEventListener("progress", p)), s.readyState !== s.DONE && s.abort() } }))) } static { this.\u0275fac = function (r) { return new (r || e)(x(aM)) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac }) } } return e })(); const hm = new T(""), TS = new T("", { providedIn: "root", factory: () => "XSRF-TOKEN" }), AS = new T("", { providedIn: "root", factory: () => "X-XSRF-TOKEN" }); class NS { } let y4 = (() => { class e { constructor(t, r, o) { this.doc = t, this.platform = r, this.cookieName = o, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const t = this.doc.cookie || ""; return t !== this.lastCookieString && (this.parseCount++, this.lastToken = XE(t, this.cookieName), this.lastCookieString = t), this.lastToken } static { this.\u0275fac = function (r) { return new (r || e)(x(Et), x(zn), x(TS)) } } static { this.\u0275prov = N({ token: e, factory: e.\u0275fac }) } } return e })(); function _4(e, n) { const t = e.url.toLowerCase(); if (!b(hm) || "GET" === e.method || "HEAD" === e.method || t.startsWith("http://") || t.startsWith("https://")) return n(e); const r = b(NS).getToken(), o = b(AS); return null != r && !e.headers.has(o) && (e = e.clone({ headers: e.headers.set(o, r) })), n(e) } let A4 = (() => { class e { apiBaseUrl; constructor() { this.apiBaseUrl = "localhost" === window.location.hostname || "127.0.0.1" === window.location.hostname ? "http://localhost:3000" : "http://localhost:3000" } getApiUrl(t) { return `${this.apiBaseUrl}/${t}` } getApiBaseUrl() { return this.apiBaseUrl } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), Pa = (() => { class e { http; apiConfig; games = []; constructor(t, r) { this.http = t, this.apiConfig = r } getGames() { return this.http.get(this.apiConfig.getApiUrl("gamesList")) } getGameDetails(t) { return this.http.get(this.apiConfig.getApiUrl(`gameDetails/${t}`)) } getProfiles() { return this.http.get(this.apiConfig.getApiUrl("profile")) } getPlatforms() { return this.http.get(this.apiConfig.getApiUrl("platforms")) } getGenres() { return this.http.get(this.apiConfig.getApiUrl("genres")) } addGame(t) { return this.games.push(t) } addProfile(t) { return this.http.put(this.apiConfig.getApiUrl("profile/"), t) } editProfile(t) { return this.http.put(this.apiConfig.getApiUrl("profile/"), t) } addGameToList(t, r, o) { return this.http.patch(this.apiConfig.getApiUrl(`profile/${t}`), { lists: [{ id: r, gamesIds: [o] }] }) } removeGameFromList(t, r, o) { return this.http.patch(this.apiConfig.getApiUrl(`profile/${t}`), { lists: [{ id: r, gamesIds: [o] }] }) } moveGameBetweenLists(t, r, o, i) { return this.http.patch(this.apiConfig.getApiUrl(`profile/${t}`), { lists: [{ id: r, gamesIds: [i] }, { id: o, gamesIds: [i] }] }) } static \u0275fac = function (r) { return new (r || e)(x(CS), x(A4)) }; static \u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function N4(e, n) { if (1 & e && (y(0, "option", 24), E(1), m()), 2 & e) { const t = n.$implicit; P("value", t.name), I(), Ae(" ", t.name, " ") } } function O4(e, n) { if (1 & e && (y(0, "option", 24), E(1), m()), 2 & e) { const t = n.$implicit; P("value", t.name), I(), Ae(" ", t.name, " ") } } function x4(e, n) { if (1 & e) { const t = Tn(); y(0, "div", 28)(1, "div", 29), re("click", function () { const o = Ie(t).$implicit; return Se(z(2).viewGameDetails(o.id || "")) }), k(2, "img", 30), y(3, "div", 31)(4, "h5", 32), E(5), m(), y(6, "p", 33), E(7), Xr(8, "slice"), m(), y(9, "div", 34)(10, "div", 35)(11, "span", 36), E(12), m(), y(13, "span", 37), E(14), m()(), y(15, "div", 38)(16, "small", 39), E(17), Xr(18, "date"), m(), y(19, "button", 40), re("click", function (o) { const i = Ie(t).$implicit; return z(2).viewGameDetails(i.id || ""), Se(o.stopPropagation()) }), E(20, " Ver Detalhes "), m()()()()()() } if (2 & e) { const t = n.$implicit; I(2), P("src", t.thumbnail, en)("alt", t.title), I(3), Me(t.title), I(2), wl("", pp(8, 8, t.shortDescription, 0, 100), "", t.shortDescription.length > 100 ? "..." : "", ""), I(5), Me(t.genre), I(2), Me(t.platform), I(3), Me(Ml(18, 12, t.releaseDate, "dd/MM/yyyy")) } } function R4(e, n) { if (1 & e && (y(0, "div", 25)(1, "div", 26)(2, "h4"), E(3), m()(), De(4, x4, 21, 15, "div", 27), m()), 2 & e) { const t = z(); I(3), Ae("Encontrados ", t.filteredGames.length, " jogos"), I(), P("ngForOf", t.filteredGames) } } function P4(e, n) { 1 & e && (y(0, "div", 25)(1, "div", 41)(2, "div", 42)(3, "h4"), E(4, "Nenhum jogo encontrado"), m(), y(5, "p"), E(6, "Tente ajustar os filtros de pesquisa."), m()()()()) } function F4(e, n) { 1 & e && (y(0, "div", 25)(1, "div", 41)(2, "div", 43)(3, "span", 44), E(4, "Carregando..."), m()()()()) } let k4 = (() => { class e { gameService; router; games = []; filteredGames = []; platforms = []; genres = []; loading = !0; searchTerm = ""; selectedPlatform = ""; selectedGenre = ""; sortBy = "title"; constructor(t, r) { this.gameService = t, this.router = r } ngOnInit() { this.loadGames(), this.loadPlatforms(), this.loadGenres() } loadGames() { this.loading = !0, this.gameService.getGames().subscribe({ next: t => { this.games = t, this.applyFilters(), this.loading = !1 }, error: t => { console.error("Error loading games:", t), this.loading = !1 } }) } loadPlatforms() { this.gameService.getPlatforms().subscribe({ next: t => { this.platforms = t }, error: t => { console.error("Error loading platforms:", t) } }) } loadGenres() { this.gameService.getGenres().subscribe({ next: t => { this.genres = t }, error: t => { console.error("Error loading genres:", t) } }) } onSearchChange() { this.applyFilters() } onFilterChange() { this.applyFilters() } onSortChange() { this.applyFilters() } applyFilters() { let t = [...this.games]; this.searchTerm.trim() && (t = t.filter(r => r.title.toLowerCase().includes(this.searchTerm.toLowerCase()))), this.selectedPlatform && (t = t.filter(r => r.platform === this.selectedPlatform)), this.selectedGenre && (t = t.filter(r => r.genre === this.selectedGenre)), t.sort((r, o) => { switch (this.sortBy) { case "title": return r.title.localeCompare(o.title); case "-title": return o.title.localeCompare(r.title); case "releaseDate": return new Date(r.releaseDate).getTime() - new Date(o.releaseDate).getTime(); case "-releaseDate": return new Date(o.releaseDate).getTime() - new Date(r.releaseDate).getTime(); default: return 0 } }), this.filteredGames = t } viewGameDetails(t) { this.router.navigate(["/game", t]) } static \u0275fac = function (r) { return new (r || e)(M(Pa), M(Mt)) }; static \u0275cmp = gn({ type: e, selectors: [["app-games-list"]], standalone: !0, features: [Nn], decls: 39, vars: 9, consts: [[1, "container-fluid", "py-4"], [1, "row", "mb-4"], [1, "col-12"], [1, "card"], [1, "card-body"], [1, "row", "g-3"], [1, "col-md-4"], ["for", "searchInput", 1, "form-label"], ["type", "text", "id", "searchInput", "placeholder", "Digite o nome do jogo...", 1, "form-control", 3, "ngModelChange", "input", "ngModel"], [1, "col-md-3"], ["for", "platformFilter", 1, "form-label"], ["id", "platformFilter", 1, "form-select", 3, "ngModelChange", "change", "ngModel"], ["value", ""], [3, "value", 4, "ngFor", "ngForOf"], ["for", "genreFilter", 1, "form-label"], ["id", "genreFilter", 1, "form-select", 3, "ngModelChange", "change", "ngModel"], [1, "col-md-2"], ["for", "sortSelect", 1, "form-label"], ["id", "sortSelect", 1, "form-select", 3, "ngModelChange", "change", "ngModel"], ["value", "title"], ["value", "-title"], ["value", "releaseDate"], ["value", "-releaseDate"], ["class", "row", 4, "ngIf"], [3, "value"], [1, "row"], [1, "col-12", "mb-3"], ["class", "col-lg-3 col-md-4 col-sm-6 mb-4", 4, "ngFor", "ngForOf"], [1, "col-lg-3", "col-md-4", "col-sm-6", "mb-4"], [1, "card", "h-100", "game-card", 3, "click"], [1, "card-img-top", 2, "height", "200px", "object-fit", "cover", 3, "src", "alt"], [1, "card-body", "d-flex", "flex-column"], [1, "card-title"], [1, "card-text", "flex-grow-1"], [1, "mt-auto"], [1, "d-flex", "justify-content-between", "align-items-center", "mb-2"], [1, "badge", "bg-primary"], [1, "badge", "bg-secondary"], [1, "d-flex", "justify-content-between", "align-items-center"], [1, "text-muted"], [1, "btn", "btn-sm", "btn-outline-primary", 3, "click"], [1, "col-12", "text-center"], [1, "alert", "alert-info"], ["role", "status", 1, "spinner-border", "text-primary"], [1, "visually-hidden"]], template: function (r, o) { 1 & r && (y(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "div", 4)(5, "div", 5)(6, "div", 6)(7, "label", 7), E(8, "Pesquisar Jogos"), m(), y(9, "input", 8), an("ngModelChange", function (s) { return An(o.searchTerm, s) || (o.searchTerm = s), s }), re("input", function () { return o.onSearchChange() }), m()(), y(10, "div", 9)(11, "label", 10), E(12, "Plataforma"), m(), y(13, "select", 11), an("ngModelChange", function (s) { return An(o.selectedPlatform, s) || (o.selectedPlatform = s), s }), re("change", function () { return o.onFilterChange() }), y(14, "option", 12), E(15, "Todas as plataformas"), m(), De(16, N4, 2, 2, "option", 13), m()(), y(17, "div", 9)(18, "label", 14), E(19, "G\xeanero"), m(), y(20, "select", 15), an("ngModelChange", function (s) { return An(o.selectedGenre, s) || (o.selectedGenre = s), s }), re("change", function () { return o.onFilterChange() }), y(21, "option", 12), E(22, "Todos os g\xeaneros"), m(), De(23, O4, 2, 2, "option", 13), m()(), y(24, "div", 16)(25, "label", 17), E(26, "Ordenar"), m(), y(27, "select", 18), an("ngModelChange", function (s) { return An(o.sortBy, s) || (o.sortBy = s), s }), re("change", function () { return o.onSortChange() }), y(28, "option", 19), E(29, "Nome A-Z"), m(), y(30, "option", 20), E(31, "Nome Z-A"), m(), y(32, "option", 21), E(33, "Data de Lan\xe7amento"), m(), y(34, "option", 22), E(35, "Data de Lan\xe7amento (Recente)"), m()()()()()()()(), De(36, R4, 5, 2, "div", 23)(37, P4, 7, 0, "div", 23)(38, F4, 5, 0, "div", 23), m()), 2 & r && (I(9), sn("ngModel", o.searchTerm), I(4), sn("ngModel", o.selectedPlatform), I(3), P("ngForOf", o.platforms), I(4), sn("ngModel", o.selectedGenre), I(3), P("ngForOf", o.genres), I(4), sn("ngModel", o.sortBy), I(9), P("ngIf", o.filteredGames.length > 0), I(), P("ngIf", 0 === o.filteredGames.length && o.games.length > 0), I(), P("ngIf", o.loading)) }, dependencies: [wi, ca, Di, Jp, Kl, fS, eS, nS, Sa, Uu, qg, Bu], styles: [".game-card[_ngcontent-%COMP%]{transition:transform .2s ease-in-out,box-shadow .2s ease-in-out;cursor:pointer;border:1px solid #dee2e6}.game-card[_ngcontent-%COMP%]:hover{transform:translateY(-5px);box-shadow:0 4px 15px #0000001a}.card-title[_ngcontent-%COMP%]{font-size:1.1rem;font-weight:600;margin-bottom:.5rem;line-height:1.3}.card-text[_ngcontent-%COMP%]{font-size:.9rem;color:#6c757d;line-height:1.4}.badge[_ngcontent-%COMP%]{font-size:.75rem;padding:.35em .65em}.btn-outline-primary[_ngcontent-%COMP%]{border-width:1px;font-size:.875rem;padding:.25rem .5rem}.form-label[_ngcontent-%COMP%]{font-weight:500;color:#495057}.card[_ngcontent-%COMP%]{border:1px solid #e9ecef;box-shadow:0 2px 4px #0000000d}.alert[_ngcontent-%COMP%]{border-radius:.5rem}.spinner-border[_ngcontent-%COMP%]{width:3rem;height:3rem}"] }) } return e })(), L4 = (() => { class e { sanitizer; constructor(t) { this.sanitizer = t } transform(t) { if (!t) return ""; const r = t.replace(/\n/g, "<br>"); return this.sanitizer.bypassSecurityTrustHtml(r) } static \u0275fac = function (r) { return new (r || e)(M(OM, 16)) }; static \u0275pipe = ct({ name: "nl2br", type: e, pure: !0, standalone: !0 }) } return e })(); function V4(e, n) { if (1 & e) { const t = Tn(); y(0, "div", 36)(1, "button", 37), re("click", function () { const o = Ie(t).$implicit, i = z(3); return Se(i.toggleGameInList(o, i.gameDetails.id)) }), k(2, "i", 38), E(3), m()() } if (2 & e) { const t = n.$implicit, r = z(3); I(), gi(r.isGameInList(t, r.gameDetails.id) ? "btn-success" : "btn-outline-primary"), I(), gi(r.isGameInList(t, r.gameDetails.id) ? "fa-check" : "fa-plus"), I(), Ae(" ", t.name, " ") } } function j4(e, n) { if (1 & e && (y(0, "div", 27)(1, "h5"), E(2, "Adicionar \xe0s Minhas Listas"), m(), y(3, "div", 34), De(4, V4, 4, 5, "div", 35), m()()), 2 & e) { const t = z(2); I(4), P("ngForOf", t.profile.lists) } } function B4(e, n) { if (1 & e && (y(0, "div", 22)(1, "strong"), E(2, "Sistema Operacional:"), m(), E(3), m()), 2 & e) { const t = z(3); I(3), Ae(" ", t.gameDetails.minimumSystemRequirements.os, " ") } } function U4(e, n) { if (1 & e && (y(0, "div", 22)(1, "strong"), E(2, "Processador:"), m(), E(3), m()), 2 & e) { const t = z(3); I(3), Ae(" ", t.gameDetails.minimumSystemRequirements.processor, " ") } } function $4(e, n) { if (1 & e && (y(0, "div", 22)(1, "strong"), E(2, "Mem\xf3ria:"), m(), E(3), m()), 2 & e) { const t = z(3); I(3), Ae(" ", t.gameDetails.minimumSystemRequirements.memory, " ") } } function H4(e, n) { if (1 & e && (y(0, "div", 22)(1, "strong"), E(2, "Gr\xe1ficos:"), m(), E(3), m()), 2 & e) { const t = z(3); I(3), Ae(" ", t.gameDetails.minimumSystemRequirements.graphics, " ") } } function G4(e, n) { if (1 & e && (y(0, "div", 22)(1, "strong"), E(2, "Armazenamento:"), m(), E(3), m()), 2 & e) { const t = z(3); I(3), Ae(" ", t.gameDetails.minimumSystemRequirements.storage, " ") } } function z4(e, n) { if (1 & e && (y(0, "div", 10)(1, "div", 11)(2, "div", 30)(3, "div", 31)(4, "h3"), E(5, "Requisitos M\xednimos do Sistema"), m()(), y(6, "div", 18)(7, "div", 39), De(8, B4, 4, 1, "div", 40)(9, U4, 4, 1, "div", 40)(10, $4, 4, 1, "div", 40)(11, H4, 4, 1, "div", 40)(12, G4, 4, 1, "div", 40), m()()()()()), 2 & e) { const t = z(2); I(8), P("ngIf", t.gameDetails.minimumSystemRequirements.os), I(), P("ngIf", t.gameDetails.minimumSystemRequirements.processor), I(), P("ngIf", t.gameDetails.minimumSystemRequirements.memory), I(), P("ngIf", t.gameDetails.minimumSystemRequirements.graphics), I(), P("ngIf", t.gameDetails.minimumSystemRequirements.storage) } } function q4(e, n) { if (1 & e) { const t = Tn(); y(0, "div", 43)(1, "img", 44), re("click", function () { const o = Ie(t).$implicit; return Se(z(3).openScreenshotModal(o.image)) }), m()() } if (2 & e) { const t = n.$implicit, r = z(3); I(), P("src", t.image, en)("alt", r.gameDetails.title + " screenshot") } } function W4(e, n) { if (1 & e && (y(0, "div", 10)(1, "div", 11)(2, "div", 30)(3, "div", 31)(4, "h3"), E(5, "Screenshots"), m()(), y(6, "div", 18)(7, "div", 41), De(8, q4, 2, 2, "div", 42), m()()()()()), 2 & e) { const t = z(2); I(8), P("ngForOf", t.gameDetails.screenshots) } } function Z4(e, n) { if (1 & e) { const t = Tn(); y(0, "div", 9)(1, "div", 10)(2, "div", 11)(3, "button", 12), re("click", function () { return Ie(t), Se(z().goBack()) }), k(4, "i", 13), E(5, "Voltar aos Jogos "), m()()(), y(6, "div", 10)(7, "div", 14), k(8, "img", 15), m(), y(9, "div", 16)(10, "div", 17)(11, "div", 18)(12, "h1", 19), E(13), m(), y(14, "p", 20), E(15), m(), y(16, "div", 21)(17, "div", 22)(18, "strong"), E(19, "G\xeanero:"), m(), y(20, "span", 23), E(21), m()(), y(22, "div", 22)(23, "strong"), E(24, "Plataforma:"), m(), y(25, "span", 24), E(26), m()()(), y(27, "div", 21)(28, "div", 22)(29, "strong"), E(30, "Desenvolvedor:"), m(), E(31), m(), y(32, "div", 22)(33, "strong"), E(34, "Publicador:"), m(), E(35), m()(), y(36, "div", 21)(37, "div", 22)(38, "strong"), E(39, "Data de Lan\xe7amento:"), m(), E(40), Xr(41, "date"), m(), y(42, "div", 22)(43, "strong"), E(44, "Status:"), m(), y(45, "span", 25), E(46), m()()(), De(47, j4, 5, 1, "div", 26), y(48, "div", 27)(49, "a", 28), k(50, "i", 29), E(51, "Jogar Agora "), m()()()()()(), y(52, "div", 10)(53, "div", 11)(54, "div", 30)(55, "div", 31)(56, "h3"), E(57, "Descri\xe7\xe3o"), m()(), y(58, "div", 18), k(59, "p", 32), Xr(60, "nl2br"), m()()()(), De(61, z4, 13, 5, "div", 33)(62, W4, 9, 1, "div", 33), m() } if (2 & e) { const t = z(); I(8), P("src", t.gameDetails.thumbnail, en)("alt", t.gameDetails.title), I(5), Me(t.gameDetails.title), I(2), Me(t.gameDetails.shortDescription), I(6), Me(t.gameDetails.genre), I(5), Me(t.gameDetails.platform), I(5), Ae(" ", t.gameDetails.developer, " "), I(4), Ae(" ", t.gameDetails.publisher, " "), I(5), Ae(" ", Ml(41, 15, t.gameDetails.releaseDate, "dd/MM/yyyy"), " "), I(6), Me(t.gameDetails.status), I(), P("ngIf", t.profile), I(2), P("href", t.gameDetails.gameUrl, en), I(10), P("innerHTML", Eb(60, 18, t.gameDetails.description), a_), I(2), P("ngIf", t.gameDetails.minimumSystemRequirements), I(), P("ngIf", t.gameDetails.screenshots && t.gameDetails.screenshots.length > 0) } } function Q4(e, n) { 1 & e && (y(0, "div", 9)(1, "div", 39)(2, "div", 45)(3, "div", 46)(4, "span", 47), E(5, "Carregando..."), m()()()()()) } function Y4(e, n) { 1 & e && k(0, "img", 48), 2 & e && P("src", z().selectedScreenshot, en) } function X4(e, n) { if (1 & e && k(0, "img", 70), 2 & e) { const t = z(); P("src", (null == t.profile ? null : t.profile.avatar) || "", en)("alt", (null == t.profile ? null : t.profile.name) || "") } } function K4(e, n) { if (1 & e && (y(0, "div", 71), E(1), m()), 2 & e) { const t = z(); hi("background-color", t.getAvatarColor((null == t.profile ? null : t.profile.name) || "")), I(), Ae(" ", t.getInitials((null == t.profile ? null : t.profile.name) || ""), " ") } } function e5(e, n) { if (1 & e && k(0, "img", 72), 2 & e) { const t = z(); P("src", (null == t.profile ? null : t.profile.avatar) || "", en)("alt", (null == t.profile ? null : t.profile.name) || "") } } function t5(e, n) { if (1 & e && (y(0, "div", 73), E(1), m()), 2 & e) { const t = z(); hi("background-color", t.getAvatarColor((null == t.profile ? null : t.profile.name) || "")), I(), Ae(" ", t.getInitials((null == t.profile ? null : t.profile.name) || ""), " ") } } function n5(e, n) { 1 & e && k(0, "span", 74) } function r5(e, n) { 1 & e && k(0, "i", 75) } function o5(e, n) { if (1 & e && (y(0, "div", 76)(1, "div", 77)(2, "div", 78), k(3, "i", 79), m(), y(4, "div", 80)(5, "h6", 81), E(6), m(), y(7, "span", 82), E(8), m()()(), y(9, "div", 83)(10, "div", 84), k(11, "div", 85), m()()()), 2 & e) { const t = n.$implicit, r = z(); I(3), gi(r.getListIcon(t.name || "")), I(3), Me(t.name), I(2), Ae("", t.gamesIds.length || 0, " jogos"), I(3), hi("width", r.getListProgress(t), "%") } } function i5(e, n) { 1 & e && (y(0, "div", 86), k(1, "i", 87), y(2, "p", 88), E(3, "Nenhuma lista criada ainda"), m(), y(4, "a", 89), k(5, "i", 90), E(6, "Criar Lista "), m()()) } function a5(e, n) { if (1 & e && (y(0, "li", 18)(1, "button", 19), k(2, "i", 20), E(3), y(4, "span", 21), E(5), m()()()), 2 & e) { const t = n.$implicit, r = n.index, o = z(); I(), pi("active", 0 === r), P("id", "tab-" + t.id), nn("data-bs-target", "#content-" + t.id), I(), gi(o.getListIcon(t.name || "")), I(), Ae(" ", t.name, " "), I(2), Me(o.getGamesInList(t).length) } } function c5(e, n) { if (1 & e) { const t = Tn(); y(0, "div", 32)(1, "div", 33), k(2, "img", 34), y(3, "div", 35)(4, "h5", 36), E(5), m(), y(6, "p", 37), E(7), Xr(8, "slice"), m(), y(9, "div", 38)(10, "div", 39)(11, "span", 40), E(12), m(), y(13, "span", 41), E(14), m()(), y(15, "div", 25)(16, "small", 3), E(17), Xr(18, "date"), m(), y(19, "div", 42)(20, "button", 43), re("click", function () { const o = Ie(t).$implicit; return Se(z(3).viewGameDetails(o.id || "")) }), k(21, "i", 44), m(), y(22, "button", 45), re("click", function () { const o = Ie(t).$implicit, i = z(2).$implicit; return Se(z().moveGame(i, o.id || "")) }), k(23, "i", 46), m(), y(24, "button", 47), re("click", function () { const o = Ie(t).$implicit, i = z(2).$implicit; return Se(z().removeGameFromList(i, o.id || "")) }), k(25, "i", 48), m()()()()()()() } if (2 & e) { const t = n.$implicit; I(2), P("src", t.thumbnail, en)("alt", t.title), I(3), Me(t.title), I(2), wl("", pp(8, 8, t.shortDescription, 0, 100), "", t.shortDescription.length > 100 ? "..." : "", ""), I(5), Me(t.genre), I(2), Me(t.platform), I(3), Me(Ml(18, 12, t.releaseDate, "dd/MM/yyyy")) } } function l5(e, n) { if (1 & e && (y(0, "div", 23), De(1, c5, 26, 15, "div", 31), m()), 2 & e) { const t = z().$implicit, r = z(); I(), P("ngForOf", r.getGamesInList(t)) } } function u5(e, n) { 1 & e && (y(0, "div", 23)(1, "div", 49)(2, "div", 50), k(3, "i", 51), y(4, "h5"), E(5, "Lista Vazia"), m(), y(6, "p"), E(7, "Esta lista ainda n\xe3o possui jogos. Explore nossa biblioteca e adicione seus jogos favoritos!"), m(), y(8, "button", 52), k(9, "i", 53), E(10, "Explorar Jogos "), m()()()()) } function d5(e, n) { if (1 & e) { const t = Tn(); y(0, "div", 22)(1, "div", 23)(2, "div", 24)(3, "div", 25)(4, "h4"), E(5), m(), y(6, "div", 26)(7, "button", 27), re("click", function () { const o = Ie(t).$implicit; return Se(z().moveAllGames(o)) }), k(8, "i", 28), E(9, "Mover Todos "), m(), y(10, "button", 29), re("click", function () { const o = Ie(t).$implicit; return Se(z().clearList(o)) }), k(11, "i", 30), E(12, "Limpar Lista "), m()()()()(), De(13, l5, 2, 1, "div", 8)(14, u5, 11, 0, "div", 8), m() } if (2 & e) { const t = n.$implicit, r = n.index, o = z(); pi("show", 0 === r)("active", 0 === r), P("id", "content-" + t.id), I(5), Me(t.name), I(8), P("ngIf", o.getGamesInList(t).length > 0), I(), P("ngIf", 0 === o.getGamesInList(t).length) } } function f5(e, n) { 1 & e && (y(0, "div", 23)(1, "div", 49)(2, "div", 54)(3, "span", 55), E(4, "Carregando..."), m()()()()) } function h5(e, n) { if (1 & e) { const t = Tn(); y(0, "button", 56), re("click", function () { const o = Ie(t).$implicit; return Se(z().confirmMoveGame(o)) }), k(1, "i", 20), E(2), m() } if (2 & e) { const t = n.$implicit, r = z(); P("disabled", t.id === (null == r.selectedList ? null : r.selectedList.id)), I(), gi(r.getListIcon(t.name || "")), I(), Ae(" ", t.name, " ") } } const p5 = [{ path: "", redirectTo: "/games", pathMatch: "full" }, { title: "FreePlayFinder - Home", path: "home", component: Q3 }, { title: "FreePlayFinder - Jogos", path: "games", component: k4 }, { title: "FreePlayFinder - Detalhes do Jogo", path: "game/:id", component: (() => { class e { route; router; gameService; gameDetails = null; profile = null; loading = !0; selectedScreenshot = ""; constructor(t, r, o) { this.route = t, this.router = r, this.gameService = o } ngOnInit() { this.loadGameDetails(), this.loadProfile() } loadGameDetails() { const t = this.route.snapshot.paramMap.get("id"); t && this.gameService.getGameDetails(t).subscribe({ next: r => { this.gameDetails = r, this.loading = !1 }, error: r => { console.error("Error loading game details:", r), this.loading = !1 } }) } loadProfile() { this.gameService.getProfiles().subscribe({ next: t => { t && t.length > 0 && (this.profile = t[0]) }, error: t => { console.error("Error loading profile:", t) } }) } goBack() { this.router.navigate(["/games"]) } isGameInList(t, r) { return r && t.gamesIds?.includes(r) || !1 } toggleGameInList(t, r) { this.profile && r && (this.isGameInList(t, r) ? this.removeGameFromList(t, r) : this.addGameToList(t, r)) } addGameToList(t, r) { !this.profile || !t.id || !r || (this.profile.lists.forEach(o => { o.gamesIds && (o.gamesIds = o.gamesIds.filter(i => i !== r)) }), t.gamesIds || (t.gamesIds = []), t.gamesIds.push(r), this.gameService.editProfile(this.profile).subscribe({ next: o => { this.profile = o, this.showNotification("Jogo adicionado \xe0 lista com sucesso!", "success") }, error: o => { console.error("Error adding game to list:", o), this.showNotification("Erro ao adicionar jogo \xe0 lista", "error") } })) } removeGameFromList(t, r) { !this.profile || !t.gamesIds || !r || (t.gamesIds = t.gamesIds.filter(o => o !== r), this.gameService.editProfile(this.profile).subscribe({ next: o => { this.profile = o, this.showNotification("Jogo removido da lista com sucesso!", "success") }, error: o => { console.error("Error removing game from list:", o), this.showNotification("Erro ao remover jogo da lista", "error") } })) } openScreenshotModal(t) { this.selectedScreenshot = t } showNotification(t, r) { const o = document.createElement("div"); o.className = `alert alert-${"success" === r ? "success" : "danger"} position-fixed`, o.style.cssText = "top: 20px; right: 20px; z-index: 9999; min-width: 300px;", o.textContent = t, document.body.appendChild(o), setTimeout(() => { document.body.removeChild(o) }, 3e3) } static \u0275fac = function (r) { return new (r || e)(M(ao), M(Mt), M(Pa)) }; static \u0275cmp = gn({ type: e, selectors: [["app-game-details"]], standalone: !0, features: [Nn], decls: 11, vars: 3, consts: [["class", "container-fluid py-4", 4, "ngIf"], ["id", "screenshotModal", "tabindex", "-1", 1, "modal", "fade"], [1, "modal-dialog", "modal-lg"], [1, "modal-content"], [1, "modal-header"], [1, "modal-title"], ["type", "button", "data-bs-dismiss", "modal", 1, "btn-close"], [1, "modal-body", "text-center"], ["class", "img-fluid", 3, "src", 4, "ngIf"], [1, "container-fluid", "py-4"], [1, "row", "mb-4"], [1, "col-12"], [1, "btn", "btn-outline-secondary", 3, "click"], [1, "fas", "fa-arrow-left", "me-2"], [1, "col-lg-4", "col-md-5"], [1, "img-fluid", "rounded", "shadow", 3, "src", "alt"], [1, "col-lg-8", "col-md-7"], [1, "card", "h-100"], [1, "card-body"], [1, "card-title"], [1, "card-text", "text-muted"], [1, "row", "mb-3"], [1, "col-md-6"], [1, "badge", "bg-primary"], [1, "badge", "bg-secondary"], [1, "badge", "bg-success"], ["class", "mt-4", 4, "ngIf"], [1, "mt-4"], ["target", "_blank", 1, "btn", "btn-primary", "btn-lg", 3, "href"], [1, "fas", "fa-play", "me-2"], [1, "card"], [1, "card-header"], [1, "card-text", 3, "innerHTML"], ["class", "row mb-4", 4, "ngIf"], [1, "row", "g-2"], ["class", "col-md-3", 4, "ngFor", "ngForOf"], [1, "col-md-3"], [1, "btn", "w-100", 3, "click"], [1, "fas"], [1, "row"], ["class", "col-md-6", 4, "ngIf"], [1, "row", "g-3"], ["class", "col-lg-4 col-md-6", 4, "ngFor", "ngForOf"], [1, "col-lg-4", "col-md-6"], [1, "img-fluid", "rounded", "shadow-sm", 2, "cursor", "pointer", 3, "click", "src", "alt"], [1, "col-12", "text-center"], ["role", "status", 1, "spinner-border", "text-primary"], [1, "visually-hidden"], [1, "img-fluid", 3, "src"]], template: function (r, o) { 1 & r && (De(0, Z4, 63, 20, "div", 0)(1, Q4, 6, 0, "div", 0), y(2, "div", 1)(3, "div", 2)(4, "div", 3)(5, "div", 4)(6, "h5", 5), E(7, "Screenshot"), m(), k(8, "button", 6), m(), y(9, "div", 7), De(10, Y4, 1, 1, "img", 8), m()()()()), 2 & r && (P("ngIf", o.gameDetails), I(), P("ngIf", o.loading), I(9), P("ngIf", o.selectedScreenshot)) }, dependencies: [wi, ca, Di, Kl, L4] }) } return e })() }, { title: "FreePlayFinder - Perfil", path: "profile", component: (() => { class e { gameService; router; profile = null; originalProfile = null; newPassword = ""; confirmPassword = ""; saving = !1; constructor(t, r) { this.gameService = t, this.router = r } ngOnInit() { this.loadProfile() } loadProfile() { this.gameService.getProfiles().subscribe({ next: t => { t && t.length > 0 && (this.profile = { ...t[0] }, this.originalProfile = { ...t[0] }) }, error: t => { console.error("Error loading profile:", t) } }) } getInitials(t) { return t.split(" ").map(r => r.charAt(0)).join("").toUpperCase() } getAvatarColor(t) { const r = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7", "#DDA0DD", "#98D8C8", "#F7DC6F", "#BB8FCE", "#85C1E9"]; return r[t.charCodeAt(0) % r.length] } getListIcon(t) { return { "Play Later": "fa-clock", "Currently Playing": "fa-play", Played: "fa-check", Completed: "fa-trophy" }[t] || "fa-list" } removeAvatar() { this.profile && (this.profile.avatar = "") } generateRandomAvatar() { const t = ["https://api.dicebear.com/7.x/avataaars/svg?seed=Felix", "https://api.dicebear.com/7.x/avataaars/svg?seed=Aneka", "https://api.dicebear.com/7.x/avataaars/svg?seed=Jasper", "https://api.dicebear.com/7.x/avataaars/svg?seed=Lily", "https://api.dicebear.com/7.x/avataaars/svg?seed=Midnight"]; this.profile && (this.profile.avatar = t[Math.floor(Math.random() * t.length)]) } saveProfile() { if (this.profile) { if (this.newPassword && this.newPassword !== this.confirmPassword) return void this.showNotification("As senhas n\xe3o coincidem", "error"); this.newPassword && (this.profile.password = this.newPassword), this.saving = !0, this.gameService.editProfile(this.profile).subscribe({ next: t => { this.profile = t, this.originalProfile = { ...t }, this.newPassword = "", this.confirmPassword = "", this.saving = !1, this.showNotification("Perfil atualizado com sucesso!", "success") }, error: t => { console.error("Error updating profile:", t), this.saving = !1, this.showNotification("Erro ao atualizar perfil", "error") } }) } } cancelEdit() { this.originalProfile && (this.profile = { ...this.originalProfile }), this.newPassword = "", this.confirmPassword = "", this.router.navigate(["/games"]) } showNotification(t, r) { const o = document.createElement("div"); o.className = `alert alert-${"success" === r ? "success" : "danger"} position-fixed`, o.style.cssText = "top: 20px; right: 20px; z-index: 9999; min-width: 300px;", o.textContent = t, document.body.appendChild(o), setTimeout(() => { document.body.removeChild(o) }, 3e3) } getTotalGames() { return this.profile?.lists ? this.profile.lists.reduce((t, r) => t + (r.gamesIds?.length || 0), 0) : 0 } trackByListId(t, r) { return r.id || t } getListProgress(t) { return t.gamesIds?.length ? Math.min(100, t.gamesIds.length / 10 * 100) : 0 } static \u0275fac = function (r) { return new (r || e)(M(Pa), M(Mt)) }; static \u0275cmp = gn({ type: e, selectors: [["app-profile"]], standalone: !0, features: [Nn], decls: 99, vars: 20, consts: [["profileForm", "ngForm"], [1, "profile-container"], [1, "container-fluid", "py-5"], [1, "row", "justify-content-center"], [1, "col-lg-10", "col-xl-8"], [1, "profile-header", "mb-4"], [1, "d-flex", "align-items-center"], [1, "profile-avatar", "me-4"], ["class", "rounded-circle", "width", "120", "height", "120", "style", "object-fit: cover;", 3, "src", "alt", 4, "ngIf"], ["class", "avatar-placeholder rounded-circle d-flex align-items-center justify-content-center", "style", "width: 120px; height: 120px; color: white; font-size: 2.5rem; font-weight: bold;", 3, "background-color", 4, "ngIf"], [1, "profile-info"], [1, "profile-name", "mb-2"], [1, "profile-email", "text-muted", "mb-3"], [1, "profile-stats", "d-flex", "gap-4"], [1, "stat-item"], [1, "stat-number"], [1, "stat-label"], [1, "row"], [1, "col-lg-8"], [1, "card", "profile-card"], [1, "card-header"], [1, "mb-0"], [1, "fas", "fa-user-edit", "me-2"], [1, "card-body"], [3, "ngSubmit"], [1, "row", "g-4"], [1, "col-12"], [1, "avatar-section"], [1, "form-label", "fw-bold"], [1, "fas", "fa-camera", "me-2"], [1, "avatar-controls"], [1, "avatar-preview", "mb-3"], ["class", "rounded-circle", "width", "100", "height", "100", "style", "object-fit: cover;", 3, "src", "alt", 4, "ngIf"], ["class", "avatar-placeholder rounded-circle d-flex align-items-center justify-content-center", "style", "width: 100px; height: 100px; color: white; font-size: 2rem; font-weight: bold;", 3, "background-color", 4, "ngIf"], [1, "avatar-actions"], [1, "mb-3"], ["type", "url", "id", "avatarUrl", "name", "avatar", "placeholder", "https://exemplo.com/foto.jpg", 1, "form-control", 3, "ngModelChange", "ngModel"], [1, "form-text"], ["role", "group", 1, "btn-group"], ["type", "button", 1, "btn", "btn-outline-danger", "btn-sm", 3, "click"], [1, "fas", "fa-trash", "me-1"], ["type", "button", 1, "btn", "btn-outline-primary", "btn-sm", 3, "click"], [1, "fas", "fa-random", "me-1"], [1, "col-md-6"], ["for", "name", 1, "form-label", "fw-bold"], [1, "fas", "fa-user", "me-2"], ["type", "text", "id", "name", "name", "name", "required", "", 1, "form-control", 3, "ngModelChange", "ngModel"], ["for", "email", 1, "form-label", "fw-bold"], [1, "fas", "fa-envelope", "me-2"], ["type", "email", "id", "email", "name", "email", "required", "", 1, "form-control", 3, "ngModelChange", "ngModel"], [1, "password-section"], [1, "fw-bold", "mb-3"], [1, "fas", "fa-lock", "me-2"], [1, "row", "g-3"], ["for", "password", 1, "form-label"], ["type", "password", "id", "password", "name", "password", "placeholder", "Deixe em branco para manter a atual", 1, "form-control", 3, "ngModelChange", "ngModel"], ["for", "confirmPassword", 1, "form-label"], ["type", "password", "id", "confirmPassword", "name", "confirmPassword", 1, "form-control", 3, "ngModelChange", "ngModel"], [1, "d-flex", "justify-content-end", "gap-3", "mt-4", "pt-4", "border-top"], ["type", "button", 1, "btn", "btn-outline-secondary", 3, "click"], [1, "fas", "fa-times", "me-2"], ["type", "submit", 1, "btn", "btn-primary", 3, "disabled"], ["class", "spinner-border spinner-border-sm me-2", 4, "ngIf"], ["class", "fas fa-save me-2", 4, "ngIf"], [1, "col-lg-4"], [1, "card", "lists-card"], [1, "fas", "fa-list", "me-2"], [1, "lists-summary"], ["class", "list-item", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "text-center mt-3", 4, "ngIf"], ["width", "120", "height", "120", 1, "rounded-circle", 2, "object-fit", "cover", 3, "src", "alt"], [1, "avatar-placeholder", "rounded-circle", "d-flex", "align-items-center", "justify-content-center", 2, "width", "120px", "height", "120px", "color", "white", "font-size", "2.5rem", "font-weight", "bold"], ["width", "100", "height", "100", 1, "rounded-circle", 2, "object-fit", "cover", 3, "src", "alt"], [1, "avatar-placeholder", "rounded-circle", "d-flex", "align-items-center", "justify-content-center", 2, "width", "100px", "height", "100px", "color", "white", "font-size", "2rem", "font-weight", "bold"], [1, "spinner-border", "spinner-border-sm", "me-2"], [1, "fas", "fa-save", "me-2"], [1, "list-item"], [1, "list-header"], [1, "list-icon"], [1, "fas"], [1, "list-info"], [1, "list-name", "mb-1"], [1, "list-count"], [1, "list-progress"], [1, "progress", 2, "height", "4px"], [1, "progress-bar"], [1, "text-center", "mt-3"], [1, "fas", "fa-inbox", "fa-2x", "text-muted", "mb-2"], [1, "text-muted", "mb-0"], ["routerLink", "/lists", 1, "btn", "btn-sm", "btn-outline-primary", "mt-2"], [1, "fas", "fa-plus", "me-1"]], template: function (r, o) { if (1 & r) { const i = Tn(); y(0, "div", 1)(1, "div", 2)(2, "div", 3)(3, "div", 4)(4, "div", 5)(5, "div", 6)(6, "div", 7), De(7, X4, 1, 2, "img", 8)(8, K4, 2, 3, "div", 9), m(), y(9, "div", 10)(10, "h2", 11), E(11), m(), y(12, "p", 12), E(13), m(), y(14, "div", 13)(15, "div", 14)(16, "span", 15), E(17), m(), y(18, "span", 16), E(19, "Listas"), m()(), y(20, "div", 14)(21, "span", 15), E(22), m(), y(23, "span", 16), E(24, "Jogos"), m()()()()()(), y(25, "div", 17)(26, "div", 18)(27, "div", 19)(28, "div", 20)(29, "h4", 21), k(30, "i", 22), E(31, " Editar Perfil "), m()(), y(32, "div", 23)(33, "form", 24, 0), re("ngSubmit", function () { return Ie(i), Se(o.saveProfile()) }), y(35, "div", 25)(36, "div", 26)(37, "div", 27)(38, "label", 28), k(39, "i", 29), E(40, " Foto de Perfil "), m(), y(41, "div", 30)(42, "div", 31), De(43, e5, 1, 2, "img", 32)(44, t5, 2, 3, "div", 33), m(), y(45, "div", 34)(46, "div", 35)(47, "input", 36), an("ngModelChange", function (a) { return Ie(i), An(o.profile.avatar, a) || (o.profile.avatar = a), Se(a) }), m(), y(48, "div", 37), E(49, "Cole aqui o link da sua foto de perfil"), m()(), y(50, "div", 38)(51, "button", 39), re("click", function () { return Ie(i), Se(o.removeAvatar()) }), k(52, "i", 40), E(53, "Remover "), m(), y(54, "button", 41), re("click", function () { return Ie(i), Se(o.generateRandomAvatar()) }), k(55, "i", 42), E(56, "Gerar Avatar "), m()()()()()(), y(57, "div", 43)(58, "label", 44), k(59, "i", 45), E(60, " Nome Completo "), m(), y(61, "input", 46), an("ngModelChange", function (a) { return Ie(i), An(o.profile.name, a) || (o.profile.name = a), Se(a) }), m()(), y(62, "div", 43)(63, "label", 47), k(64, "i", 48), E(65, " Email "), m(), y(66, "input", 49), an("ngModelChange", function (a) { return Ie(i), An(o.profile.email, a) || (o.profile.email = a), Se(a) }), m()(), y(67, "div", 26)(68, "div", 50)(69, "h6", 51), k(70, "i", 52), E(71, " Alterar Senha "), m(), y(72, "div", 53)(73, "div", 43)(74, "label", 54), E(75, "Nova Senha"), m(), y(76, "input", 55), an("ngModelChange", function (a) { return Ie(i), An(o.newPassword, a) || (o.newPassword = a), Se(a) }), m()(), y(77, "div", 43)(78, "label", 56), E(79, "Confirmar Nova Senha"), m(), y(80, "input", 57), an("ngModelChange", function (a) { return Ie(i), An(o.confirmPassword, a) || (o.confirmPassword = a), Se(a) }), m()()()()()(), y(81, "div", 58)(82, "button", 59), re("click", function () { return Ie(i), Se(o.cancelEdit()) }), k(83, "i", 60), E(84, "Cancelar "), m(), y(85, "button", 61), De(86, n5, 1, 0, "span", 62)(87, r5, 1, 0, "i", 63), E(88), m()()()()()(), y(89, "div", 64)(90, "div", 65)(91, "div", 20)(92, "h5", 21), k(93, "i", 66), E(94, " Minhas Listas "), m()(), y(95, "div", 23)(96, "div", 67), De(97, o5, 12, 6, "div", 68)(98, i5, 7, 0, "div", 69), m()()()()()()()()() } if (2 & r) { const i = Yw(34); I(7), P("ngIf", null == o.profile ? null : o.profile.avatar), I(), P("ngIf", !(null != o.profile && o.profile.avatar)), I(3), Me((null == o.profile ? null : o.profile.name) || "Usu\xe1rio"), I(2), Me((null == o.profile ? null : o.profile.email) || "email@exemplo.com"), I(4), Me((null == o.profile || null == o.profile.lists ? null : o.profile.lists.length) || 0), I(5), Me(o.getTotalGames()), I(21), P("ngIf", null == o.profile ? null : o.profile.avatar), I(), P("ngIf", !(null != o.profile && o.profile.avatar)), I(3), sn("ngModel", o.profile.avatar), I(14), sn("ngModel", o.profile.name), I(5), sn("ngModel", o.profile.email), I(10), sn("ngModel", o.newPassword), I(4), sn("ngModel", o.confirmPassword), I(5), P("disabled", !i.valid || o.saving), I(), P("ngIf", o.saving), I(), P("ngIf", !o.saving), I(), Ae(" ", o.saving ? "Salvando..." : "Salvar Altera\xe7\xf5es", " "), I(9), P("ngForOf", null == o.profile ? null : o.profile.lists)("ngForTrackBy", o.trackByListId), I(), P("ngIf", !(null != o.profile && null != o.profile.lists && o.profile.lists.length)) } }, dependencies: [wi, ca, Di, fS, z0, Sa, qg, O0, $u, Bu, ju], styles: [".profile-container[_ngcontent-%COMP%]{background:linear-gradient(135deg,#f8f9fa,#e9ecef);min-height:100vh}.profile-header[_ngcontent-%COMP%]{background:#fff;border-radius:1rem;padding:2rem;box-shadow:0 4px 20px #00000014;border:1px solid rgba(102,126,234,.1)}.profile-header[_ngcontent-%COMP%]   .profile-avatar[_ngcontent-%COMP%]{position:relative}.profile-header[_ngcontent-%COMP%]   .profile-avatar[_ngcontent-%COMP%]   img[_ngcontent-%COMP%], .profile-header[_ngcontent-%COMP%]   .profile-avatar[_ngcontent-%COMP%]   .avatar-placeholder[_ngcontent-%COMP%]{border:4px solid white;box-shadow:0 8px 25px #00000026;transition:all .3s ease}.profile-header[_ngcontent-%COMP%]   .profile-avatar[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]:hover, .profile-header[_ngcontent-%COMP%]   .profile-avatar[_ngcontent-%COMP%]   .avatar-placeholder[_ngcontent-%COMP%]:hover{transform:scale(1.05);box-shadow:0 12px 35px #0003}.profile-header[_ngcontent-%COMP%]   .profile-info[_ngcontent-%COMP%]   .profile-name[_ngcontent-%COMP%]{background:linear-gradient(135deg,#667eea,#764ba2);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;font-weight:700;font-size:2rem}.profile-header[_ngcontent-%COMP%]   .profile-info[_ngcontent-%COMP%]   .profile-email[_ngcontent-%COMP%]{font-size:1.1rem}.profile-header[_ngcontent-%COMP%]   .profile-info[_ngcontent-%COMP%]   .profile-stats[_ngcontent-%COMP%]   .stat-item[_ngcontent-%COMP%]{text-align:center;padding:1rem;background:#667eea0d;border-radius:.75rem;border:1px solid rgba(102,126,234,.1);transition:all .3s ease}.profile-header[_ngcontent-%COMP%]   .profile-info[_ngcontent-%COMP%]   .profile-stats[_ngcontent-%COMP%]   .stat-item[_ngcontent-%COMP%]:hover{background:#667eea1a;transform:translateY(-2px)}.profile-header[_ngcontent-%COMP%]   .profile-info[_ngcontent-%COMP%]   .profile-stats[_ngcontent-%COMP%]   .stat-item[_ngcontent-%COMP%]   .stat-number[_ngcontent-%COMP%]{display:block;font-size:1.5rem;font-weight:700;color:#667eea}.profile-header[_ngcontent-%COMP%]   .profile-info[_ngcontent-%COMP%]   .profile-stats[_ngcontent-%COMP%]   .stat-item[_ngcontent-%COMP%]   .stat-label[_ngcontent-%COMP%]{font-size:.875rem;color:#6c757d;font-weight:500}.profile-card[_ngcontent-%COMP%], .lists-card[_ngcontent-%COMP%]{border:none;border-radius:1rem;box-shadow:0 4px 20px #00000014;transition:all .3s ease}.profile-card[_ngcontent-%COMP%]:hover, .lists-card[_ngcontent-%COMP%]:hover{box-shadow:0 8px 30px #0000001f;transform:translateY(-2px)}.profile-card[_ngcontent-%COMP%]   .card-header[_ngcontent-%COMP%], .lists-card[_ngcontent-%COMP%]   .card-header[_ngcontent-%COMP%]{background:linear-gradient(135deg,#667eea,#764ba2);color:#fff;border-radius:1rem 1rem 0 0!important;border:none;padding:1.5rem}.profile-card[_ngcontent-%COMP%]   .card-header[_ngcontent-%COMP%]   h4[_ngcontent-%COMP%], .profile-card[_ngcontent-%COMP%]   .card-header[_ngcontent-%COMP%]   h5[_ngcontent-%COMP%], .lists-card[_ngcontent-%COMP%]   .card-header[_ngcontent-%COMP%]   h4[_ngcontent-%COMP%], .lists-card[_ngcontent-%COMP%]   .card-header[_ngcontent-%COMP%]   h5[_ngcontent-%COMP%]{margin:0;font-weight:600}.profile-card[_ngcontent-%COMP%]   .card-body[_ngcontent-%COMP%], .lists-card[_ngcontent-%COMP%]   .card-body[_ngcontent-%COMP%]{padding:2rem}.avatar-section[_ngcontent-%COMP%]   .avatar-controls[_ngcontent-%COMP%]{display:flex;align-items:center;gap:2rem}.avatar-section[_ngcontent-%COMP%]   .avatar-controls[_ngcontent-%COMP%]   .avatar-preview[_ngcontent-%COMP%]{flex-shrink:0}.avatar-section[_ngcontent-%COMP%]   .avatar-controls[_ngcontent-%COMP%]   .avatar-preview[_ngcontent-%COMP%]   img[_ngcontent-%COMP%], .avatar-section[_ngcontent-%COMP%]   .avatar-controls[_ngcontent-%COMP%]   .avatar-preview[_ngcontent-%COMP%]   .avatar-placeholder[_ngcontent-%COMP%]{border:3px solid #e9ecef;transition:all .3s ease}.avatar-section[_ngcontent-%COMP%]   .avatar-controls[_ngcontent-%COMP%]   .avatar-preview[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]:hover, .avatar-section[_ngcontent-%COMP%]   .avatar-controls[_ngcontent-%COMP%]   .avatar-preview[_ngcontent-%COMP%]   .avatar-placeholder[_ngcontent-%COMP%]:hover{border-color:#667eea;transform:scale(1.05)}.avatar-section[_ngcontent-%COMP%]   .avatar-controls[_ngcontent-%COMP%]   .avatar-actions[_ngcontent-%COMP%]{flex:1}.avatar-section[_ngcontent-%COMP%]   .avatar-controls[_ngcontent-%COMP%]   .avatar-actions[_ngcontent-%COMP%]   .btn-group[_ngcontent-%COMP%]   .btn[_ngcontent-%COMP%]{border-radius:.5rem;font-weight:500;transition:all .3s ease}.avatar-section[_ngcontent-%COMP%]   .avatar-controls[_ngcontent-%COMP%]   .avatar-actions[_ngcontent-%COMP%]   .btn-group[_ngcontent-%COMP%]   .btn[_ngcontent-%COMP%]:hover{transform:translateY(-1px)}.password-section[_ngcontent-%COMP%]{background:#667eea05;border:1px solid rgba(102,126,234,.1);border-radius:.75rem;padding:1.5rem;margin-top:1rem}.password-section[_ngcontent-%COMP%]   h6[_ngcontent-%COMP%]{color:#667eea;margin-bottom:1rem}.lists-card[_ngcontent-%COMP%]   .lists-summary[_ngcontent-%COMP%]   .list-item[_ngcontent-%COMP%]{padding:1rem;border:1px solid #e9ecef;border-radius:.75rem;margin-bottom:1rem;transition:all .3s ease}.lists-card[_ngcontent-%COMP%]   .lists-summary[_ngcontent-%COMP%]   .list-item[_ngcontent-%COMP%]:hover{border-color:#667eea;box-shadow:0 4px 15px #667eea1a;transform:translate(5px)}.lists-card[_ngcontent-%COMP%]   .lists-summary[_ngcontent-%COMP%]   .list-item[_ngcontent-%COMP%]:last-child{margin-bottom:0}.lists-card[_ngcontent-%COMP%]   .lists-summary[_ngcontent-%COMP%]   .list-item[_ngcontent-%COMP%]   .list-header[_ngcontent-%COMP%]{display:flex;align-items:center;gap:1rem;margin-bottom:.75rem}.lists-card[_ngcontent-%COMP%]   .lists-summary[_ngcontent-%COMP%]   .list-item[_ngcontent-%COMP%]   .list-header[_ngcontent-%COMP%]   .list-icon[_ngcontent-%COMP%]{width:40px;height:40px;background:linear-gradient(135deg,#667eea,#764ba2);border-radius:50%;display:flex;align-items:center;justify-content:center;color:#fff;font-size:1rem}.lists-card[_ngcontent-%COMP%]   .lists-summary[_ngcontent-%COMP%]   .list-item[_ngcontent-%COMP%]   .list-header[_ngcontent-%COMP%]   .list-info[_ngcontent-%COMP%]{flex:1}.lists-card[_ngcontent-%COMP%]   .lists-summary[_ngcontent-%COMP%]   .list-item[_ngcontent-%COMP%]   .list-header[_ngcontent-%COMP%]   .list-info[_ngcontent-%COMP%]   .list-name[_ngcontent-%COMP%]{font-weight:600;color:#495057;margin:0}.lists-card[_ngcontent-%COMP%]   .lists-summary[_ngcontent-%COMP%]   .list-item[_ngcontent-%COMP%]   .list-header[_ngcontent-%COMP%]   .list-info[_ngcontent-%COMP%]   .list-count[_ngcontent-%COMP%]{font-size:.875rem;color:#6c757d;font-weight:500}.lists-card[_ngcontent-%COMP%]   .lists-summary[_ngcontent-%COMP%]   .list-item[_ngcontent-%COMP%]   .list-progress[_ngcontent-%COMP%]   .progress[_ngcontent-%COMP%]{background-color:#e9ecef;border-radius:.25rem;overflow:hidden}.lists-card[_ngcontent-%COMP%]   .lists-summary[_ngcontent-%COMP%]   .list-item[_ngcontent-%COMP%]   .list-progress[_ngcontent-%COMP%]   .progress[_ngcontent-%COMP%]   .progress-bar[_ngcontent-%COMP%]{background:linear-gradient(135deg,#667eea,#764ba2);transition:width .6s ease}.form-label[_ngcontent-%COMP%]{font-weight:600;color:#495057;margin-bottom:.5rem}.form-label[_ngcontent-%COMP%]   i[_ngcontent-%COMP%]{color:#667eea}.form-control[_ngcontent-%COMP%]{border-radius:.5rem;border:2px solid #e9ecef;padding:.75rem 1rem;transition:all .3s ease}.form-control[_ngcontent-%COMP%]:focus{border-color:#667eea;box-shadow:0 0 0 .2rem #667eea40}.btn[_ngcontent-%COMP%]{border-radius:.5rem;font-weight:500;padding:.75rem 1.5rem;transition:all .3s ease}.btn[_ngcontent-%COMP%]:hover{transform:translateY(-2px)}.btn.btn-primary[_ngcontent-%COMP%]{background:linear-gradient(135deg,#667eea,#764ba2);border:none}.btn.btn-primary[_ngcontent-%COMP%]:hover{box-shadow:0 5px 15px #667eea66}.btn.btn-outline-secondary[_ngcontent-%COMP%]{border-color:#6c757d;color:#6c757d}.btn.btn-outline-secondary[_ngcontent-%COMP%]:hover{background-color:#6c757d;border-color:#6c757d}.btn.btn-outline-danger[_ngcontent-%COMP%]{border-color:#dc3545;color:#dc3545}.btn.btn-outline-danger[_ngcontent-%COMP%]:hover{background-color:#dc3545;border-color:#dc3545}@media (max-width: 991.98px){.profile-header[_ngcontent-%COMP%]   .profile-info[_ngcontent-%COMP%]{margin-top:1.5rem;text-align:center}.avatar-section[_ngcontent-%COMP%]   .avatar-controls[_ngcontent-%COMP%]{flex-direction:column;align-items:center;text-align:center}}@media (max-width: 767.98px){.profile-container[_ngcontent-%COMP%]   .container-fluid[_ngcontent-%COMP%]{padding:1rem}.profile-header[_ngcontent-%COMP%]{padding:1.5rem}.profile-header[_ngcontent-%COMP%]   .profile-stats[_ngcontent-%COMP%]{justify-content:center}.profile-card[_ngcontent-%COMP%]   .card-body[_ngcontent-%COMP%], .lists-card[_ngcontent-%COMP%]   .card-body[_ngcontent-%COMP%]{padding:1.5rem}}"] }) } return e })() }, { title: "FreePlayFinder - Minhas Listas", path: "lists", component: (() => { class e { gameService; router; profile = null; games = []; loading = !0; selectedList = null; selectedGameId = ""; constructor(t, r) { this.gameService = t, this.router = r } ngOnInit() { this.loadProfile(), this.loadGames() } loadProfile() { this.gameService.getProfiles().subscribe({ next: t => { t && t.length > 0 && (this.profile = t[0]), this.loading = !1 }, error: t => { console.error("Error loading profile:", t), this.loading = !1 } }) } loadGames() { this.gameService.getGames().subscribe({ next: t => { this.games = t }, error: t => { console.error("Error loading games:", t) } }) } getGamesInList(t) { return t.gamesIds && this.games.length ? this.games.filter(r => t.gamesIds?.includes(r.id || "")) : [] } getListIcon(t) { return t && { "Play Later": "fa-clock", "Currently Playing": "fa-play", Played: "fa-check", Completed: "fa-trophy" }[t] || "fa-list" } viewGameDetails(t) { this.router.navigate(["/game", t]) } moveGame(t, r) { this.selectedList = t, this.selectedGameId = r, console.log(`Moving game ${r} from list ${t.name}`) } confirmMoveGame(t) { !this.selectedList || !this.selectedGameId || !this.profile || (this.selectedList.gamesIds && (this.selectedList.gamesIds = this.selectedList.gamesIds.filter(r => r !== this.selectedGameId)), t.gamesIds || (t.gamesIds = []), t.gamesIds.push(this.selectedGameId), this.gameService.editProfile(this.profile).subscribe({ next: r => { this.profile = r, this.showNotification("Jogo movido com sucesso!", "success"), this.selectedList = null, this.selectedGameId = "" }, error: r => { console.error("Error moving game:", r), this.showNotification("Erro ao mover jogo", "error") } })) } removeGameFromList(t, r) { !this.profile || !t.gamesIds || (t.gamesIds = t.gamesIds.filter(o => o !== r), this.gameService.editProfile(this.profile).subscribe({ next: o => { this.profile = o, this.showNotification("Jogo removido da lista com sucesso!", "success") }, error: o => { console.error("Error removing game from list:", o), this.showNotification("Erro ao remover jogo da lista", "error") } })) } moveAllGames(t) { console.log(`Moving all games from list ${t.name}`) } clearList(t) { this.profile && confirm(`Tem certeza que deseja limpar a lista "${t.name}"?`) && (t.gamesIds = [], this.gameService.editProfile(this.profile).subscribe({ next: r => { this.profile = r, this.showNotification("Lista limpa com sucesso!", "success") }, error: r => { console.error("Error clearing list:", r), this.showNotification("Erro ao limpar lista", "error") } })) } showNotification(t, r) { const o = document.createElement("div"); o.className = `alert alert-${"success" === r ? "success" : "danger"} position-fixed`, o.style.cssText = "top: 20px; right: 20px; z-index: 9999; min-width: 300px;", o.textContent = t, document.body.appendChild(o), setTimeout(() => { document.body.removeChild(o) }, 3e3) } static \u0275fac = function (r) { return new (r || e)(M(Pa), M(Mt)) }; static \u0275cmp = gn({ type: e, selectors: [["app-game-lists"]], standalone: !0, features: [Nn], decls: 26, vars: 4, consts: [[1, "container-fluid", "py-4"], [1, "row", "mb-4"], [1, "col-12"], [1, "text-muted"], ["id", "listsTab", "role", "tablist", 1, "nav", "nav-tabs"], ["class", "nav-item", "role", "presentation", 4, "ngFor", "ngForOf"], ["id", "listsTabContent", 1, "tab-content"], ["class", "tab-pane fade", "role", "tabpanel", 3, "show", "active", "id", 4, "ngFor", "ngForOf"], ["class", "row", 4, "ngIf"], ["id", "moveGameModal", "tabindex", "-1", 1, "modal", "fade"], [1, "modal-dialog"], [1, "modal-content"], [1, "modal-header"], [1, "modal-title"], ["type", "button", "data-bs-dismiss", "modal", 1, "btn-close"], [1, "modal-body"], [1, "d-grid", "gap-2"], ["class", "btn btn-outline-primary", 3, "disabled", "click", 4, "ngFor", "ngForOf"], ["role", "presentation", 1, "nav-item"], ["data-bs-toggle", "tab", "type", "button", "role", "tab", 1, "nav-link", 3, "id"], [1, "fas", "me-2"], [1, "badge", "bg-secondary", "ms-2"], ["role", "tabpanel", 1, "tab-pane", "fade", 3, "id"], [1, "row"], [1, "col-12", "mb-3"], [1, "d-flex", "justify-content-between", "align-items-center"], ["role", "group", 1, "btn-group"], [1, "btn", "btn-outline-primary", "btn-sm", 3, "click"], [1, "fas", "fa-exchange-alt", "me-1"], [1, "btn", "btn-outline-danger", "btn-sm", 3, "click"], [1, "fas", "fa-trash", "me-1"], ["class", "col-lg-3 col-md-4 col-sm-6 mb-4", 4, "ngFor", "ngForOf"], [1, "col-lg-3", "col-md-4", "col-sm-6", "mb-4"], [1, "card", "h-100", "game-card"], [1, "card-img-top", 2, "height", "200px", "object-fit", "cover", 3, "src", "alt"], [1, "card-body", "d-flex", "flex-column"], [1, "card-title"], [1, "card-text", "flex-grow-1"], [1, "mt-auto"], [1, "d-flex", "justify-content-between", "align-items-center", "mb-2"], [1, "badge", "bg-primary"], [1, "badge", "bg-secondary"], [1, "btn-group", "btn-group-sm"], [1, "btn", "btn-outline-primary", 3, "click"], [1, "fas", "fa-eye"], [1, "btn", "btn-outline-warning", 3, "click"], [1, "fas", "fa-exchange-alt"], [1, "btn", "btn-outline-danger", 3, "click"], [1, "fas", "fa-trash"], [1, "col-12", "text-center"], [1, "alert", "alert-info"], [1, "fas", "fa-info-circle", "fa-2x", "mb-3"], ["routerLink", "/games", 1, "btn", "btn-primary"], [1, "fas", "fa-search", "me-2"], ["role", "status", 1, "spinner-border", "text-primary"], [1, "visually-hidden"], [1, "btn", "btn-outline-primary", 3, "click", "disabled"]], template: function (r, o) { 1 & r && (y(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "h2"), E(4, "Minhas Listas de Jogos"), m(), y(5, "p", 3), E(6, "Gerencie seus jogos favoritos organizados em listas personalizadas"), m()()(), y(7, "div", 1)(8, "div", 2)(9, "ul", 4), De(10, a5, 6, 8, "li", 5), m()()(), y(11, "div", 6), De(12, d5, 15, 8, "div", 7), m(), De(13, f5, 5, 0, "div", 8), m(), y(14, "div", 9)(15, "div", 10)(16, "div", 11)(17, "div", 12)(18, "h5", 13), E(19, "Mover Jogo"), m(), k(20, "button", 14), m(), y(21, "div", 15)(22, "p"), E(23, "Selecione a lista de destino:"), m(), y(24, "div", 16), De(25, h5, 3, 4, "button", 17), m()()()()()), 2 & r && (I(10), P("ngForOf", null == o.profile ? null : o.profile.lists), I(2), P("ngForOf", null == o.profile ? null : o.profile.lists), I(), P("ngIf", o.loading), I(12), P("ngForOf", null == o.profile ? null : o.profile.lists)) }, dependencies: [wi, ca, Di, Jp, Kl] }) } return e })() }], g5 = { providers: [function WL(e) { const n = e?.ignoreChangesOutsideZone, t = e?.scheduleInRootZone, r = Ep({ ngZoneFactory: () => { const o = Mp(e); return o.scheduleInRootZone = t, o.shouldCoalesceEventChangeDetection && ht("NgZone_CoalesceEvent"), new ie(o) }, ignoreChangesOutsideZone: n, scheduleInRootZone: t }); return Eo([{ provide: qL, useValue: !0 }, { provide: Ns, useValue: !1 }, r]) }({ eventCoalescing: !0 }), function F3(e, ...n) { return Eo([{ provide: Fi, multi: !0, useValue: e }, [], { provide: ao, useFactory: KI, deps: [Mt] }, { provide: Ks, multi: !0, useFactory: e0 }, n.map(t => t.\u0275providers)]) }(p5), function C4(...e) { const n = [CS, SS, MS, { provide: Hu, useExisting: MS }, { provide: Gu, useFactory: () => b(dm, { optional: !0 }) ?? b(SS) }, { provide: Ra, useValue: _4, multi: !0 }, { provide: hm, useValue: !0 }, { provide: NS, useClass: y4 }]; for (const t of e) n.push(...t.\u0275providers); return Eo(n) }()] }; function m5(e, n) { if (1 & e && k(0, "img", 30), 2 & e) { const t = z(2); P("src", t.profile.avatar, en)("alt", t.profile.name) } } function v5(e, n) { if (1 & e && (y(0, "div", 31), E(1), m()), 2 & e) { const t = z(2); hi("background-color", t.getAvatarColor(t.profile.name)), I(), Ae(" ", t.getInitials(t.profile.name), " ") } } function y5(e, n) { if (1 & e) { const t = Tn(); y(0, "div", 16)(1, "div", 17)(2, "a", 18)(3, "div", 19), De(4, m5, 1, 2, "img", 20)(5, v5, 2, 3, "div", 21), m(), y(6, "span", 22), E(7), m(), k(8, "i", 23), m(), y(9, "ul", 24)(10, "li")(11, "a", 25), k(12, "i", 26), E(13, " Editar Perfil "), m()(), y(14, "li"), k(15, "hr", 27), m(), y(16, "li")(17, "a", 28), re("click", function () { return Ie(t), Se(z().logout()) }), k(18, "i", 29), E(19, " Sair "), m()()()()() } if (2 & e) { const t = z(); I(4), P("ngIf", t.profile.avatar), I(), P("ngIf", !t.profile.avatar), I(2), Me(t.profile.name) } } let _5 = (() => { class e { gameService; profile = null; constructor(t) { this.gameService = t } ngOnInit() { this.loadProfile() } loadProfile() { this.gameService.getProfiles().subscribe({ next: t => { t && t.length > 0 && (this.profile = t[0]) }, error: t => { console.error("Error loading profile:", t) } }) } getInitials(t) { return t.split(" ").map(r => r.charAt(0)).join("").toUpperCase() } getAvatarColor(t) { const r = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7", "#DDA0DD", "#98D8C8", "#F7DC6F", "#BB8FCE", "#85C1E9"]; return r[t.charCodeAt(0) % r.length] } logout() { window.location.reload() } static \u0275fac = function (r) { return new (r || e)(M(Pa)) }; static \u0275cmp = gn({ type: e, selectors: [["app-navbar"]], standalone: !0, features: [Nn], decls: 22, vars: 1, consts: [[1, "navbar", "navbar-expand-lg", "navbar-dark"], [1, "container"], ["routerLink", "/games", 1, "navbar-brand", "d-flex", "align-items-center"], [1, "brand-icon", "me-2"], [1, "fas", "fa-gamepad"], [1, "brand-text"], ["type", "button", "data-bs-toggle", "collapse", "data-bs-target", "#navbarNav", "aria-controls", "navbarNav", "aria-expanded", "false", "aria-label", "Toggle navigation", 1, "navbar-toggler", "border-0"], [1, "navbar-toggler-icon"], ["id", "navbarNav", 1, "collapse", "navbar-collapse"], [1, "navbar-nav", "me-auto"], [1, "nav-item"], ["routerLink", "/games", "routerLinkActive", "active", 1, "nav-link", "d-flex", "align-items-center"], [1, "fas", "fa-list", "me-2"], ["routerLink", "/lists", "routerLinkActive", "active", 1, "nav-link", "d-flex", "align-items-center"], [1, "fas", "fa-bookmark", "me-2"], ["class", "navbar-nav ms-auto", 4, "ngIf"], [1, "navbar-nav", "ms-auto"], [1, "nav-item", "dropdown"], ["href", "#", "role", "button", "data-bs-toggle", "dropdown", "aria-expanded", "false", 1, "nav-link", "dropdown-toggle", "d-flex", "align-items-center", "user-profile"], [1, "avatar", "me-2"], ["class", "rounded-circle", "width", "36", "height", "36", 3, "src", "alt", 4, "ngIf"], ["class", "avatar-placeholder rounded-circle d-flex align-items-center justify-content-center", 3, "background-color", 4, "ngIf"], [1, "user-name"], [1, "fas", "fa-chevron-down", "ms-1"], [1, "dropdown-menu", "dropdown-menu-end"], ["routerLink", "/profile", 1, "dropdown-item", "d-flex", "align-items-center"], [1, "fas", "fa-user-edit", "me-2"], [1, "dropdown-divider"], ["href", "#", 1, "dropdown-item", "d-flex", "align-items-center", "text-danger", 3, "click"], [1, "fas", "fa-sign-out-alt", "me-2"], ["width", "36", "height", "36", 1, "rounded-circle", 3, "src", "alt"], [1, "avatar-placeholder", "rounded-circle", "d-flex", "align-items-center", "justify-content-center"]], template: function (r, o) { 1 & r && (y(0, "nav", 0)(1, "div", 1)(2, "a", 2)(3, "div", 3), k(4, "i", 4), m(), y(5, "span", 5), E(6, "FreePlayFinder"), m()(), y(7, "button", 6), k(8, "span", 7), m(), y(9, "div", 8)(10, "ul", 9)(11, "li", 10)(12, "a", 11), k(13, "i", 12), y(14, "span"), E(15, "Jogos"), m()()(), y(16, "li", 10)(17, "a", 13), k(18, "i", 14), y(19, "span"), E(20, "Minhas Listas"), m()()()(), De(21, y5, 20, 3, "div", 15), m()()()), 2 & r && (I(21), P("ngIf", o.profile)) }, dependencies: [wi, Di, $g, Ia, jg], styles: [".navbar[_ngcontent-%COMP%]{background:linear-gradient(135deg,#667eea,#764ba2);box-shadow:0 4px 20px #0000001a;padding:1rem 0;transition:all .3s ease}.navbar[_ngcontent-%COMP%]   .navbar-brand[_ngcontent-%COMP%]{font-weight:700;font-size:1.5rem;color:#fff!important;text-decoration:none;transition:transform .2s ease}.navbar[_ngcontent-%COMP%]   .navbar-brand[_ngcontent-%COMP%]:hover{transform:scale(1.05)}.navbar[_ngcontent-%COMP%]   .navbar-brand[_ngcontent-%COMP%]   .brand-icon[_ngcontent-%COMP%]{background:#fff3;border-radius:50%;width:40px;height:40px;display:flex;align-items:center;justify-content:center;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,.3)}.navbar[_ngcontent-%COMP%]   .navbar-brand[_ngcontent-%COMP%]   .brand-icon[_ngcontent-%COMP%]   i[_ngcontent-%COMP%]{font-size:1.2rem;color:#fff}.navbar[_ngcontent-%COMP%]   .navbar-brand[_ngcontent-%COMP%]   .brand-text[_ngcontent-%COMP%]{background:linear-gradient(45deg,#fff,#f0f0f0);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;font-weight:800}.navbar[_ngcontent-%COMP%]   .navbar-toggler[_ngcontent-%COMP%]{border:none;padding:.5rem}.navbar[_ngcontent-%COMP%]   .navbar-toggler[_ngcontent-%COMP%]:focus{box-shadow:none}.navbar[_ngcontent-%COMP%]   .navbar-toggler[_ngcontent-%COMP%]   .navbar-toggler-icon[_ngcontent-%COMP%]{background-image:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'%3e%3cpath stroke='rgba%28255, 255, 255, 0.9%29' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e\")}.navbar[_ngcontent-%COMP%]   .nav-link[_ngcontent-%COMP%]{color:#ffffffe6!important;font-weight:500;padding:.75rem 1rem!important;border-radius:8px;margin:0 .25rem;transition:all .3s ease;position:relative}.navbar[_ngcontent-%COMP%]   .nav-link[_ngcontent-%COMP%]:hover{color:#fff!important;background:#ffffff1a;transform:translateY(-2px)}.navbar[_ngcontent-%COMP%]   .nav-link.active[_ngcontent-%COMP%]{color:#fff!important;background:#fff3;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,.3)}.navbar[_ngcontent-%COMP%]   .nav-link.active[_ngcontent-%COMP%]:after{content:\"\";position:absolute;bottom:0;left:50%;transform:translate(-50%);width:20px;height:2px;background:#fff;border-radius:1px}.navbar[_ngcontent-%COMP%]   .nav-link[_ngcontent-%COMP%]   i[_ngcontent-%COMP%]{font-size:.9rem}.navbar[_ngcontent-%COMP%]   .user-profile[_ngcontent-%COMP%]{background:#ffffff1a;border-radius:25px;padding:.5rem 1rem!important;border:1px solid rgba(255,255,255,.2);-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px)}.navbar[_ngcontent-%COMP%]   .user-profile[_ngcontent-%COMP%]:hover{background:#fff3;transform:translateY(-2px)}.navbar[_ngcontent-%COMP%]   .user-profile[_ngcontent-%COMP%]   .avatar[_ngcontent-%COMP%]   .avatar-placeholder[_ngcontent-%COMP%]{width:36px;height:36px;color:#fff;font-weight:700;font-size:14px;border:2px solid rgba(255,255,255,.3)}.navbar[_ngcontent-%COMP%]   .user-profile[_ngcontent-%COMP%]   .avatar[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{border:2px solid rgba(255,255,255,.3);transition:transform .2s ease}.navbar[_ngcontent-%COMP%]   .user-profile[_ngcontent-%COMP%]   .avatar[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]:hover{transform:scale(1.1)}.navbar[_ngcontent-%COMP%]   .user-profile[_ngcontent-%COMP%]   .user-name[_ngcontent-%COMP%]{font-weight:600;color:#fff}.navbar[_ngcontent-%COMP%]   .user-profile[_ngcontent-%COMP%]   .fa-chevron-down[_ngcontent-%COMP%]{font-size:.8rem;transition:transform .2s ease}.navbar[_ngcontent-%COMP%]   .user-profile[aria-expanded=true][_ngcontent-%COMP%]   .fa-chevron-down[_ngcontent-%COMP%]{transform:rotate(180deg)}.navbar[_ngcontent-%COMP%]   .dropdown-menu[_ngcontent-%COMP%]{background:#fffffff2;-webkit-backdrop-filter:blur(20px);backdrop-filter:blur(20px);border:1px solid rgba(255,255,255,.2);border-radius:12px;box-shadow:0 10px 30px #0000001a;margin-top:.5rem;padding:.5rem}.navbar[_ngcontent-%COMP%]   .dropdown-menu[_ngcontent-%COMP%]   .dropdown-item[_ngcontent-%COMP%]{border-radius:8px;padding:.75rem 1rem;font-weight:500;transition:all .2s ease}.navbar[_ngcontent-%COMP%]   .dropdown-menu[_ngcontent-%COMP%]   .dropdown-item[_ngcontent-%COMP%]:hover{background:#667eea1a;transform:translate(5px)}.navbar[_ngcontent-%COMP%]   .dropdown-menu[_ngcontent-%COMP%]   .dropdown-item.text-danger[_ngcontent-%COMP%]:hover{background:#dc35451a}.navbar[_ngcontent-%COMP%]   .dropdown-menu[_ngcontent-%COMP%]   .dropdown-item[_ngcontent-%COMP%]   i[_ngcontent-%COMP%]{width:16px;text-align:center}.navbar[_ngcontent-%COMP%]   .dropdown-menu[_ngcontent-%COMP%]   .dropdown-divider[_ngcontent-%COMP%]{border-color:#0000001a;margin:.5rem 0}@media (max-width: 991.98px){.navbar[_ngcontent-%COMP%]   .navbar-collapse[_ngcontent-%COMP%]{background:#ffffff1a;-webkit-backdrop-filter:blur(20px);backdrop-filter:blur(20px);border-radius:12px;margin-top:1rem;padding:1rem;border:1px solid rgba(255,255,255,.2)}.navbar[_ngcontent-%COMP%]   .nav-link[_ngcontent-%COMP%]{margin:.25rem 0}.navbar[_ngcontent-%COMP%]   .user-profile[_ngcontent-%COMP%]{margin-top:1rem;justify-content:center}}"] }) } return e })(), C5 = (() => { class e { static \u0275fac = function (r) { return new (r || e) }; static \u0275cmp = gn({ type: e, selectors: [["app-footer"]], standalone: !0, features: [Nn], decls: 25, vars: 0, consts: [[1, "footer"], [1, "container"], [1, "row", "align-items-center"], [1, "col-md-6"], [1, "footer-brand", "d-flex", "align-items-center"], [1, "brand-icon", "me-3"], [1, "fas", "fa-gamepad"], [1, "brand-text", "mb-1"], [1, "text-muted", "mb-0"], [1, "col-md-6", "text-md-end"], [1, "footer-links"], ["routerLink", "/games", "routerLinkActive", "active"], ["routerLink", "/lists", "routerLinkActive", "active"], ["routerLink", "/profile", "routerLinkActive", "active"], [1, "footer-bottom"], [1, "col-12", "text-center"], [1, "mb-0", "text-muted"]], template: function (r, o) { 1 & r && (y(0, "footer", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "div", 4)(5, "div", 5), k(6, "i", 6), m(), y(7, "div")(8, "h5", 7), E(9, "FreePlayFinder"), m(), y(10, "p", 8), E(11, "Descubra seus pr\xf3ximos jogos favoritos gratuitos"), m()()()(), y(12, "div", 9)(13, "div", 10)(14, "a", 11), E(15, "Jogos"), m(), y(16, "a", 12), E(17, "Minhas Listas"), m(), y(18, "a", 13), E(19, "Perfil"), m()()()(), y(20, "div", 14)(21, "div", 2)(22, "div", 15)(23, "p", 16), E(24, " \xa9 2024 FreePlayFinder. Todos os direitos reservados. "), m()()()()()()) }, dependencies: [wi, $g, Ia, jg], styles: ['.footer[_ngcontent-%COMP%]{background:linear-gradient(135deg,#667eea,#764ba2);color:#fff;padding:2rem 0 1rem;flex-shrink:0;position:relative;width:100%;box-shadow:0 -4px 20px #667eea26}.footer[_ngcontent-%COMP%]:before{content:"";position:absolute;top:0;left:0;right:0;height:1px;background:linear-gradient(90deg,transparent,rgba(255,255,255,.3),transparent)}.footer[_ngcontent-%COMP%]   .footer-brand[_ngcontent-%COMP%]   .brand-icon[_ngcontent-%COMP%]{background:#fff3;border-radius:50%;width:50px;height:50px;display:flex;align-items:center;justify-content:center;box-shadow:0 4px 15px #fff3;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,.3)}.footer[_ngcontent-%COMP%]   .footer-brand[_ngcontent-%COMP%]   .brand-icon[_ngcontent-%COMP%]   i[_ngcontent-%COMP%]{font-size:1.2rem;color:#fff}.footer[_ngcontent-%COMP%]   .footer-brand[_ngcontent-%COMP%]   .brand-text[_ngcontent-%COMP%]{color:#fff;font-weight:700;font-size:1.3rem;text-shadow:0 2px 4px rgba(0,0,0,.1)}.footer[_ngcontent-%COMP%]   .footer-links[_ngcontent-%COMP%]{display:flex;gap:1.5rem;justify-content:flex-end}.footer[_ngcontent-%COMP%]   .footer-links[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{color:#ffffffe6;text-decoration:none;font-weight:500;transition:all .3s ease;position:relative;padding:.5rem 1rem;border-radius:.5rem}.footer[_ngcontent-%COMP%]   .footer-links[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:hover{color:#fff;background:#ffffff1a;transform:translateY(-2px);-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px)}.footer[_ngcontent-%COMP%]   .footer-links[_ngcontent-%COMP%]   a.active[_ngcontent-%COMP%]{color:#fff;background:#fff3;font-weight:600;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px)}.footer[_ngcontent-%COMP%]   .footer-links[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:after{content:"";position:absolute;bottom:-2px;left:50%;width:0;height:2px;background:#fff;transition:all .3s ease;transform:translate(-50%)}.footer[_ngcontent-%COMP%]   .footer-links[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:hover:after{width:80%}.footer[_ngcontent-%COMP%]   .social-links[_ngcontent-%COMP%]{display:flex;gap:1rem;justify-content:flex-end}.footer[_ngcontent-%COMP%]   .social-links[_ngcontent-%COMP%]   .social-link[_ngcontent-%COMP%]{background:#ffffff1a;border-radius:50%;width:35px;height:35px;display:flex;align-items:center;justify-content:center;color:#fff;text-decoration:none;transition:all .3s ease;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,.2)}.footer[_ngcontent-%COMP%]   .social-links[_ngcontent-%COMP%]   .social-link[_ngcontent-%COMP%]:hover{background:#fff3;transform:translateY(-3px);box-shadow:0 5px 15px #fff3;color:#fff}.footer[_ngcontent-%COMP%]   .social-links[_ngcontent-%COMP%]   .social-link[_ngcontent-%COMP%]   i[_ngcontent-%COMP%]{font-size:.9rem}.footer[_ngcontent-%COMP%]   .footer-bottom[_ngcontent-%COMP%]{border-top:1px solid rgba(255,255,255,.2);margin-top:1.5rem;padding-top:1rem}.footer[_ngcontent-%COMP%]   .footer-bottom[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{color:#fffc;font-weight:400}@media (max-width: 767.98px){.footer[_ngcontent-%COMP%]{padding:1.5rem 0 1rem}.footer[_ngcontent-%COMP%]   .footer-brand[_ngcontent-%COMP%]{margin-bottom:1rem}.footer[_ngcontent-%COMP%]   .footer-links[_ngcontent-%COMP%]{justify-content:center;margin-bottom:1rem}.footer[_ngcontent-%COMP%]   .social-links[_ngcontent-%COMP%]{justify-content:center}.footer[_ngcontent-%COMP%]   .footer-bottom[_ngcontent-%COMP%]{text-align:center}.footer[_ngcontent-%COMP%]   .footer-bottom[_ngcontent-%COMP%]   .col-md-6[_ngcontent-%COMP%]:last-child{margin-top:1rem}}'] }) } return e })(), D5 = (() => { class e { titleService; baseTitle = "FreePlayFinder"; constructor(t) { this.titleService = t } setTitle(t) { this.titleService.setTitle(t ? `${this.baseTitle} - ${t}` : this.baseTitle) } setBaseTitle() { this.titleService.setTitle(this.baseTitle) } static \u0275fac = function (r) { return new (r || e)(x(TM)) }; static \u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); (function mB(e, n) { return A2({ rootComponent: e, ...SM(n) }) })((() => { class e { titleService; title = "FreePlayFinder"; constructor(t) { this.titleService = t } ngOnInit() { this.titleService.setBaseTitle() } static \u0275fac = function (r) { return new (r || e)(M(D5)) }; static \u0275cmp = gn({ type: e, selectors: [["app-root"]], standalone: !0, features: [Nn], decls: 4, vars: 0, consts: [[1, "flex-grow-1"]], template: function (r, o) { 1 & r && (k(0, "app-navbar"), y(1, "main", 0), k(2, "router-outlet"), m(), k(3, "app-footer")) }, dependencies: [Ng, $g, _5, C5] }) } return e })(), g5).catch(e => console.error(e)) } }, Bi => { Bi(Bi.s = 327) }]);